---
phase: 08-audio-sources-sinks
plan: 03
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - reticulum/src/main/java/com/lxmf/messenger/reticulum/audio/lxst/LineSink.kt
autonomous: true

must_haves:
  truths:
    - "LineSink plays decoded audio through speaker via KotlinAudioBridge"
    - "LineSink uses queue-based buffering with configurable depth"
    - "LineSink auto-starts playback when buffer reaches threshold"
    - "LineSink handles underrun by stopping after timeout (no silence insertion)"
    - "LineSink supports low-latency mode via bridge"
    - "Audio plays through speaker without pops or clicks"
    - "Low-latency mode activates PERFORMANCE_MODE_LOW_LATENCY in AudioTrack"
  artifacts:
    - path: "reticulum/src/main/java/com/lxmf/messenger/reticulum/audio/lxst/LineSink.kt"
      provides: "Speaker playback wrapping KotlinAudioBridge"
      min_lines: 150
      exports: ["LineSink"]
  key_links:
    - from: "LineSink.kt"
      to: "KotlinAudioBridge"
      via: "bridge.startPlayback/writeAudio/stopPlayback"
      pattern: "bridge\\.(startPlayback|writeAudio|stopPlayback)"
    - from: "LineSink.kt"
      to: "Source.kt"
      via: "canReceive(fromSource) backpressure check"
      pattern: "canReceive.*Source"
---

<objective>
Implement LineSink that wraps KotlinAudioBridge for speaker playback, matching Python LXST Sinks.py pattern.

Purpose: Plays decoded audio with queue-based buffering, underrun handling, low-latency mode (SINK-01, SINK-02 requirements)
Output: LineSink.kt with LinkedBlockingQueue buffering, autostart, underrun timeout, lag dropping
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-audio-sources-sinks/08-CONTEXT.md
@.planning/phases/08-audio-sources-sinks/08-RESEARCH.md
@.planning/phases/08-audio-sources-sinks/08-01-SUMMARY.md
@reticulum/src/main/java/com/lxmf/messenger/reticulum/audio/bridge/KotlinAudioBridge.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create LineSink.kt with queue-based buffering and autostart</name>
  <files>reticulum/src/main/java/com/lxmf/messenger/reticulum/audio/lxst/LineSink.kt</files>
  <action>
Create LineSink matching Python LXST Sinks.py:118-219 pattern.

Key implementation from 08-RESEARCH.md:

```kotlin
package com.lxmf.messenger.reticulum.audio.lxst

import android.util.Log
import com.lxmf.messenger.reticulum.audio.bridge.KotlinAudioBridge
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.SupervisorJob
import kotlinx.coroutines.cancel
import kotlinx.coroutines.delay
import kotlinx.coroutines.launch
import java.util.concurrent.LinkedBlockingQueue
import java.util.concurrent.TimeUnit
import java.util.concurrent.atomic.AtomicBoolean

/**
 * LineSink - Speaker playback for LXST audio pipeline.
 *
 * Wraps KotlinAudioBridge to provide LXST-compatible sink interface.
 * Uses queue-based buffering with autostart and underrun handling.
 *
 * Matches Python LXST Sinks.py LineSink class (lines 118-219).
 *
 * @param bridge KotlinAudioBridge instance for audio playback
 * @param autodigest Auto-start playback when buffer reaches minimum (default true)
 * @param lowLatency Enable low-latency AudioTrack mode (default false)
 */
class LineSink(
    private val bridge: KotlinAudioBridge,
    private val autodigest: Boolean = true,
    private val lowLatency: Boolean = false
) : LocalSink() {

    companion object {
        private const val TAG = "Columba:LineSink"

        // Buffer configuration (matches Python LXST Sinks.py:119-121)
        const val MAX_FRAMES = 6           // Queue depth
        const val AUTOSTART_MIN = 1        // Start playback when 1 frame ready
        const val FRAME_TIMEOUT_FRAMES = 8 // Stop after 8 frame times of underrun
    }

    // Frame queue (lock-free, thread-safe)
    private val frameQueue = LinkedBlockingQueue<FloatArray>(MAX_FRAMES)
    private val bufferMaxHeight = MAX_FRAMES - 3 // Backpressure threshold

    // Playback state
    private val isRunningFlag = AtomicBoolean(false)
    private val scope = CoroutineScope(Dispatchers.IO + SupervisorJob())

    // Audio configuration (detected from first frame or set explicitly)
    private var sampleRate: Int = 0
    private var channels: Int = 1
    private var frameTimeMs: Long = 20 // Default, updated from frame size

    /**
     * Check if sink can accept more frames.
     *
     * Matches Python LXST Sinks.py:129-134 pattern.
     * Uses lock-free queue size check for performance.
     *
     * @param fromSource Optional source reference (unused, for interface compatibility)
     * @return true if queue has room, false if backpressure active
     */
    override fun canReceive(fromSource: Source?): Boolean {
        return frameQueue.size < bufferMaxHeight
    }

    /**
     * Handle an incoming audio frame.
     *
     * Matches Python LXST Sinks.py:136-146 pattern:
     * 1. Add frame to queue (drop oldest if full)
     * 2. Auto-start playback if threshold reached
     *
     * @param frame Float32 audio samples (decoded)
     * @param source Optional source reference for sample rate detection
     */
    override fun handleFrame(frame: FloatArray, source: Source?) {
        // Detect sample rate from source on first frame
        if (sampleRate == 0) {
            sampleRate = source?.sampleRate ?: KotlinAudioBridge.DEFAULT_SAMPLE_RATE
            channels = source?.channels ?: 1
            Log.i(TAG, "LineSink detected: rate=$sampleRate, channels=$channels")
        }

        // Non-blocking offer, drop oldest if full (prevents blocking source)
        if (!frameQueue.offer(frame)) {
            frameQueue.poll() // Remove oldest frame
            frameQueue.offer(frame)
            Log.w(TAG, "Buffer overflow, dropped oldest frame")
        }

        // Auto-start playback when buffer has minimum frames
        if (autodigest && !isRunningFlag.get() && frameQueue.size >= AUTOSTART_MIN) {
            start()
        }
    }

    /**
     * Start playback.
     *
     * Matches Python LXST Sinks.py:148-155 pattern.
     */
    override fun start() {
        if (isRunningFlag.getAndSet(true)) {
            Log.w(TAG, "LineSink already running")
            return
        }

        Log.i(TAG, "Starting LineSink: rate=$sampleRate, channels=$channels, lowLatency=$lowLatency")

        // Start bridge playback
        bridge.startPlayback(
            sampleRate = sampleRate,
            channels = channels,
            lowLatency = lowLatency
        )

        // Launch digest coroutine
        scope.launch { digestJob() }
    }

    /**
     * Stop playback and clear buffers.
     *
     * Matches Python LXST Sinks.py:157-162 pattern.
     */
    override fun stop() {
        if (!isRunningFlag.getAndSet(false)) {
            Log.w(TAG, "LineSink not running")
            return
        }

        Log.i(TAG, "Stopping LineSink")
        frameQueue.clear()
        bridge.stopPlayback()
    }

    override fun isRunning(): Boolean = isRunningFlag.get()

    /**
     * Main playback loop - runs in coroutine.
     *
     * Matches Python LXST Sinks.py:178-217 __digest_job pattern:
     * 1. Poll frame from queue (with timeout)
     * 2. If frame available: convert to bytes, write to bridge, drop if lagging
     * 3. If no frame: track underrun, stop after timeout
     */
    private suspend fun digestJob() {
        Log.d(TAG, "Digest job started")
        var frameCount = 0L
        var underrunStartMs: Long? = null

        while (isRunningFlag.get()) {
            // Poll with timeout (10ms to stay responsive)
            val frame = frameQueue.poll(10, TimeUnit.MILLISECONDS)

            if (frame != null) {
                // Clear underrun state
                underrunStartMs = null
                frameCount++

                // Calculate frame time from first frame
                if (frameCount == 1L && sampleRate > 0) {
                    frameTimeMs = ((frame.size.toFloat() / sampleRate) * 1000).toLong()
                    Log.d(TAG, "Frame time: ${frameTimeMs}ms (${frame.size} samples at ${sampleRate}Hz)")
                }

                // Convert float32 to int16 bytes
                val frameBytes = float32ToBytes(frame)

                // Write to AudioTrack via bridge
                bridge.writeAudio(frameBytes)

                // Drop oldest if buffer is lagging (prevents increasing delay)
                if (frameQueue.size > bufferMaxHeight) {
                    frameQueue.poll()
                    Log.w(TAG, "Buffer lag, dropped oldest frame (height=${frameQueue.size})")
                }
            } else {
                // Underrun: no frames available
                if (underrunStartMs == null) {
                    underrunStartMs = System.currentTimeMillis()
                    Log.d(TAG, "Buffer underrun started")
                } else {
                    // Check timeout (stop playback after FRAME_TIMEOUT_FRAMES of silence)
                    val underrunDurationMs = System.currentTimeMillis() - underrunStartMs
                    val timeoutMs = frameTimeMs * FRAME_TIMEOUT_FRAMES

                    if (underrunDurationMs > timeoutMs) {
                        Log.i(TAG, "No frames for ${underrunDurationMs}ms, stopping playback")
                        isRunningFlag.set(false)
                    } else {
                        // Brief sleep during underrun (Python LXST Sinks.py:214-215)
                        delay(frameTimeMs / 10)
                    }
                }
            }
        }

        Log.d(TAG, "Digest job ended, played $frameCount frames")
        bridge.stopPlayback()
    }

    /**
     * Release resources.
     */
    fun release() {
        stop()
        scope.cancel()
    }

    /**
     * Configure sample rate explicitly (if not auto-detected from source).
     *
     * Call before start() if not using auto-detection.
     */
    fun configure(sampleRate: Int, channels: Int = 1) {
        this.sampleRate = sampleRate
        this.channels = channels
        Log.d(TAG, "LineSink configured: rate=$sampleRate, channels=$channels")
    }
}
```

Key implementation decisions:
1. **LinkedBlockingQueue**: Lock-free queue operations (no manual locks like Python)
2. **Non-blocking offer**: Drops oldest on overflow instead of blocking source
3. **Underrun stops playback**: Matches Python - no silence insertion (cleaner audio)
4. **Lag dropping**: If queue grows beyond threshold, drop oldest to prevent increasing delay
5. **Sample rate from source**: Auto-detect on first frame (matches Python pattern)
  </action>
  <verify>File exists, compiles: `cd /home/tyler/repos/public/columba && JAVA_HOME=/home/tyler/android-studio/jbr ./gradlew :reticulum:compileDebugKotlin 2>&1 | tail -20`</verify>
  <done>LineSink.kt exists with queue-based buffering, autostart, and underrun handling</done>
</task>

<task type="auto">
  <name>Task 2: Verify LineSink integrates with KotlinAudioBridge</name>
  <files>N/A</files>
  <action>
Run compilation and check for any integration issues:

```bash
cd /home/tyler/repos/public/columba
JAVA_HOME=/home/tyler/android-studio/jbr ./gradlew :reticulum:compileDebugKotlin --info 2>&1 | grep -E "(LineSink|error|Error|warning)" | head -30
```

Verify imports work correctly:
```bash
grep -n "import.*KotlinAudioBridge\|import.*Source\|import.*float32ToBytes" reticulum/src/main/java/com/lxmf/messenger/reticulum/audio/lxst/LineSink.kt
```

Check the complete file structure:
```bash
ls -la reticulum/src/main/java/com/lxmf/messenger/reticulum/audio/lxst/
```
  </action>
  <verify>Gradle compiles successfully, imports resolve correctly, all 4 files exist</verify>
  <done>LineSink compiles and integrates with KotlinAudioBridge</done>
</task>

</tasks>

<verification>
- [ ] LineSink.kt exists in lxst package
- [ ] LineSink extends LocalSink
- [ ] canReceive() returns false when queue near full
- [ ] handleFrame() adds to queue, drops oldest if full, auto-starts if threshold
- [ ] start() calls bridge.startPlayback() and launches coroutine
- [ ] stop() clears queue and calls bridge.stopPlayback()
- [ ] digestJob() polls queue, writes to bridge, handles underrun
- [ ] Module compiles without errors
</verification>

<success_criteria>
LineSink plays decoded audio via KotlinAudioBridge with queue buffering and underrun handling (SINK-01, SINK-02)
</success_criteria>

<output>
After completion, create `.planning/phases/08-audio-sources-sinks/08-03-SUMMARY.md`
</output>
