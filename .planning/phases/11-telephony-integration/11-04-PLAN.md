---
phase: 11-telephony-integration
plan: 04
type: execute
wave: 4
depends_on: ["11-02", "11-03"]
files_modified:
  - python/lxst_modules/call_manager.py
  - reticulum/src/main/java/com/lxmf/messenger/reticulum/wrapper/PythonWrapperManager.kt
autonomous: true

must_haves:
  truths:
    - "Kotlin Telephone can initiate calls through Python bridge"
    - "Python call_manager receives state change notifications from Kotlin"
    - "Profile changes sync bidirectionally"
  artifacts:
    - path: "python/lxst_modules/call_manager.py"
      provides: "Updated call_manager with Kotlin Telephone integration"
      contains: ["receive_audio_packet", "receive_signal", "on_profile_changed", "on_state_changed"]
    - path: "reticulum/src/main/java/com/lxmf/messenger/reticulum/wrapper/PythonWrapperManager.kt"
      provides: "Kotlin Telephone initialization in wrapper"
      contains: ["setupTelephone", "PythonNetworkTransport"]
  key_links:
    - from: "PythonWrapperManager.kt"
      to: "Telephone"
      via: "initialization"
      pattern: "Telephone\\("
    - from: "call_manager.py"
      to: "kotlin_telephone"
      via: "on_state_changed callback"
      pattern: "on_state_changed|on_profile_changed"
---

<objective>
Wire Kotlin Telephone to Python call_manager for bidirectional communication.

Purpose: Complete the Kotlin-Python integration so Telephone can make calls through Reticulum while Python handles network transport.

Output:
- Updated call_manager.py with Kotlin callback methods
- Updated PythonWrapperManager.kt to initialize Telephone
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-telephony-integration/11-RESEARCH.md
@.planning/phases/11-telephony-integration/11-CONTEXT.md

# Prior plans
@.planning/phases/11-telephony-integration/11-01-SUMMARY.md
@.planning/phases/11-telephony-integration/11-02-SUMMARY.md
@.planning/phases/11-telephony-integration/11-03-SUMMARY.md

# Reference files
@python/lxst_modules/call_manager.py
@reticulum/src/main/java/com/lxmf/messenger/reticulum/wrapper/PythonWrapperManager.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update call_manager.py for Kotlin Telephone integration</name>
  <files>python/lxst_modules/call_manager.py</files>
  <action>
Update `python/lxst_modules/call_manager.py` to support bidirectional communication with Kotlin Telephone.

**Add new instance variable in __init__:**
```python
self._kotlin_telephone_callback = None  # Callback to notify Kotlin of state changes
```

**Add Kotlin callback setter:**
```python
def set_kotlin_telephone_callback(self, callback):
    """Set callback for notifying Kotlin Telephone of state changes.

    Called by PythonWrapperManager after Kotlin Telephone initialization.
    Callback receives (state: str, data: dict) tuples.
    """
    self._kotlin_telephone_callback = callback
    RNS.log("Kotlin Telephone callback set", RNS.LOG_DEBUG)
```

**Add methods for Kotlin -> Python notification (from CONTEXT.md):**

```python
def on_state_changed(self, state_code):
    """Called by Kotlin Telephone when call state changes.

    Kotlin drives state machine, Python is notified for network coordination.

    Args:
        state_code: Signalling status code (0x00-0x06)
    """
    RNS.log(f"Kotlin state change: {state_code:#04x}", RNS.LOG_DEBUG)
    # Update internal state if needed for network coordination
    # Python LXST Telephone handles network aspects

def on_profile_changed(self, profile_id):
    """Called by Kotlin Telephone when profile changes.

    Kotlin is single source of truth for profiles; push to Python.

    Args:
        profile_id: Profile ID (0x10-0x80)
    """
    RNS.log(f"Kotlin profile change: {profile_id:#04x}", RNS.LOG_DEBUG)
    # If we have an active call, update Python LXST profile
    if self.telephone and self.telephone.active_call:
        self.telephone.switch_profile(profile_id, from_signalling=True)
```

**Update receive_audio_packet and receive_signal stubs from Phase 10:**

The existing stubs have TODO comments. Update them to wire to LXST:

```python
def receive_audio_packet(self, packet_data):
    """Receive encoded audio packet from Kotlin.

    Called by Kotlin Packetizer (via PythonNetworkTransport) to deliver
    encoded frames to Python LXST for network transmission.

    Args:
        packet_data: bytes (codec header byte + encoded frame)
    """
    if self.telephone and self.telephone.active_call:
        # Forward to LXST Packetizer
        try:
            packetizer = getattr(self.telephone.active_call, 'packetizer', None)
            if packetizer:
                # LXST Packetizer sends to network
                packetizer.send(packet_data)
        except Exception as e:
            RNS.log(f"Error forwarding packet to LXST: {e}", RNS.LOG_ERROR)

def receive_signal(self, signal):
    """Receive signalling from Kotlin.

    Called by Kotlin SignallingReceiver to deliver signals to Python LXST
    for network transmission to remote peer.

    Args:
        signal: int signal value
    """
    if self.telephone and self.telephone.active_call:
        try:
            self.telephone.signal(signal, self.telephone.active_call)
        except Exception as e:
            RNS.log(f"Error forwarding signal to LXST: {e}", RNS.LOG_ERROR)
```

**Add method for Python -> Kotlin state notification:**

Modify existing callback handlers (_handle_ringing, _handle_established, etc.) to notify Kotlin:

```python
def _notify_kotlin(self, event, identity_hash=None, extra=None):
    """Notify Kotlin Telephone of event."""
    if self._kotlin_telephone_callback:
        try:
            data = {'identity': identity_hash}
            if extra:
                data.update(extra)
            self._kotlin_telephone_callback(event, data)
        except Exception as e:
            RNS.log(f"Error notifying Kotlin: {e}", RNS.LOG_ERROR)
```

Update _handle_established:
```python
def _handle_established(self, identity):
    # ... existing code ...
    self._notify_kotlin('established', identity_hash)
```

Similarly update other handlers.
  </action>
  <verify>
Python syntax valid:
```bash
python3 -m py_compile /home/tyler/repos/public/columba/python/lxst_modules/call_manager.py && echo "Syntax OK"
```
  </verify>
  <done>
call_manager.py updated with:
- on_state_changed() for Kotlin state notifications
- on_profile_changed() for profile sync
- receive_audio_packet() wired to LXST Packetizer
- receive_signal() wired to LXST signalling
- _notify_kotlin() for Python->Kotlin events
  </done>
</task>

<task type="auto">
  <name>Task 2: Update PythonWrapperManager to initialize Telephone</name>
  <files>reticulum/src/main/java/com/lxmf/messenger/reticulum/wrapper/PythonWrapperManager.kt</files>
  <action>
Update `reticulum/src/main/java/com/lxmf/messenger/reticulum/wrapper/PythonWrapperManager.kt` to create and wire Kotlin Telephone.

First, read the existing file to understand the current structure and initialization pattern.

**Add import:**
```kotlin
import com.lxmf.messenger.reticulum.call.telephone.Telephone
import com.lxmf.messenger.reticulum.call.telephone.PythonNetworkTransport
import com.lxmf.messenger.reticulum.call.telephone.Profile
```

**Add property:**
```kotlin
private var telephone: Telephone? = null
```

**Add initialization method (call after call_manager is initialized):**

```kotlin
/**
 * Initialize Kotlin Telephone with Python network transport.
 *
 * Creates PythonNetworkTransport wrapping NetworkPacketBridge and call_manager,
 * then creates Telephone using that transport.
 *
 * Call this after setupCallManager() completes.
 */
fun setupTelephone() {
    val callManager = callManagerPyObject ?: run {
        Log.e(TAG, "Cannot setup Telephone: call_manager not initialized")
        return
    }

    val networkBridge = NetworkPacketBridge.getInstance(context)
    val callBridge = CallBridge.getInstance()
    val audioBridge = KotlinAudioBridge.getInstance(context)

    // Create Python network transport
    val transport = PythonNetworkTransport(networkBridge, callManager)

    // Create Telephone
    telephone = Telephone(
        networkTransport = transport,
        audioBridge = audioBridge,
        callBridge = callBridge
    )

    // Set up Python -> Kotlin callback for state events
    callManager.callAttr("set_kotlin_telephone_callback") { event: String, data: Map<String, Any?> ->
        handlePythonEvent(event, data)
    }

    Log.i(TAG, "Kotlin Telephone initialized")
}

private fun handlePythonEvent(event: String, data: Map<String, Any?>) {
    when (event) {
        "ringing" -> {
            // Incoming call ringing notification
            val identity = data["identity"] as? String
            if (identity != null) {
                telephone?.onIncomingCall(identity)
            }
        }
        "established" -> {
            // Call established notification from Python
            // Kotlin Telephone already handling this via signalling
        }
        // Handle other events as needed
    }
}
```

**Add accessor for UI layer:**
```kotlin
fun getTelephone(): Telephone? = telephone
```

**Wire into existing initialization flow:**

Find where setupCallManager() is called and add setupTelephone() after it:
```kotlin
// In initialization sequence
setupCallManager()
setupTelephone()  // Add this line
```

**Add shutdown handling:**

In shutdown/cleanup method, add:
```kotlin
telephone?.hangup()
telephone = null
```
  </action>
  <verify>
Kotlin compiles:
```bash
cd /home/tyler/repos/public/columba && JAVA_HOME=/home/tyler/android-studio/jbr ./gradlew :reticulum:compileDebugKotlin 2>&1 | head -50
```
  </verify>
  <done>
PythonWrapperManager.kt updated with:
- setupTelephone() creating Telephone with PythonNetworkTransport
- getTelephone() accessor for UI layer
- Python callback handler for events
- Proper cleanup in shutdown
  </done>
</task>

</tasks>

<verification>
Both files compile/parse:
```bash
python3 -m py_compile /home/tyler/repos/public/columba/python/lxst_modules/call_manager.py && echo "Python OK"
cd /home/tyler/repos/public/columba && JAVA_HOME=/home/tyler/android-studio/jbr ./gradlew :reticulum:compileDebugKotlin 2>&1 | tail -10
```

Verify integration points exist:
```bash
grep -l "setupTelephone\|PythonNetworkTransport" /home/tyler/repos/public/columba/reticulum/src/main/java/com/lxmf/messenger/reticulum/wrapper/*.kt
grep -l "on_state_changed\|on_profile_changed" /home/tyler/repos/public/columba/python/lxst_modules/call_manager.py
```
</verification>

<success_criteria>
1. call_manager.py has on_state_changed() and on_profile_changed() methods
2. call_manager.py receive_audio_packet() forwards to LXST Packetizer
3. call_manager.py receive_signal() forwards to LXST signalling
4. PythonWrapperManager creates Telephone with PythonNetworkTransport
5. Bidirectional callback wiring complete
6. Both files compile/parse without errors
</success_criteria>

<output>
After completion, create `.planning/phases/11-telephony-integration/11-04-SUMMARY.md`
</output>
