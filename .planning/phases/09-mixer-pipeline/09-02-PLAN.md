---
phase: 09-mixer-pipeline
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - reticulum/src/main/java/com/lxmf/messenger/reticulum/audio/lxst/ToneSource.kt
autonomous: true

must_haves:
  truths:
    - "ToneSource generates continuous sine wave at specified frequency"
    - "Tone fades in smoothly on start (no click)"
    - "Tone fades out smoothly on stop (no click)"
    - "Gain can be adjusted smoothly without artifacts"
  artifacts:
    - path: "reticulum/src/main/java/com/lxmf/messenger/reticulum/audio/lxst/ToneSource.kt"
      provides: "Sine wave generator with easing"
      min_lines: 100
      contains: "class ToneSource"
  key_links:
    - from: "ToneSource.kt"
      to: "Source.kt"
      via: "extends LocalSource"
      pattern: "class ToneSource.*LocalSource"
    - from: "ToneSource.kt"
      to: "Codec.kt"
      via: "uses codec for encoding"
      pattern: "codec.*encode"
---

<objective>
Implement ToneSource class that generates dial tones with smooth fade in/out.

Purpose: ToneSource produces dial/busy tones for call feedback. Smooth easing prevents audible clicks when starting/stopping tones. Must match Python LXST Generators.py exactly.

Output: ToneSource.kt implementing LocalSource with sine wave generation, phase accumulator, configurable frequency/gain, and linear fade in/out (ease) functionality.
</objective>

<execution_context>
@/home/tyler/.claude/get-shit-done/workflows/execute-plan.md
@/home/tyler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/09-mixer-pipeline/09-RESEARCH.md

# Existing base classes
@reticulum/src/main/java/com/lxmf/messenger/reticulum/audio/lxst/Source.kt
@reticulum/src/main/java/com/lxmf/messenger/reticulum/audio/codec/Codec.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ToneSource class with sine wave generation</name>
  <files>reticulum/src/main/java/com/lxmf/messenger/reticulum/audio/lxst/ToneSource.kt</files>
  <action>
Create ToneSource.kt in the lxst package matching Python LXST Generators.py ToneSource (lines 11-134):

**Class declaration:**
```kotlin
class ToneSource(
    private val frequency: Float = DEFAULT_FREQUENCY,
    private var targetGain: Float = 0.1f,
    private val ease: Boolean = true,
    private val easeTimeMs: Float = EASE_TIME_MS,
    private val targetFrameMs: Int = DEFAULT_FRAME_MS,
    var codec: Codec? = null,
    var sink: Sink? = null,
    override val channels: Int = 1
) : LocalSource()
```

**Constants (from Python Generators.py:12-15):**
```kotlin
companion object {
    private const val TAG = "Columba:ToneSource"
    const val DEFAULT_FRAME_MS = 80
    const val DEFAULT_SAMPLE_RATE = 48000
    const val DEFAULT_FREQUENCY = 382f  // Hz, matches Python LXST (not 440Hz ITU-T)
    const val EASE_TIME_MS = 20f        // Fade duration in ms
}
```

**IMPORTANT:** Use 382Hz as default frequency to match Python LXST Telephony.py:118. User said "match Python LXST exactly" as guiding principle. Frequency is configurable if user wants 440Hz later.

**Properties:**
- `override var sampleRate: Int = DEFAULT_SAMPLE_RATE`
- `theta: Double = 0.0` - Phase accumulator (persists across frames!)
- `easeGain: Float = 0f` - Fade multiplier (0.0 to 1.0)
- `currentGain: Float = 0f` - Internal gain that converges to targetGain
- `easeStep: Float = 0f` - Per-sample fade increment
- `gainStep: Float = 0f` - Per-sample gain change increment
- `easingOut: Boolean = false` - True when fading out before stop
- `samplesPerFrame: Int = 0` - Calculated from codec/sample rate
- `frameTimeMs: Long = 0` - Calculated frame duration
- `scope: CoroutineScope` - For background generation coroutine
- `shouldRun: AtomicBoolean` - Generation thread flag

**Methods:**

1. `init {}` block:
   - Call calculateParameters() to set up from codec

2. `calculateParameters()` (private):
   - If codec set: sampleRate = codec.preferredSamplerate ?: DEFAULT_SAMPLE_RATE
   - samplesPerFrame = ((targetFrameMs / 1000f) * sampleRate).toInt()
   - frameTimeMs = ((samplesPerFrame.toFloat() / sampleRate) * 1000).toLong()
   - easeStep = 1.0f / (sampleRate * (easeTimeMs / 1000f))
   - gainStep = 0.02f / (sampleRate * (easeTimeMs / 1000f))

3. `start()`:
   - If already running: return
   - Set shouldRun = true
   - Set easeGain = if (ease) 0f else 1f (start silent if easing)
   - Set currentGain = 0f
   - Launch generateJob() coroutine

4. `stop()`:
   - If NOT ease: set shouldRun = false immediately
   - If ease: set easingOut = true (triggers fade out, job stops when done)

5. `isRunning(): Boolean`:
   - Return shouldRun.get() && !easingOut

6. `generateFrame(): FloatArray` (private, Python lines 95-123):
   - Create FloatArray(samplesPerFrame * channels)
   - Calculate step = (frequency * 2 * Math.PI) / sampleRate
   - For each sample n in 0 until samplesPerFrame:
     a. theta += step (accumulate phase)
     b. amplitude = (Math.sin(theta) * currentGain * easeGain).toFloat()
     c. Write amplitude to frame[n * channels + c] for each channel c
     d. Smooth gain transition:
        - If targetGain > currentGain: currentGain += gainStep, clamp
        - If targetGain < currentGain: currentGain -= gainStep, clamp
     e. Ease in/out (if ease enabled):
        - If easeGain < 1.0f AND NOT easingOut: easeGain += easeStep, clamp to 1.0
        - If easingOut AND easeGain > 0.0f: easeGain -= easeStep
          - If easeGain <= 0: set easeGain = 0, easingOut = false, shouldRun.set(false)
   - Return frame

7. `generateJob()` (private suspend, Python lines 125-133):
   - While shouldRun.get():
     a. Get currentCodec and currentSink
     b. If both non-null AND sink.canReceive(this):
        - Generate frame: generateFrame()
        - Encode: currentCodec.encode(frameSamples)
        - Push: currentSink.handleFrame(encoded, this)
     c. delay(frameTimeMs / 10) for timing

8. `setGain(gain: Float)`:
   - Set targetGain = gain (will converge smoothly)

9. `release()`:
   - stop()
   - scope.cancel()

**Critical implementation notes:**
- theta MUST persist across frames (not reset per frame) for smooth tone
- Use Double for theta to avoid floating point drift over long tones
- Math.sin() is in radians
- easeGain ramps 0->1 on start, 1->0 on stop
- easingOut=true triggers fade, shouldRun=false only after fade completes
  </action>
  <verify>
Build compiles: `cd /home/tyler/repos/public/columba && ./gradlew :reticulum:compileDebugKotlin 2>&1 | tail -20`
File exists: `grep -c "class ToneSource" reticulum/src/main/java/com/lxmf/messenger/reticulum/audio/lxst/ToneSource.kt`
Has phase accumulator: `grep "theta" reticulum/src/main/java/com/lxmf/messenger/reticulum/audio/lxst/ToneSource.kt | head -3`
Has easing: `grep "easeGain" reticulum/src/main/java/com/lxmf/messenger/reticulum/audio/lxst/ToneSource.kt | head -3`
  </verify>
  <done>
ToneSource.kt exists with:
- 382Hz default frequency (matches Python LXST)
- Phase accumulator (theta) persists across frames
- Linear fade in/out via easeGain
- Smooth gain transitions via currentGain -> targetGain convergence
- Eased stop (fade out before stopping)
- Build compiles successfully
  </done>
</task>

<task type="auto">
  <name>Task 2: Handle handleFrame output format</name>
  <files>reticulum/src/main/java/com/lxmf/messenger/reticulum/audio/lxst/ToneSource.kt</files>
  <action>
Verify ToneSource output matches what Mixer/LineSink expect:

**Current flow (Phase 8):**
- LineSource encodes with codec, then decodes locally for loopback
- LineSink.handleFrame expects float32

**ToneSource flow:**
- ToneSource generates float32
- Encodes with codec
- Pushes encoded to sink

**Problem:** If sink is Mixer, Mixer.handleFrame expects decoded float32, not encoded bytes.

**Research says (09-RESEARCH.md lines 106-108):**
```python
if not decoded: frame_samples = source.codec.decode(frame)
else:           frame_samples = frame
```

Python Mixer decodes incoming frames. But our handleFrame signature is `handleFrame(frame: FloatArray, ...)` - it expects float32.

**Resolution:** ToneSource should push DECODED float32 to sink (matching LineSink expectations). The encode/decode is for wire format when going over network (Phase 10).

For Phase 9, ToneSource feeds into Mixer -> LineSink, all local. No encoding needed internally.

**Update generateJob():**
```kotlin
private suspend fun generateJob() {
    while (shouldRun.get()) {
        val currentSink = sink
        if (currentSink != null && currentSink.canReceive(this)) {
            val frameSamples = generateFrame()
            // Push float32 directly to sink (local playback path)
            // Encoding happens in transmit path (Mixer -> network), not here
            currentSink.handleFrame(frameSamples, this)
        }
        delay(frameTimeMs / 10)
    }
}
```

**Note:** Remove codec from generateJob for now. ToneSource output goes to Mixer, which handles encoding for network. Dial tone is local-only (speaker), doesn't need encoding.

If codec is needed later (for testing), add a `localPlayback: Boolean = true` flag:
- If localPlayback: push float32 directly
- If !localPlayback: encode then push (for network path)

For Phase 9: localPlayback = true (dial tone -> mixer -> speaker)
  </action>
  <verify>
Build compiles: `cd /home/tyler/repos/public/columba && ./gradlew :reticulum:compileDebugKotlin 2>&1 | tail -20`
handleFrame called with float32: `grep -A5 "handleFrame" reticulum/src/main/java/com/lxmf/messenger/reticulum/audio/lxst/ToneSource.kt`
  </verify>
  <done>
- ToneSource pushes float32 to sink (local playback path)
- No encoding in ToneSource (encoding is transmit path responsibility)
- Compatible with Mixer.handleFrame(float32) and LineSink.handleFrame(float32)
- Build compiles successfully
  </done>
</task>

</tasks>

<verification>
1. ToneSource.kt file exists with ~130+ lines
2. 382Hz default frequency (matches Python)
3. Phase accumulator persists across frames
4. Fade in on start (easeGain 0 -> 1)
5. Fade out on stop (easeGain 1 -> 0)
6. Build compiles: `./gradlew :reticulum:compileDebugKotlin`
</verification>

<success_criteria>
- GEN-01: ToneSource generates dial tones with smooth fade in/out
- 382Hz matches Python LXST (configurable if user wants 440Hz)
- Phase accumulator prevents discontinuities
- Eased stop prevents click on tone off
- Build compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/09-mixer-pipeline/09-02-SUMMARY.md`
</output>
