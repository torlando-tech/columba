---
phase: 09-mixer-pipeline
plan: 03
type: execute
wave: 2
depends_on: ["09-01", "09-02"]
files_modified:
  - reticulum/src/main/java/com/lxmf/messenger/reticulum/audio/lxst/Pipeline.kt
autonomous: true

must_haves:
  truths:
    - "Pipeline wires source.sink = sink for frame flow"
    - "Pipeline.start() delegates to source.start()"
    - "Pipeline.stop() delegates to source.stop()"
    - "Pipeline.running reflects source running state"
  artifacts:
    - path: "reticulum/src/main/java/com/lxmf/messenger/reticulum/audio/lxst/Pipeline.kt"
      provides: "Component orchestration wrapper"
      min_lines: 50
      contains: "class Pipeline"
  key_links:
    - from: "Pipeline.kt"
      to: "Source.kt"
      via: "holds source reference"
      pattern: "val source: Source"
    - from: "Pipeline.kt"
      to: "Sink.kt"
      via: "wires source to sink"
      pattern: "source.*sink"
---

<objective>
Implement Pipeline class that orchestrates source -> codec -> sink flow.

Purpose: Pipeline is the glue that wires audio components together. It provides unified start/stop lifecycle and component wiring. Must match Python LXST Pipeline.py exactly.

Output: Pipeline.kt that wires source.sink = sink, delegates start/stop to source, and exposes running state.
</objective>

<execution_context>
@/home/tyler/.claude/get-shit-done/workflows/execute-plan.md
@/home/tyler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/09-mixer-pipeline/09-RESEARCH.md

# Dependencies from Wave 1
@reticulum/src/main/java/com/lxmf/messenger/reticulum/audio/lxst/Mixer.kt
@reticulum/src/main/java/com/lxmf/messenger/reticulum/audio/lxst/ToneSource.kt
@reticulum/src/main/java/com/lxmf/messenger/reticulum/audio/lxst/Source.kt
@reticulum/src/main/java/com/lxmf/messenger/reticulum/audio/lxst/Sink.kt
@reticulum/src/main/java/com/lxmf/messenger/reticulum/audio/lxst/LineSource.kt
@reticulum/src/main/java/com/lxmf/messenger/reticulum/audio/lxst/LineSink.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Pipeline class for component orchestration</name>
  <files>reticulum/src/main/java/com/lxmf/messenger/reticulum/audio/lxst/Pipeline.kt</files>
  <action>
Create Pipeline.kt in the lxst package matching Python LXST Pipeline.py (lines 10-58):

**Class declaration:**
```kotlin
/**
 * Pipeline - Orchestrates audio component wiring and lifecycle.
 *
 * Matches Python LXST Pipeline.py structure. Pipeline is a thin wrapper
 * that wires source -> sink and provides unified start/stop.
 *
 * Pipeline delegates all work to source - it's pure coordination, no processing.
 *
 * @param source Audio source (LineSource, ToneSource, or Mixer)
 * @param codec Codec for encoding (optional, set on source if source supports it)
 * @param sink Audio sink (LineSink or Mixer)
 */
class Pipeline(
    val source: Source,
    codec: Codec,
    val sink: Sink
)
```

**Note on codec:** Python Pipeline.py sets codec on source (line 42-44). Our sources (LineSource, ToneSource, Mixer) have codec properties. Need to wire this.

**Properties:**
- `private var _codec: Codec? = null`

**init block (Python lines 20-31):**
Wire components in constructor:
```kotlin
init {
    // Wire source to sink (source pushes frames to sink)
    wireSourceToSink(source, sink)

    // Set codec (triggers codec setter)
    this.codec = codec
}
```

**wireSourceToSink helper (private):**
Different source types have different sink properties:
```kotlin
private fun wireSourceToSink(source: Source, sink: Sink) {
    when (source) {
        is LineSource -> source.sink = sink
        is Mixer -> source.sink = sink
        is ToneSource -> source.sink = sink
        else -> {
            // Try reflection or log warning for unknown source types
            Log.w(TAG, "Unknown source type: ${source::class.simpleName}, cannot wire sink")
        }
    }
}
```

**codec property (Python lines 33-44):**
```kotlin
var codec: Codec
    get() = _codec ?: throw IllegalStateException("Codec not set")
    set(value) {
        if (_codec != value) {
            _codec = value
            // Set codec on source if source supports it
            wireCodecToSource(source, value)
        }
    }

private fun wireCodecToSource(source: Source, codec: Codec) {
    when (source) {
        is LineSource -> {
            // LineSource codec is set in constructor, immutable
            // Log if mismatch
            if (source.codec != codec) {
                Log.w(TAG, "LineSource codec already set, cannot change dynamically")
            }
        }
        is ToneSource -> source.codec = codec
        is Mixer -> source.codec = codec
        else -> Log.w(TAG, "Unknown source type, cannot set codec")
    }
}
```

**Wait - LineSource doesn't have a public codec property.** Check LineSource.kt:
```kotlin
class LineSource(
    private val bridge: KotlinAudioBridge,
    private val codec: Codec,  // private val, not var
    ...
```

LineSource codec is immutable (set in constructor). This matches Python behavior - LineSource.codec is set at creation. Pipeline.codec setter should only affect sources that support runtime codec changes (ToneSource, Mixer).

**running property (Python lines 46-48):**
```kotlin
val running: Boolean
    get() = source.isRunning()
```

**start() (Python lines 50-52):**
```kotlin
fun start() {
    if (!running) {
        source.start()
    }
}
```

**stop() (Python lines 54-58):**
```kotlin
fun stop() {
    if (running) {
        source.stop()
    }
}
```

**Companion object:**
```kotlin
companion object {
    private const val TAG = "Columba:Pipeline"
}
```

**Full class should be ~60-80 lines** - Pipeline is intentionally thin.
  </action>
  <verify>
Build compiles: `cd /home/tyler/repos/public/columba && ./gradlew :reticulum:compileDebugKotlin 2>&1 | tail -20`
File exists: `grep -c "class Pipeline" reticulum/src/main/java/com/lxmf/messenger/reticulum/audio/lxst/Pipeline.kt`
Has start/stop: `grep -E "fun (start|stop)" reticulum/src/main/java/com/lxmf/messenger/reticulum/audio/lxst/Pipeline.kt`
Has running property: `grep "val running" reticulum/src/main/java/com/lxmf/messenger/reticulum/audio/lxst/Pipeline.kt`
  </verify>
  <done>
Pipeline.kt exists with:
- Constructor wires source.sink = sink
- codec property wired to source (where supported)
- start() delegates to source.start()
- stop() delegates to source.stop()
- running reflects source.isRunning()
- Build compiles successfully
  </done>
</task>

<task type="auto">
  <name>Task 2: Fix LineSource codec access for Pipeline compatibility</name>
  <files>reticulum/src/main/java/com/lxmf/messenger/reticulum/audio/lxst/LineSource.kt</files>
  <action>
Pipeline needs to read LineSource.codec to check for mismatches. Currently codec is `private val`.

Add a public getter without making it settable:

In LineSource.kt, change:
```kotlin
// FROM:
private val codec: Codec,

// TO:
private val _codec: Codec,
```

And add property:
```kotlin
/** Codec used for encoding (read-only, set in constructor) */
val codec: Codec
    get() = _codec
```

Then update all internal references from `codec` to `_codec`.

Alternatively, simpler approach - just make it a val with public getter:
```kotlin
// Keep as:
private val codec: Codec,
```

And Pipeline can skip codec check for LineSource (Python doesn't check either, it just sets). Pipeline.wireCodecToSource for LineSource case can be:
```kotlin
is LineSource -> {
    // LineSource codec immutable, no action needed
    // Codec was set in LineSource constructor
}
```

**Recommended:** Don't modify LineSource.kt. Pipeline should just accept that LineSource codec is already set. This matches Python behavior.

Update Pipeline.kt wireCodecToSource:
```kotlin
is LineSource -> {
    // LineSource codec is immutable (set in constructor)
    // No runtime codec change supported - this is by design
}
```
  </action>
  <verify>
Build compiles: `cd /home/tyler/repos/public/columba && ./gradlew :reticulum:compileDebugKotlin 2>&1 | tail -20`
No changes to LineSource: `git diff --name-only reticulum/src/main/java/com/lxmf/messenger/reticulum/audio/lxst/LineSource.kt || echo "unchanged"`
  </verify>
  <done>
- Pipeline handles LineSource codec gracefully (no-op)
- LineSource.kt unchanged (immutable codec by design)
- Build compiles successfully
  </done>
</task>

</tasks>

<verification>
1. Pipeline.kt file exists with ~60-80 lines
2. Constructor wires source.sink = sink
3. start() calls source.start()
4. stop() calls source.stop()
5. running returns source.isRunning()
6. Build compiles: `./gradlew :reticulum:compileDebugKotlin`
</verification>

<success_criteria>
- PIPE-01: Pipeline correctly wires source->codec->sink
- Pipeline is thin wrapper (no audio processing)
- start/stop delegates to source
- Build compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/09-mixer-pipeline/09-03-SUMMARY.md`
</output>
