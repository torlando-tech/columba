---
phase: 09-mixer-pipeline
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - reticulum/src/main/java/com/lxmf/messenger/reticulum/audio/lxst/Mixer.kt
autonomous: true

must_haves:
  truths:
    - "Multiple audio sources can push frames to Mixer"
    - "Mixer combines frames with global gain control"
    - "Mute prevents output (gain multiplier = 0)"
    - "Backpressure rejects frames when queue full"
    - "Mixer can be used as both Source (output) and Sink (input)"
  artifacts:
    - path: "reticulum/src/main/java/com/lxmf/messenger/reticulum/audio/lxst/Mixer.kt"
      provides: "Push-based audio mixer with dual Source/Sink behavior"
      min_lines: 120
      contains: "class Mixer"
  key_links:
    - from: "Mixer.kt"
      to: "Source.kt"
      via: "extends LocalSource"
      pattern: "class Mixer.*LocalSource"
    - from: "Mixer.kt"
      to: "Sink behavior"
      via: "implements canReceive and handleFrame directly"
      pattern: "fun canReceive.*fun handleFrame"
---

<objective>
Implement Mixer class that combines multiple audio sources with gain control.

Purpose: Mixer is the core audio combiner for voice calls - it mixes local mic + remote stream for receive path, and local sources for transmit path. Must match Python LXST Mixer.py exactly.

Output: Mixer.kt extending LocalSource and implementing Sink-like methods directly (canReceive, handleFrame) without modifying Sink.kt. This provides dual Source/Sink behavior through composition rather than multiple inheritance.
</objective>

<execution_context>
@/home/tyler/.claude/get-shit-done/workflows/execute-plan.md
@/home/tyler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/09-mixer-pipeline/09-RESEARCH.md

# Existing base classes (READ ONLY - do not modify)
@reticulum/src/main/java/com/lxmf/messenger/reticulum/audio/lxst/Source.kt
@reticulum/src/main/java/com/lxmf/messenger/reticulum/audio/lxst/Sink.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Mixer class with dual Source/Sink behavior</name>
  <files>reticulum/src/main/java/com/lxmf/messenger/reticulum/audio/lxst/Mixer.kt</files>
  <action>
Create Mixer.kt in the lxst package matching Python LXST Mixer.py (lines 14-177) structure.

**Implementation Pattern (Kotlin single inheritance solution):**
Mixer extends LocalSource (inherits Source behavior) and implements Sink methods DIRECTLY in the class body. This is NOT inheritance from Sink - it's direct method implementation that matches the Sink contract.

```kotlin
/**
 * Mixer - Combines multiple audio sources with gain control.
 *
 * Mixer acts as BOTH a Source (output mixed audio) AND a Sink (receive input frames).
 * Since Kotlin only allows single class inheritance, we:
 * - Extend LocalSource for Source behavior (sampleRate, channels, start, stop, isRunning)
 * - Implement Sink methods directly (canReceive, handleFrame) without extending Sink
 *
 * This matches Python LXST where Mixer inherits from both Source and Sink.
 * Callers can use Mixer as a Source, and manually call canReceive/handleFrame for Sink behavior.
 */
class Mixer(
    private val targetFrameMs: Int = 40,
    var codec: Codec? = null,
    var sink: Sink? = null,
    private var globalGain: Float = 0.0f  // dB, 0.0 = unity
) : LocalSource() {
    // Source properties (from LocalSource)
    override var sampleRate: Int = 0  // Auto-detected from first source
    override var channels: Int = 1

    // Sink-like methods implemented directly below
    // canReceive(fromSource: Source?): Boolean
    // handleFrame(frame: FloatArray, source: Source?)

    // ... rest of implementation
}
```

**Properties (from Python Mixer.py:14-39):**
- `incomingFrames: MutableMap<Source, ArrayDeque<FloatArray>>` - per-source queues
- `MAX_FRAMES = 8` - queue depth constant
- `insertLock: Any` - synchronization for queue access
- `shouldRun: AtomicBoolean` - mixer thread flag
- `muted: AtomicBoolean` - mute state
- `scope: CoroutineScope` - for background mixing coroutine

**Methods:**

1. `fun canReceive(fromSource: Source? = null): Boolean` (Python lines 66-70)
   - Sink-like method implemented directly (NOT via inheritance)
   - Return true if source not in map or queue size < MAX_FRAMES
   - Lock-free read for performance

2. `fun handleFrame(frame: FloatArray, source: Source? = null)` (Python lines 72-93)
   - Sink-like method implemented directly (NOT via inheritance)
   - Synchronized on insertLock
   - Create queue for new source
   - Auto-detect sampleRate/channels from first source
   - Add frame to queue (drop oldest if full with removeFirst())
   - Frame is already decoded float32 (from context research)

3. `mixingGain: Float` (property, Python lines 95-99)
   - If muted: return 0.0f
   - If globalGain == 0.0f: return 1.0f (unity)
   - Else: return 10f.pow(globalGain / 10f) (dB to linear)

4. `override fun start()` (Python lines 51-56)
   - Set shouldRun = true
   - Launch mixerJob() coroutine in scope

5. `override fun stop()` (Python lines 58-63)
   - Set shouldRun = false
   - Clear incomingFrames

6. `override fun isRunning(): Boolean` - return shouldRun.get()

7. `private suspend fun mixerJob()` (Python lines 101-139)
   - Loop while shouldRun
   - Check sink?.canReceive(this)
   - Pull one frame from each source queue (synchronized)
   - Mix: first frame * gain, then add subsequent frames * gain
   - Clip to [-1.0f, 1.0f] using coerceIn
   - If codec set: encode then push to sink
   - Else: push float32 directly to sink
   - If no frames: delay(targetFrameMs / 10)

8. `fun setGain(gain: Float)` - set globalGain
9. `fun mute(mute: Boolean = true)` - set muted flag

**Key implementation details:**
- Use `synchronized(insertLock)` for thread safety in handleFrame
- Use `ArrayDeque<FloatArray>()` with capacity MAX_FRAMES
- For mixing: `frames.zip(nextFrame) { a, b -> a + b * mixingGain }`
- Sample rate auto-detection happens on first handleFrame call
- Match Python exactly: global gain only (not per-source)

**IMPORTANT - DO NOT:**
- Do NOT modify Sink.kt in any way
- Do NOT create a SinkInterface
- Do NOT use delegation patterns or wrappers
- Just implement the 5 Sink methods directly in Mixer class body
  </action>
  <verify>
Build compiles: `cd /home/tyler/repos/public/columba && ./gradlew :reticulum:compileDebugKotlin 2>&1 | tail -20`
File exists and has expected structure: `grep -c "class Mixer" reticulum/src/main/java/com/lxmf/messenger/reticulum/audio/lxst/Mixer.kt`
Has canReceive: `grep "fun canReceive" reticulum/src/main/java/com/lxmf/messenger/reticulum/audio/lxst/Mixer.kt`
Has handleFrame: `grep "fun handleFrame" reticulum/src/main/java/com/lxmf/messenger/reticulum/audio/lxst/Mixer.kt`
Sink.kt unchanged: `git diff --name-only reticulum/src/main/java/com/lxmf/messenger/reticulum/audio/lxst/Sink.kt | wc -l` should be 0
  </verify>
  <done>
Mixer.kt exists with:
- Extends LocalSource (single inheritance)
- Implements canReceive and handleFrame DIRECTLY in class body
- Does NOT modify Sink.kt
- handleFrame accepts float32 and stores in per-source queues
- mixerJob combines frames with gain and clips to [-1.0, 1.0]
- mute() sets gain multiplier to 0
- canReceive provides backpressure
- Build compiles successfully
  </done>
</task>

</tasks>

<verification>
1. Mixer.kt file exists with ~150+ lines
2. Mixer extends LocalSource only (no Sink inheritance)
3. Mixer has canReceive and handleFrame methods implemented directly
4. Sink.kt is UNCHANGED from Phase 8
5. Mixer can accept frames via handleFrame
6. Mixer outputs mixed frames via background coroutine
7. mute() sets gain to 0 (silence)
8. Build compiles: `./gradlew :reticulum:compileDebugKotlin`
</verification>

<success_criteria>
- MIX-01 PARTIAL: Mixer combines frames with global gain (per-source not required by Python)
- MIX-02 PARTIAL: Mute implemented (receive/transmit split is in Telephone, not Mixer)
- Mixer.kt matches Python LXST Mixer.py structure
- Mixer has dual Source/Sink behavior WITHOUT modifying Phase 8 code
- Build compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/09-mixer-pipeline/09-01-SUMMARY.md`
</output>
