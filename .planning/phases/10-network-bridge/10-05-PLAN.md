---
phase: 10-network-bridge
plan: 05
type: execute
wave: 3
depends_on: ["10-01", "10-02", "10-03", "10-04"]
files_modified:
  - python/lxst_modules/call_manager.py
  - reticulum/src/main/java/com/lxmf/messenger/reticulum/wrapper/PythonWrapperManager.kt
autonomous: true

must_haves:
  truths:
    - "call_manager.py can send audio packets to Kotlin via network bridge"
    - "call_manager.py can receive audio packets from Kotlin via callback"
    - "PythonWrapperManager initializes NetworkPacketBridge at startup"
    - "Bridge is set on call_manager during initialization"
    - "Signalling flows bidirectionally through the bridge"
  artifacts:
    - path: "python/lxst_modules/call_manager.py"
      provides: "Python-side bridge integration"
      contains: "send_audio_packet"
    - path: "reticulum/src/main/java/com/lxmf/messenger/reticulum/wrapper/PythonWrapperManager.kt"
      provides: "Kotlin-side bridge initialization"
      contains: "NetworkPacketBridge"
  key_links:
    - from: "PythonWrapperManager"
      to: "NetworkPacketBridge.getInstance"
      via: "getInstance call during init"
      pattern: "NetworkPacketBridge\\.getInstance"
    - from: "PythonWrapperManager"
      to: "wrapper.callAttr.*set_network_bridge"
      via: "Python bridge setup"
      pattern: "set_network_bridge"
    - from: "call_manager.send_audio_packet"
      to: "kotlin_network_bridge.onPythonPacketReceived"
      via: "Chaquopy method call"
      pattern: "_kotlin_network_bridge.*onPython"
---

<objective>
Integrate NetworkPacketBridge with call_manager.py and PythonWrapperManager to complete the bidirectional bridge.

Purpose: Wire the Kotlin components (Plans 01-04) with the existing Python call infrastructure.
Output: Working end-to-end packet flow between Kotlin Pipeline and Python LXST/Reticulum.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-network-bridge/10-RESEARCH.md

# Phase 10 dependencies
@.planning/phases/10-network-bridge/10-01-SUMMARY.md
@.planning/phases/10-network-bridge/10-02-SUMMARY.md
@.planning/phases/10-network-bridge/10-03-SUMMARY.md
@.planning/phases/10-network-bridge/10-04-SUMMARY.md

# Existing integration patterns
@python/lxst_modules/call_manager.py
@reticulum/src/main/java/com/lxmf/messenger/reticulum/wrapper/PythonWrapperManager.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add network bridge methods to call_manager.py</name>
  <files>python/lxst_modules/call_manager.py</files>
  <action>
Add network bridge integration to CallManager class in call_manager.py:

1. Add new instance variable in __init__:
   ```python
   self._kotlin_network_bridge = None  # Set by Kotlin via initialize()
   ```

2. Update initialize() method signature to accept network bridge:
   ```python
   def initialize(self, audio_bridge, kotlin_call_bridge=None, kotlin_network_bridge=None):
       """Initialize the CallManager.

       Args:
           audio_bridge: KotlinAudioBridge instance
           kotlin_call_bridge: Optional CallBridge instance for state callbacks
           kotlin_network_bridge: Optional NetworkPacketBridge for packet transfer
       """
       self._audio_bridge = audio_bridge
       self._kotlin_call_bridge = kotlin_call_bridge
       self._kotlin_network_bridge = kotlin_network_bridge
       # ... rest of initialization
   ```

3. Add send_audio_packet method (called by Python LXST Packetizer):
   ```python
   def send_audio_packet(self, packet_data):
       """Send encoded audio packet to Kotlin.

       Called by Python LXST pipeline to deliver decoded frames to Kotlin.

       Args:
           packet_data: ByteArray (codec header byte + encoded frame)
       """
       if self._kotlin_network_bridge:
           try:
               self._kotlin_network_bridge.onPythonPacketReceived(packet_data)
           except Exception as e:
               RNS.log(f"Failed to send packet to Kotlin: {e}", RNS.LOG_ERROR)
   ```

4. Add send_signal method (called by Python LXST SignallingReceiver):
   ```python
   def send_signal(self, signal):
       """Send signalling to Kotlin.

       Called by Python LXST to deliver call signals to Kotlin.

       Args:
           signal: int signal value (STATUS_* or profile change)
       """
       if self._kotlin_network_bridge:
           try:
               self._kotlin_network_bridge.onPythonSignalReceived(signal)
           except Exception as e:
               RNS.log(f"Failed to send signal to Kotlin: {e}", RNS.LOG_ERROR)
   ```

5. Add method for Kotlin to send packets to Python (will be called from NetworkPacketBridge):
   These will be wired up to the Python LXST Telephone in Phase 11.
   For now, just log/stub:
   ```python
   def receive_audio_packet(self, packet_data):
       """Receive encoded audio packet from Kotlin.

       Called by Kotlin NetworkPacketBridge to deliver encoded frames to Python LXST.
       Will be wired to LXST Packetizer in Phase 11.

       Args:
           packet_data: bytes (codec header byte + encoded frame)
       """
       # TODO: Phase 11 will wire this to LXST Telephone's receive path
       RNS.log(f"Received audio packet from Kotlin ({len(packet_data)} bytes)", RNS.LOG_DEBUG)

   def receive_signal(self, signal):
       """Receive signalling from Kotlin.

       Called by Kotlin NetworkPacketBridge to deliver signals to Python LXST.
       Will be wired to LXST SignallingReceiver in Phase 11.

       Args:
           signal: int signal value
       """
       # TODO: Phase 11 will wire this to LXST Telephone's signalling
       RNS.log(f"Received signal from Kotlin: {signal:#04x}", RNS.LOG_DEBUG)
   ```

6. Update initialize_call_manager function to accept network bridge:
   ```python
   def initialize_call_manager(identity, audio_bridge, kotlin_call_bridge=None, kotlin_network_bridge=None):
       """Initialize the global CallManager.
       ...
       """
       global _call_manager
       with _call_manager_lock:
           if _call_manager is not None:
               RNS.log("CallManager already initialized", RNS.LOG_WARNING)
               return _call_manager

           _call_manager = CallManager(identity)
           _call_manager.initialize(audio_bridge, kotlin_call_bridge, kotlin_network_bridge)
           return _call_manager
   ```
  </action>
  <verify>
Python syntax check: `cd /home/tyler/repos/public/columba && python3 -m py_compile python/lxst_modules/call_manager.py`
Methods exist: `grep -E "send_audio_packet|send_signal|receive_audio_packet|receive_signal|kotlin_network_bridge" python/lxst_modules/call_manager.py`
  </verify>
  <done>
call_manager.py updated with:
- _kotlin_network_bridge instance variable
- initialize() accepts kotlin_network_bridge parameter
- send_audio_packet() and send_signal() for Python->Kotlin
- receive_audio_packet() and receive_signal() stubs for Kotlin->Python (Phase 11)
  </done>
</task>

<task type="auto">
  <name>Task 2: Initialize NetworkPacketBridge in PythonWrapperManager</name>
  <files>reticulum/src/main/java/com/lxmf/messenger/reticulum/wrapper/PythonWrapperManager.kt</files>
  <action>
Add NetworkPacketBridge initialization to PythonWrapperManager:

1. Add import:
   ```kotlin
   import com.lxmf.messenger.reticulum.audio.bridge.NetworkPacketBridge
   ```

2. Add instance variable alongside existing bridges:
   ```kotlin
   @Volatile
   private var networkPacketBridge: NetworkPacketBridge? = null
   ```

3. In initializePython() or wherever audio/call bridges are initialized, add:
   ```kotlin
   // Initialize network packet bridge (eager, per context decision)
   networkPacketBridge = NetworkPacketBridge.getInstance(context)
   ```

4. Where wrapper.callAttr("set_audio_bridge", ...) is called, add parallel registration:
   ```kotlin
   // Set network bridge on Python call_manager
   wrapper.callAttr("set_network_bridge", networkPacketBridge)
   ```

5. Add wrapper method for Python to call to set up its side:
   - Find where Python wrapper methods are set up
   - This should be handled by the Python call_manager accepting the bridge during initialize()

6. Update the call to initialize_call_manager to include network bridge:
   Look for existing pattern like:
   ```kotlin
   callManagerModule.callAttr("initialize_call_manager", identity, audioBridge, callBridge)
   ```
   Update to:
   ```kotlin
   callManagerModule.callAttr("initialize_call_manager", identity, audioBridge, callBridge, networkPacketBridge)
   ```

7. In shutdown/cleanup, add:
   ```kotlin
   networkPacketBridge?.shutdown()
   networkPacketBridge = null
   ```

IMPORTANT: Follow the existing patterns in PythonWrapperManager for bridge registration.
The exact method names and locations may vary - match the existing style.
  </action>
  <verify>
Build succeeds: `cd /home/tyler/repos/public/columba && JAVA_HOME=/home/tyler/android-studio/jbr ./gradlew :reticulum:compileDebugKotlin 2>&1 | tail -20`
Integration present: `grep -E "NetworkPacketBridge|networkPacketBridge|set_network_bridge" reticulum/src/main/java/com/lxmf/messenger/reticulum/wrapper/PythonWrapperManager.kt`
  </verify>
  <done>
PythonWrapperManager.kt updated with:
- NetworkPacketBridge import
- networkPacketBridge instance variable
- Initialization in appropriate location (eager startup)
- Bridge passed to call_manager during initialization
- Cleanup in shutdown path
  </done>
</task>

</tasks>

<verification>
1. Python compiles: `python3 -m py_compile python/lxst_modules/call_manager.py`
2. Kotlin builds: `./gradlew :reticulum:compileDebugKotlin`
3. call_manager.py has send_audio_packet and send_signal methods
4. PythonWrapperManager imports and initializes NetworkPacketBridge
5. Bridge passed to Python during initialization
</verification>

<success_criteria>
- call_manager.py compiles with new bridge methods
- PythonWrapperManager initializes NetworkPacketBridge at startup
- Bridge reference passed to Python call_manager
- Python can call Kotlin methods (send_audio_packet -> onPythonPacketReceived)
- Kotlin can call Python methods (sendPacket -> receive_audio_packet) [stubbed for Phase 11]
</success_criteria>

<output>
After completion, create `.planning/phases/10-network-bridge/10-05-SUMMARY.md`
</output>
