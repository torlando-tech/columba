---
phase: 05-memory-optimization
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - python/memory_profiler.py
  - python/reticulum_wrapper.py
  - app/build.gradle.kts
  - app/src/main/java/com/lxmf/messenger/service/manager/MemoryProfilerManager.kt
  - app/src/main/java/com/lxmf/messenger/service/ReticulumService.kt
autonomous: true

must_haves:
  truths:
    - "Memory profiling can be enabled via build flag (debug builds only)"
    - "tracemalloc snapshots are taken at 5-minute intervals when profiling enabled"
    - "Memory growth is observable via logcat output showing top allocations"
    - "Profiling has minimal overhead when disabled (no runtime cost)"
  artifacts:
    - path: "python/memory_profiler.py"
      provides: "Python tracemalloc snapshot manager"
      contains: "tracemalloc.start"
    - path: "app/src/main/java/com/lxmf/messenger/service/manager/MemoryProfilerManager.kt"
      provides: "Kotlin-side memory profiling coordinator"
      contains: "class MemoryProfilerManager"
    - path: "app/build.gradle.kts"
      provides: "ENABLE_MEMORY_PROFILING build config flag"
      contains: "ENABLE_MEMORY_PROFILING"
  key_links:
    - from: "app/src/main/java/com/lxmf/messenger/service/manager/MemoryProfilerManager.kt"
      to: "python/memory_profiler.py"
      via: "Chaquopy Python bridge"
      pattern: "wrapper.callAttr.*enable_memory_profiling"
    - from: "python/memory_profiler.py"
      to: "python/reticulum_wrapper.py"
      via: "Python import and function calls"
      pattern: "from memory_profiler import"
---

<objective>
Add memory profiling infrastructure using Python's tracemalloc with developer-only toggle.

Purpose: Enable detection of Python/Reticulum memory leaks causing ~1.4 MB/min growth. The profiling instrumentation stays in the codebase but has zero overhead when disabled.

Output: Working profiling system that takes snapshots every 5 minutes, compares to baseline, and logs top memory-growing allocations to logcat.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-memory-optimization/05-CONTEXT.md
@.planning/phases/05-memory-optimization/05-RESEARCH.md

# Key source files
@python/reticulum_wrapper.py (first 200 lines for structure)
@app/src/main/java/com/lxmf/messenger/service/manager/PythonWrapperManager.kt
@app/build.gradle.kts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Python memory profiler module</name>
  <files>python/memory_profiler.py, python/reticulum_wrapper.py</files>
  <action>
Create `python/memory_profiler.py` with tracemalloc-based profiling:

1. Create module with these functions:
   - `start_profiling(nframes=10)`: Start tracemalloc, store baseline snapshot
   - `take_snapshot()`: Take snapshot, compare to baseline, log top 10 growing allocations
   - `get_memory_stats()`: Return dict with current/peak memory, tracemalloc overhead
   - `stop_profiling()`: Stop tracemalloc, clear snapshots

2. Snapshot comparison should:
   - Filter out `<frozen importlib._bootstrap>` and `<unknown>` traces
   - Log to Android logcat via `log_info()` from `logging_utils.py`
   - Format: "Memory growth: +{size_diff} KiB at {filename}:{lineno}"

3. In `reticulum_wrapper.py`, add method to ReticulumWrapper class:
   - `enable_memory_profiling(interval_seconds=300)`: Start profiler, schedule periodic snapshots
   - `disable_memory_profiling()`: Stop profiler
   - `get_memory_profile()`: Return current stats as dict

IMPORTANT per RESEARCH.md Pitfall 1: Call `tracemalloc.start()` BEFORE any RNS/LXMF imports in reticulum_wrapper.py. Add early initialization hook that memory_profiler.py can call.

Use threading.Timer for periodic snapshots (not asyncio - Chaquopy compatibility).
  </action>
  <verify>
1. `python -c "import memory_profiler; memory_profiler.start_profiling(); print(memory_profiler.get_memory_stats())"` succeeds
2. No import errors when loading reticulum_wrapper.py
  </verify>
  <done>
Python memory profiler module exists with tracemalloc integration, can start/stop/snapshot profiling, and integrates with ReticulumWrapper class.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add build config flag and Kotlin profiler manager</name>
  <files>app/build.gradle.kts, app/src/main/java/com/lxmf/messenger/service/manager/MemoryProfilerManager.kt, app/src/main/java/com/lxmf/messenger/service/ReticulumService.kt</files>
  <action>
1. In `app/build.gradle.kts`, add BuildConfig field in buildTypes:
   ```kotlin
   debug {
       buildConfigField("Boolean", "ENABLE_MEMORY_PROFILING", "true")
   }
   release {
       buildConfigField("Boolean", "ENABLE_MEMORY_PROFILING", "false")
   }
   ```

2. Create `MemoryProfilerManager.kt` in service/manager/:
   ```kotlin
   class MemoryProfilerManager(
       private val wrapperManager: PythonWrapperManager,
       private val scope: CoroutineScope
   ) {
       private val TAG = "MemoryProfilerManager"

       fun startProfiling(intervalSeconds: Int = 300) {
           if (!BuildConfig.ENABLE_MEMORY_PROFILING) {
               Log.d(TAG, "Memory profiling disabled in this build")
               return
           }
           wrapperManager.withWrapper { wrapper ->
               wrapper.callAttr("enable_memory_profiling", intervalSeconds)
               Log.i(TAG, "Memory profiling started with ${intervalSeconds}s interval")
           }
       }

       fun stopProfiling() { ... }

       fun getMemoryStats(): Map<String, Any>? { ... }
   }
   ```

3. In `ReticulumService.kt`:
   - Add MemoryProfilerManager to ServiceModule.createManagers()
   - Call `memoryProfilerManager.startProfiling()` after Python initialization completes
   - Call `memoryProfilerManager.stopProfiling()` in onDestroy()

IMPORTANT: The manager should check `BuildConfig.ENABLE_MEMORY_PROFILING` before ANY Python calls to ensure zero overhead in release builds.
  </action>
  <verify>
1. `./gradlew assembleSentryDebug` completes successfully
2. `grep -r "ENABLE_MEMORY_PROFILING" app/build/` shows the flag in generated BuildConfig
3. No compilation errors in MemoryProfilerManager.kt
  </verify>
  <done>
Build config flag exists, MemoryProfilerManager coordinates Python profiling, and profiling auto-starts in debug builds after Reticulum initialization.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add dumpsys meminfo logging for correlation</name>
  <files>app/src/main/java/com/lxmf/messenger/service/manager/MemoryProfilerManager.kt</files>
  <action>
Extend MemoryProfilerManager to periodically log Android native heap info:

1. Add function to read and parse dumpsys meminfo:
   ```kotlin
   private fun logNativeHeapInfo() {
       try {
           val runtime = Runtime.getRuntime()
           val usedMemory = (runtime.totalMemory() - runtime.freeMemory()) / 1024 / 1024
           val maxMemory = runtime.maxMemory() / 1024 / 1024

           // Also get native heap from Debug class
           val nativeHeap = Debug.getNativeHeapAllocatedSize() / 1024 / 1024

           Log.i(TAG, "Memory: JVM=${usedMemory}MB/${maxMemory}MB, Native=${nativeHeap}MB")
       } catch (e: Exception) {
           Log.w(TAG, "Failed to get memory info: ${e.message}")
       }
   }
   ```

2. Schedule periodic native heap logging (every 5 minutes, aligned with Python snapshots):
   - Use CoroutineScope with delay() for scheduling
   - Log both JVM and native heap metrics together

3. Format output to be easily grep-able:
   ```
   MemoryProfilerManager: Memory: JVM=45MB/512MB, Native=120MB
   MemoryProfilerManager: Python growth: +1.2 MiB at reticulum_wrapper.py:450
   ```

This allows correlating Python heap growth with native heap growth per RESEARCH.md Pattern 2.
  </action>
  <verify>
1. Run app in debug mode, wait 5 minutes, check logcat:
   `adb logcat -s MemoryProfilerManager:I` shows memory stats
2. Both JVM and Native memory values are logged
  </verify>
  <done>
MemoryProfilerManager logs both Android native heap and Python tracemalloc stats at synchronized intervals for leak correlation.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. Build succeeds: `./gradlew assembleSentryDebug`
2. Install and run: `./gradlew installSentryDebug`
3. After ~5 minutes, check logcat: `adb logcat -s MemoryProfilerManager:I`
4. Should see periodic memory reports with Python allocation growth and native heap stats
5. Release build check: `./gradlew assembleSentryRelease` - no profiling code path executed
</verification>

<success_criteria>
- ENABLE_MEMORY_PROFILING build flag exists (true for debug, false for release)
- Python memory_profiler.py module with tracemalloc snapshot comparison
- MemoryProfilerManager coordinates Python + Android memory logging
- Profiling auto-starts in debug builds after Reticulum init
- 5-minute snapshot intervals log top memory-growing allocations
- Zero runtime overhead in release builds
</success_criteria>

<output>
After completion, create `.planning/phases/05-memory-optimization/05-01-SUMMARY.md`
</output>
