---
phase: 08-audio-sources-sinks
plan: 04
type: execute
wave: 3
depends_on: ["08-02", "08-03"]
files_modified:
  - reticulum/src/test/java/com/lxmf/messenger/reticulum/audio/lxst/LineSourceTest.kt
  - reticulum/src/test/java/com/lxmf/messenger/reticulum/audio/lxst/LineSinkTest.kt
  - reticulum/src/test/java/com/lxmf/messenger/reticulum/audio/lxst/DataConversionTest.kt
autonomous: true

must_haves:
  truths:
    - "LineSource frame size adjustment logic is tested for all codec constraint types"
    - "LineSink queue management logic is tested (canReceive, overflow, lag dropping)"
    - "Data conversion helpers are tested for accuracy (int16 <-> float32)"
    - "Tests use mocks for bridge and codec (no JNI required)"
  artifacts:
    - path: "reticulum/src/test/java/com/lxmf/messenger/reticulum/audio/lxst/LineSourceTest.kt"
      provides: "Unit tests for LineSource configuration logic"
      min_lines: 60
    - path: "reticulum/src/test/java/com/lxmf/messenger/reticulum/audio/lxst/LineSinkTest.kt"
      provides: "Unit tests for LineSink queue management"
      min_lines: 80
    - path: "reticulum/src/test/java/com/lxmf/messenger/reticulum/audio/lxst/DataConversionTest.kt"
      provides: "Unit tests for bytesToFloat32/float32ToBytes"
      min_lines: 50
  key_links:
    - from: "LineSourceTest.kt"
      to: "LineSource.kt"
      via: "Tests frame adjustment logic"
      pattern: "adjustFrameTime|samplesPerFrame"
    - from: "LineSinkTest.kt"
      to: "LineSink.kt"
      via: "Tests canReceive/handleFrame"
      pattern: "canReceive|handleFrame"
---

<objective>
Create unit tests for configuration and queue management logic in LineSource and LineSink.

Purpose: Verify non-JNI logic works correctly (frame adjustment, queue management, data conversion)
Output: Unit tests that run without Android device, using mocks for bridge/codec
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-audio-sources-sinks/08-CONTEXT.md
@.planning/phases/08-audio-sources-sinks/08-RESEARCH.md
@.planning/phases/08-audio-sources-sinks/08-02-SUMMARY.md
@.planning/phases/08-audio-sources-sinks/08-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create DataConversionTest.kt for bytesToFloat32/float32ToBytes</name>
  <files>reticulum/src/test/java/com/lxmf/messenger/reticulum/audio/lxst/DataConversionTest.kt</files>
  <action>
Create unit tests for the data conversion helpers in Sink.kt.

These functions are pure Kotlin (no JNI), so can be tested with standard JUnit.

```kotlin
package com.lxmf.messenger.reticulum.audio.lxst

import org.junit.Assert.assertArrayEquals
import org.junit.Assert.assertEquals
import org.junit.Test
import java.nio.ByteBuffer
import java.nio.ByteOrder
import kotlin.math.abs

/**
 * Unit tests for LXST data conversion utilities.
 *
 * Tests bytesToFloat32() and float32ToBytes() functions from Sink.kt.
 * These are pure Kotlin functions with no JNI dependencies.
 */
class DataConversionTest {

    companion object {
        private const val EPSILON = 0.0001f // Float comparison tolerance
    }

    @Test
    fun `bytesToFloat32 converts silence correctly`() {
        // Silence = all zeros
        val silenceBytes = ByteArray(8) // 4 samples
        val result = bytesToFloat32(silenceBytes)

        assertEquals(4, result.size)
        result.forEach { sample ->
            assertEquals(0f, sample, EPSILON)
        }
    }

    @Test
    fun `bytesToFloat32 converts max positive correctly`() {
        // Max positive int16 = 32767 = 0xFF7F in little-endian
        val bytes = byteArrayOf(0xFF.toByte(), 0x7F, 0xFF.toByte(), 0x7F)
        val result = bytesToFloat32(bytes)

        assertEquals(2, result.size)
        // 32767 / 32768 = 0.999969...
        result.forEach { sample ->
            assertEquals(0.9999f, sample, 0.001f)
        }
    }

    @Test
    fun `bytesToFloat32 converts max negative correctly`() {
        // Max negative int16 = -32768 = 0x0080 in little-endian (0x8000 big-endian)
        val bytes = byteArrayOf(0x00, 0x80.toByte(), 0x00, 0x80.toByte())
        val result = bytesToFloat32(bytes)

        assertEquals(2, result.size)
        // -32768 / 32768 = -1.0
        result.forEach { sample ->
            assertEquals(-1f, sample, EPSILON)
        }
    }

    @Test
    fun `float32ToBytes converts silence correctly`() {
        val samples = floatArrayOf(0f, 0f, 0f, 0f)
        val result = float32ToBytes(samples)

        assertEquals(8, result.size)
        result.forEach { byte ->
            assertEquals(0, byte.toInt())
        }
    }

    @Test
    fun `float32ToBytes converts max positive correctly`() {
        val samples = floatArrayOf(1f, 1f)
        val result = float32ToBytes(samples)

        // 1.0 * 32767 = 32767 = 0xFF7F little-endian
        assertEquals(4, result.size)
        val buffer = ByteBuffer.wrap(result).order(ByteOrder.LITTLE_ENDIAN)
        assertEquals(32767, buffer.short.toInt())
        assertEquals(32767, buffer.short.toInt())
    }

    @Test
    fun `float32ToBytes clamps values above 1`() {
        val samples = floatArrayOf(1.5f, 2.0f)
        val result = float32ToBytes(samples)

        val buffer = ByteBuffer.wrap(result).order(ByteOrder.LITTLE_ENDIAN)
        // Should clamp to 32767 (max int16)
        assertEquals(32767, buffer.short.toInt())
        assertEquals(32767, buffer.short.toInt())
    }

    @Test
    fun `float32ToBytes clamps values below -1`() {
        val samples = floatArrayOf(-1.5f, -2.0f)
        val result = float32ToBytes(samples)

        val buffer = ByteBuffer.wrap(result).order(ByteOrder.LITTLE_ENDIAN)
        // Should clamp to -32768 (min int16)
        // Note: -32768 as short then toInt preserves sign
        assertEquals(-32768, buffer.short.toInt())
        assertEquals(-32768, buffer.short.toInt())
    }

    @Test
    fun `round trip preserves data within tolerance`() {
        // Generate test samples
        val original = floatArrayOf(-1f, -0.5f, 0f, 0.5f, 0.999f)

        // Convert to bytes and back
        val bytes = float32ToBytes(original)
        val recovered = bytesToFloat32(bytes)

        assertEquals(original.size, recovered.size)
        for (i in original.indices) {
            // Quantization error is at most 1/32768 = ~0.00003
            assertEquals(original[i], recovered[i], 0.0001f)
        }
    }

    @Test
    fun `bytesToFloat32 handles empty array`() {
        val result = bytesToFloat32(ByteArray(0))
        assertEquals(0, result.size)
    }

    @Test
    fun `float32ToBytes handles empty array`() {
        val result = float32ToBytes(FloatArray(0))
        assertEquals(0, result.size)
    }
}
```

Key test cases:
- Silence (all zeros)
- Max positive/negative values
- Clamping for out-of-range values
- Round-trip preservation
- Edge cases (empty arrays)
  </action>
  <verify>Tests compile and pass: `cd /home/tyler/repos/public/columba && JAVA_HOME=/home/tyler/android-studio/jbr ./gradlew :reticulum:testDebugUnitTest --tests "*.DataConversionTest" 2>&1 | tail -30`</verify>
  <done>DataConversionTest.kt exists with tests for bytesToFloat32 and float32ToBytes</done>
</task>

<task type="auto">
  <name>Task 2: Create LineSinkTest.kt for queue management logic</name>
  <files>reticulum/src/test/java/com/lxmf/messenger/reticulum/audio/lxst/LineSinkTest.kt</files>
  <action>
Create unit tests for LineSink queue management.

Note: We cannot test the full playback loop (requires AudioTrack), but we can test:
- canReceive() backpressure logic
- handleFrame() queue behavior
- Buffer overflow handling

```kotlin
package com.lxmf.messenger.reticulum.audio.lxst

import android.content.Context
import android.media.AudioManager
import com.lxmf.messenger.reticulum.audio.bridge.KotlinAudioBridge
import io.mockk.every
import io.mockk.mockk
import io.mockk.verify
import org.junit.Assert.assertEquals
import org.junit.Assert.assertFalse
import org.junit.Assert.assertTrue
import org.junit.Before
import org.junit.Test

/**
 * Unit tests for LineSink queue management logic.
 *
 * Tests canReceive(), handleFrame(), and buffer overflow behavior.
 * Uses mocked KotlinAudioBridge to avoid JNI dependencies.
 */
class LineSinkTest {

    private lateinit var mockContext: Context
    private lateinit var mockAudioManager: AudioManager
    private lateinit var mockBridge: KotlinAudioBridge
    private lateinit var sink: LineSink

    @Before
    fun setup() {
        mockContext = mockk(relaxed = true)
        mockAudioManager = mockk(relaxed = true)
        mockBridge = mockk(relaxed = true)

        // Create sink with autodigest=false to prevent auto-start
        sink = LineSink(
            bridge = mockBridge,
            autodigest = false,
            lowLatency = false
        )
    }

    @Test
    fun `canReceive returns true when queue empty`() {
        assertTrue(sink.canReceive())
    }

    @Test
    fun `canReceive returns true below threshold`() {
        // Add frames below bufferMaxHeight (MAX_FRAMES - 3 = 3)
        repeat(2) {
            sink.handleFrame(FloatArray(480))
        }
        assertTrue(sink.canReceive())
    }

    @Test
    fun `canReceive returns false at threshold`() {
        // bufferMaxHeight = MAX_FRAMES - 3 = 6 - 3 = 3
        // Fill to threshold
        repeat(3) {
            sink.handleFrame(FloatArray(480))
        }
        assertFalse(sink.canReceive())
    }

    @Test
    fun `handleFrame adds frame to queue`() {
        val frame = FloatArray(480) { it.toFloat() }
        sink.handleFrame(frame)

        // Queue should have 1 frame
        assertTrue(sink.canReceive()) // Still has room
    }

    @Test
    fun `handleFrame drops oldest on overflow`() {
        // Fill queue completely (MAX_FRAMES = 6)
        repeat(LineSink.MAX_FRAMES) {
            sink.handleFrame(FloatArray(480) { it.toFloat() })
        }

        // Add one more - should drop oldest
        val newFrame = FloatArray(480) { 999f }
        sink.handleFrame(newFrame)

        // Queue should still be at MAX_FRAMES (not MAX_FRAMES + 1)
        // We can't directly check queue contents, but we can verify no exception
    }

    @Test
    fun `configure sets sample rate and channels`() {
        sink.configure(sampleRate = 8000, channels = 1)
        // Configuration is internal, but affects start() behavior
        // We verify it doesn't throw
    }

    @Test
    fun `isRunning returns false initially`() {
        assertFalse(sink.isRunning())
    }

    @Test
    fun `stop clears queue`() {
        // Add some frames
        repeat(3) {
            sink.handleFrame(FloatArray(480))
        }

        sink.stop()

        // Queue should be empty now
        assertTrue(sink.canReceive())
    }

    @Test
    fun `autodigest starts playback when threshold reached`() {
        // Create sink with autodigest=true
        val autoSink = LineSink(
            bridge = mockBridge,
            autodigest = true,
            lowLatency = false
        )
        autoSink.configure(48000, 1)

        // Add AUTOSTART_MIN frames (1)
        autoSink.handleFrame(FloatArray(480))

        // Should have auto-started
        assertTrue(autoSink.isRunning())

        // Cleanup
        autoSink.stop()
        autoSink.release()
    }

    @Test
    fun `lowLatency flag is passed to bridge`() {
        val lowLatencySink = LineSink(
            bridge = mockBridge,
            autodigest = false,
            lowLatency = true
        )
        lowLatencySink.configure(48000, 1)
        lowLatencySink.start()

        verify {
            mockBridge.startPlayback(
                sampleRate = 48000,
                channels = 1,
                lowLatency = true
            )
        }

        lowLatencySink.stop()
        lowLatencySink.release()
    }
}
```

Key test cases:
- canReceive() backpressure threshold
- handleFrame() queue add and overflow
- autodigest behavior
- lowLatency flag forwarding
  </action>
  <verify>Tests compile and pass: `cd /home/tyler/repos/public/columba && JAVA_HOME=/home/tyler/android-studio/jbr ./gradlew :reticulum:testDebugUnitTest --tests "*.LineSinkTest" 2>&1 | tail -30`</verify>
  <done>LineSinkTest.kt exists with tests for queue management</done>
</task>

<task type="auto">
  <name>Task 3: Create LineSourceTest.kt for frame adjustment logic</name>
  <files>reticulum/src/test/java/com/lxmf/messenger/reticulum/audio/lxst/LineSourceTest.kt</files>
  <action>
Create unit tests for LineSource frame size adjustment logic.

We cannot test the capture loop (requires AudioRecord), but we can test:
- Frame time adjustment for codec constraints
- Sample rate selection from codec
- Gain parameter handling

Note: LineSource constructor requires bridge.startRecording() not to throw, so we mock it.

```kotlin
package com.lxmf.messenger.reticulum.audio.lxst

import com.lxmf.messenger.reticulum.audio.bridge.KotlinAudioBridge
import com.lxmf.messenger.reticulum.audio.codec.Codec
import io.mockk.every
import io.mockk.mockk
import io.mockk.verify
import org.junit.Assert.assertEquals
import org.junit.Assert.assertFalse
import org.junit.Before
import org.junit.Test

/**
 * Unit tests for LineSource configuration logic.
 *
 * Tests frame size adjustment based on codec constraints.
 * Uses mocked KotlinAudioBridge and Codec to avoid JNI dependencies.
 */
class LineSourceTest {

    private lateinit var mockBridge: KotlinAudioBridge
    private lateinit var mockCodec: Codec

    @Before
    fun setup() {
        mockBridge = mockk(relaxed = true)
        mockCodec = mockk(relaxed = true)

        // Default codec with no constraints
        every { mockCodec.preferredSamplerate } returns null
        every { mockCodec.frameQuantaMs } returns null
        every { mockCodec.frameMaxMs } returns null
        every { mockCodec.validFrameMs } returns null
        every { mockCodec.encode(any()) } returns ByteArray(0)
        every { mockCodec.decode(any()) } returns FloatArray(0)
    }

    @Test
    fun `uses default sample rate when codec has no preference`() {
        val source = LineSource(
            bridge = mockBridge,
            codec = mockCodec,
            targetFrameMs = 20
        )

        assertEquals(48000, source.sampleRate)
        source.release()
    }

    @Test
    fun `uses codec preferred sample rate when specified`() {
        every { mockCodec.preferredSamplerate } returns 8000

        val source = LineSource(
            bridge = mockBridge,
            codec = mockCodec,
            targetFrameMs = 20
        )

        assertEquals(8000, source.sampleRate)
        source.release()
    }

    @Test
    fun `isRunning returns false initially`() {
        val source = LineSource(
            bridge = mockBridge,
            codec = mockCodec,
            targetFrameMs = 20
        )

        assertFalse(source.isRunning())
        source.release()
    }

    @Test
    fun `start calls bridge startRecording with correct parameters`() {
        every { mockCodec.preferredSamplerate } returns 48000

        val source = LineSource(
            bridge = mockBridge,
            codec = mockCodec,
            targetFrameMs = 20
        )

        source.start()

        // 20ms at 48kHz = 960 samples
        verify {
            mockBridge.startRecording(
                sampleRate = 48000,
                channels = 1,
                samplesPerFrame = 960
            )
        }

        source.stop()
        source.release()
    }

    @Test
    fun `stop calls bridge stopRecording`() {
        val source = LineSource(
            bridge = mockBridge,
            codec = mockCodec,
            targetFrameMs = 20
        )

        source.start()
        source.stop()

        verify { mockBridge.stopRecording() }
        source.release()
    }

    @Test
    fun `frame time quantized to codec frameQuantaMs`() {
        // Opus requires 2.5ms frame quanta
        every { mockCodec.frameQuantaMs } returns 2.5f
        every { mockCodec.preferredSamplerate } returns 48000

        val source = LineSource(
            bridge = mockBridge,
            codec = mockCodec,
            targetFrameMs = 21 // Not a multiple of 2.5
        )

        source.start()

        // 21ms should quantize up to 22.5ms -> rounds to 23ms with ceil
        // Actually: ceil(21 / 2.5) * 2.5 = ceil(8.4) * 2.5 = 9 * 2.5 = 22.5
        // Then samples = 22.5ms * 48000 / 1000 = 1080
        // But Int truncation: 22ms * 48000 / 1000 = 1056 or similar
        // Let's check what the implementation actually does

        verify {
            mockBridge.startRecording(
                sampleRate = 48000,
                channels = 1,
                samplesPerFrame = any() // We'll verify it's > 960 (20ms)
            )
        }

        source.stop()
        source.release()
    }

    @Test
    fun `frame time clamped to codec frameMaxMs`() {
        every { mockCodec.frameMaxMs } returns 60f
        every { mockCodec.preferredSamplerate } returns 48000

        val source = LineSource(
            bridge = mockBridge,
            codec = mockCodec,
            targetFrameMs = 120 // Exceeds max
        )

        source.start()

        // Should clamp to 60ms = 2880 samples at 48kHz
        verify {
            mockBridge.startRecording(
                sampleRate = 48000,
                channels = 1,
                samplesPerFrame = 2880
            )
        }

        source.stop()
        source.release()
    }

    @Test
    fun `frame time snapped to codec validFrameMs`() {
        every { mockCodec.validFrameMs } returns listOf(10f, 20f, 40f, 60f)
        every { mockCodec.preferredSamplerate } returns 48000

        val source = LineSource(
            bridge = mockBridge,
            codec = mockCodec,
            targetFrameMs = 35 // Between 20 and 40
        )

        source.start()

        // Should snap to nearest valid: 40ms = 1920 samples
        verify {
            mockBridge.startRecording(
                sampleRate = 48000,
                channels = 1,
                samplesPerFrame = 1920
            )
        }

        source.stop()
        source.release()
    }

    @Test
    fun `gain parameter stored for use in capture loop`() {
        val source = LineSource(
            bridge = mockBridge,
            codec = mockCodec,
            targetFrameMs = 20,
            gain = 2.0f
        )

        // Gain is applied in ingestJob, which we can't test without real audio
        // But we verify the constructor accepts it without error
        source.release()
    }
}
```

Key test cases:
- Sample rate from codec preferredSamplerate
- Frame time quantization (frameQuantaMs)
- Frame time clamping (frameMaxMs)
- Frame time snapping (validFrameMs)
- Gain parameter acceptance
  </action>
  <verify>Tests compile and pass: `cd /home/tyler/repos/public/columba && JAVA_HOME=/home/tyler/android-studio/jbr ./gradlew :reticulum:testDebugUnitTest --tests "*.LineSourceTest" 2>&1 | tail -30`</verify>
  <done>LineSourceTest.kt exists with tests for frame adjustment logic</done>
</task>

</tasks>

<verification>
- [ ] DataConversionTest.kt exists with tests for bytesToFloat32/float32ToBytes
- [ ] LineSinkTest.kt exists with tests for queue management
- [ ] LineSourceTest.kt exists with tests for frame adjustment
- [ ] All tests pass: `./gradlew :reticulum:testDebugUnitTest --tests "*.lxst.*"`
- [ ] Tests use mocks (no JNI/device required)
</verification>

<success_criteria>
Unit tests verify configuration logic works correctly without requiring Android device
</success_criteria>

<output>
After completion, create `.planning/phases/08-audio-sources-sinks/08-04-SUMMARY.md`
</output>
