---
phase: 11.6
plan: 01
title: Disable Python Audio When Kotlin Active
wave: 1
depends_on: [11.5-signal-bridge-fix]
files_modified:
  - python/lxst_modules/chaquopy_audio_backend.py
  - python/lxst_modules/call_manager.py
  - reticulum/src/main/java/com/lxmf/messenger/reticulum/call/telephone/Telephone.kt
  - reticulum/src/main/java/com/lxmf/messenger/reticulum/call/telephone/PythonNetworkTransport.kt
autonomous: true
estimated_minutes: 15
---

# Plan 11.6-01: Disable Python Audio When Kotlin Active

## Goal

Prevent dual audio pipeline conflict by disabling Python LXST audio sources/sinks when Kotlin LXST handles audio. This eliminates AudioFlinger BUFFER TIMEOUT errors and choppy audio during calls.

## Gap Being Closed

**Gap 2 from 11-VERIFICATION.md:** Dual Audio Pipeline Conflict (CRITICAL BLOCKER)

- Both Python LXST and Kotlin LXST try to use AudioTrack
- Python LXST continues capturing mic, encoding, sending packets
- AudioFlinger buffer underruns cause choppy audio
- Evidence: `üì° PKT.tx#201`, `üé§ LS: sink blocked!` logs during calls

## Existing Pattern

`chaquopy_audio_backend.py` already has `_kotlin_filters_active` flag that disables Python filters when Kotlin filters are active. We extend this pattern to the full audio pipeline.

## Tasks

<task id="1">
<title>Add _kotlin_audio_active flag to chaquopy_audio_backend.py</title>
<context>
chaquopy_audio_backend.py already has _kotlin_filters_active pattern. Add similar flag for full audio disable.
When _kotlin_audio_active is True:
- ChaquopyRecorder.record() returns silence (zeros)
- ChaquopyPlayer.play() drops frames (no-op)
This prevents Python LXST from reading mic or writing to speaker.
</context>
<files>python/lxst_modules/chaquopy_audio_backend.py</files>
<action>
1. Add global flag after _kotlin_filters_active:

```python
# Flag to completely disable Python/LXST audio when Kotlin LXST handles audio
# When True, recorder returns silence and player drops frames
_kotlin_audio_active = False
```

2. Add setter function:

```python
def set_kotlin_audio_active(active):
    """Enable/disable Python LXST audio pipeline.

    When active=True:
    - Kotlin LXST handles all audio
    - Python recorder returns silence
    - Python player drops frames

    Called by Kotlin Telephone when opening/closing pipelines.
    """
    global _kotlin_audio_active
    _kotlin_audio_active = active
    RNS.log(f"Kotlin audio active: {active} (Python LXST audio {'disabled' if active else 'enabled'})", RNS.LOG_INFO)


def is_kotlin_audio_active():
    """Check if Kotlin LXST is handling audio."""
    return _kotlin_audio_active
```

3. Modify ChaquopyRecorder._record_chunk() to return silence when Kotlin active:

At the start of _record_chunk(), before the bridge read:
```python
def _record_chunk(self):
    """Read a single chunk from the bridge."""
    ChaquopyRecorder._record_count += 1

    # If Kotlin LXST is handling audio, return silence
    if _kotlin_audio_active:
        if ChaquopyRecorder._record_count % 100 == 1:
            RNS.log(f"üéôÔ∏è Rec#{ChaquopyRecorder._record_count}: Kotlin audio active, returning silence", RNS.LOG_DEBUG)
        return np.zeros((self.samples_per_frame,), dtype="float32")

    # ... rest of existing code
```

4. Modify ChaquopyPlayer.play() to drop frames when Kotlin active:

At the start of play(), before the bridge write:
```python
def play(self, frame):
    """Play an audio frame."""
    if not self._started:
        # ... existing code
        return

    # If Kotlin LXST is handling audio, drop the frame
    if _kotlin_audio_active:
        ChaquopyPlayer._play_count += 1
        if ChaquopyPlayer._play_count % 100 == 1:
            RNS.log(f"üîä Player#{ChaquopyPlayer._play_count}: Kotlin audio active, dropping frame", RNS.LOG_DEBUG)
        return

    # ... rest of existing code
```
</action>
<verification>
- grep for "kotlin_audio_active" shows flag, setter, getter
- grep for "Kotlin audio active" shows log messages in recorder and player
</verification>
</task>

<task id="2">
<title>Add set_kotlin_audio_active() to CallManager</title>
<context>
Kotlin Telephone needs to call Python to enable/disable audio.
CallManager already has setter methods like set_kotlin_call_bridge().
Add wrapper method that calls chaquopy_audio_backend.set_kotlin_audio_active().
</context>
<files>python/lxst_modules/call_manager.py</files>
<action>
Add method to CallManager class (after set_kotlin_telephone_callback):

```python
def set_kotlin_audio_active(self, active):
    """Enable/disable Python LXST audio when Kotlin LXST handles audio.

    Called by Kotlin Telephone:
    - When call CONNECTING: set_kotlin_audio_active(True) - Kotlin opens pipelines
    - When call ENDED: set_kotlin_audio_active(False) - Python can process again

    Args:
        active: True when Kotlin handles audio, False when Python can process
    """
    from .chaquopy_audio_backend import set_kotlin_audio_active as _set_active
    _set_active(active)
    RNS.log(f"üìû Kotlin audio active: {active}", RNS.LOG_INFO)
```
</action>
<verification>
- grep for "set_kotlin_audio_active" in call_manager.py shows method
- Method delegates to chaquopy_audio_backend
</verification>
</task>

<task id="3">
<title>Add setKotlinAudioActive() to PythonNetworkTransport</title>
<context>
PythonNetworkTransport wraps Python CallManager. It needs method to call Python's set_kotlin_audio_active().
This is the bridge between Kotlin Telephone and Python audio disable.
</context>
<files>reticulum/src/main/java/com/lxmf/messenger/reticulum/call/telephone/PythonNetworkTransport.kt</files>
<action>
1. Add method to PythonNetworkTransport:

```kotlin
/**
 * Enable/disable Python LXST audio when Kotlin LXST handles audio.
 *
 * When true, Python recorder returns silence and player drops frames.
 * This prevents dual audio pipeline conflict.
 */
fun setKotlinAudioActive(active: Boolean) {
    CoroutineScope(Dispatchers.IO).launch {
        try {
            callManager.callAttr("set_kotlin_audio_active", active)
            Log.d(TAG, "Set Kotlin audio active: $active")
        } catch (e: Exception) {
            Log.e(TAG, "Error setting Kotlin audio active: ${e.message}")
        }
    }
}
```

Note: Use Dispatchers.IO to avoid blocking audio thread on Python GIL.
</action>
<verification>
- grep for "setKotlinAudioActive" in PythonNetworkTransport.kt
- Method calls Python via callAttr
</verification>
</task>

<task id="4">
<title>Call setKotlinAudioActive() from Kotlin Telephone</title>
<context>
Telephone.kt manages pipeline lifecycle. When pipelines open/close, it should notify Python.

Key state transitions:
- CONNECTING received ‚Üí openPipelines() ‚Üí setKotlinAudioActive(true)
- AVAILABLE received (call ended) ‚Üí closePipelines() ‚Üí setKotlinAudioActive(false)

The network transport is already passed to Telephone, so we cast and call.
</context>
<files>reticulum/src/main/java/com/lxmf/messenger/reticulum/call/telephone/Telephone.kt</files>
<action>
1. In openPipelines(), BEFORE opening Kotlin pipelines, disable Python audio:

```kotlin
private fun openPipelines() {
    // Disable Python LXST audio - Kotlin will handle it
    (networkTransport as? PythonNetworkTransport)?.setKotlinAudioActive(true)

    // ... existing pipeline opening code
}
```

2. In closePipelines(), AFTER closing Kotlin pipelines, re-enable Python audio:

```kotlin
private fun closePipelines() {
    // ... existing pipeline closing code

    // Re-enable Python LXST audio after Kotlin pipelines closed
    (networkTransport as? PythonNetworkTransport)?.setKotlinAudioActive(false)
}
```

Note: Use safe cast (as?) since NetworkTransport could be mocked in tests.
</action>
<verification>
- grep for "setKotlinAudioActive" in Telephone.kt shows two calls
- One in openPipelines(true), one in closePipelines(false)
</verification>
</task>

<task id="5">
<title>Add logging to verify Python audio disable</title>
<context>
For verification, we need to confirm:
1. Python receives the set_kotlin_audio_active(True) call
2. Python recorder/player see the flag and skip processing
3. No Python audio logs (üì° PKT.tx, üé§ LS:) during Kotlin calls

The instrumentation in lxst_debug_instrumentation.py logs audio flow.
When Kotlin audio is active, these logs should stop.
</context>
<files>python/lxst_modules/lxst_debug_instrumentation.py</files>
<action>
In instrumented_ingest_job() (LineSource), add early return when Kotlin audio active:

After `_counters['ls_ingest'] += 1`, add:

```python
# Check if Kotlin LXST is handling audio
try:
    from lxst_modules.chaquopy_audio_backend import is_kotlin_audio_active
    if is_kotlin_audio_active():
        if _counters['ls_ingest'] % 100 == 1:
            RNS.log(f"üé§ LS#{_counters['ls_ingest']}: Kotlin audio active, skipping ingest", RNS.LOG_DEBUG)
        time.sleep(self.frame_time)  # Maintain timing
        continue  # Skip this frame
except ImportError:
    pass  # Not on Android
```

This provides an additional safety layer - even if recorder doesn't return silence,
LineSource won't process frames when Kotlin is active.
</action>
<verification>
- During call, logcat should show:
  - "Kotlin audio active: True (Python LXST audio disabled)"
  - "üé§ LS#N: Kotlin audio active, skipping ingest" (every 100 frames)
- Should NOT show:
  - "üì° PKT.tx#" (Packetizer sending)
  - "üéõÔ∏è MIX.j#" (Mixer job)
  - "üé§ LS#N: raw=X.XXXX" (actual audio processing)
</verification>
</task>

## Verification Criteria

After implementing all tasks:

1. **Flag wiring verified:**
   - Kotlin Telephone calls setKotlinAudioActive(true) when CONNECTING
   - Python logs: "Kotlin audio active: True (Python LXST audio disabled)"

2. **Python audio disabled:**
   - No "üì° PKT.tx#" logs during Kotlin call (Python not sending packets)
   - No "üé§ LS: sink blocked!" logs (Python mic not saturated)
   - Only "üé§ LS#N: Kotlin audio active, skipping ingest" logs

3. **AudioFlinger stable:**
   - No "BUFFER TIMEOUT: remove track" errors
   - No choppy audio artifacts

4. **Call lifecycle works:**
   - When call ends, "Kotlin audio active: False" logged
   - Python can process audio again for next call

## must_haves

From Phase 11.6 success criteria in ROADMAP.md:

- [ ] Python LXST has `set_kotlin_audio_active(bool)` method ‚Äî Task 1, 2
- [ ] Kotlin Telephone calls this when opening/closing pipelines ‚Äî Task 3, 4
- [ ] No Python audio logs (`üì° PKT.tx`, `üé§ LS:`) during Kotlin calls ‚Äî Task 5
- [ ] No AudioFlinger BUFFER TIMEOUT errors during calls ‚Äî Verified via logcat

## Anti-patterns to Avoid

- Do NOT block audio thread waiting for Python response (use Dispatchers.IO)
- Do NOT remove Python audio code - just disable via flag (reversible)
- Do NOT modify LXST source directly - use flag in backend/instrumentation
- Keep Python audio capability for fallback if Kotlin fails
