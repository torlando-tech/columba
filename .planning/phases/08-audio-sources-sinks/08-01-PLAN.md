---
phase: 08-audio-sources-sinks
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - reticulum/src/main/java/com/lxmf/messenger/reticulum/audio/lxst/Source.kt
  - reticulum/src/main/java/com/lxmf/messenger/reticulum/audio/lxst/Sink.kt
autonomous: true

must_haves:
  truths:
    - "Source base class defines sampleRate and channels properties"
    - "Sink base class defines canReceive() and handleFrame() contract"
    - "LocalSource and LocalSink extend base classes for local audio I/O"
    - "Data conversion helpers exist for int16 bytes <-> float32 arrays"
  artifacts:
    - path: "reticulum/src/main/java/com/lxmf/messenger/reticulum/audio/lxst/Source.kt"
      provides: "Source, LocalSource base classes"
      min_lines: 30
    - path: "reticulum/src/main/java/com/lxmf/messenger/reticulum/audio/lxst/Sink.kt"
      provides: "Sink, LocalSink base classes with data conversion helpers"
      min_lines: 60
  key_links:
    - from: "Source.kt"
      to: "Sink.kt"
      via: "Sink.handleFrame accepts frames from Source"
      pattern: "handleFrame.*Source"
---

<objective>
Create base Source and Sink interfaces matching Python LXST class hierarchy, plus float32/int16 conversion utilities.

Purpose: Foundation classes for LineSource and LineSink implementations (plans 02-03)
Output: Source.kt with Source/LocalSource, Sink.kt with Sink/LocalSink plus bytesToFloat32/float32ToBytes helpers
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-audio-sources-sinks/08-CONTEXT.md
@.planning/phases/08-audio-sources-sinks/08-RESEARCH.md
@reticulum/src/main/java/com/lxmf/messenger/reticulum/audio/codec/Codec.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Source.kt with base class hierarchy</name>
  <files>reticulum/src/main/java/com/lxmf/messenger/reticulum/audio/lxst/Source.kt</files>
  <action>
Create new file matching Python LXST Sources.py structure (lines 121-123):

```kotlin
package com.lxmf.messenger.reticulum.audio.lxst

/**
 * Base Source interface for LXST audio pipeline.
 *
 * Matches Python LXST Sources.py structure. Sources capture audio
 * and push encoded frames to sinks.
 */
abstract class Source {
    /** Sample rate in Hz (e.g., 48000, 8000) */
    abstract var sampleRate: Int

    /** Number of audio channels (1 for mono, 2 for stereo) */
    abstract var channels: Int

    /** Start capturing audio */
    abstract fun start()

    /** Stop capturing audio */
    abstract fun stop()

    /** Check if source is currently capturing */
    abstract fun isRunning(): Boolean
}

/**
 * LocalSource - base class for local audio capture (microphone).
 *
 * Subclasses: LineSource (microphone)
 * Future: OpusFileSource (file playback) - out of scope for Phase 8
 */
abstract class LocalSource : Source()

/**
 * RemoteSource - base class for network audio (future).
 *
 * Used for receiving audio from remote peers via Reticulum links.
 * Out of scope for Phase 8.
 */
abstract class RemoteSource : Source()
```

Key points:
- Match Python LXST class hierarchy exactly
- sampleRate and channels are abstract properties (set by subclass from codec)
- start/stop/isRunning lifecycle methods match Python pattern
- RemoteSource stubbed for future (Phase 10 network bridge)
  </action>
  <verify>File exists at path, compiles without errors: `cd /home/tyler/repos/public/columba && JAVA_HOME=/home/tyler/android-studio/jbr ./gradlew :reticulum:compileDebugKotlin 2>&1 | tail -20`</verify>
  <done>Source.kt exists with Source, LocalSource, RemoteSource base classes</done>
</task>

<task type="auto">
  <name>Task 2: Create Sink.kt with base classes and conversion helpers</name>
  <files>reticulum/src/main/java/com/lxmf/messenger/reticulum/audio/lxst/Sink.kt</files>
  <action>
Create new file matching Python LXST Sinks.py structure (lines 111-116) plus data conversion helpers from research:

```kotlin
package com.lxmf.messenger.reticulum.audio.lxst

import java.nio.ByteBuffer
import java.nio.ByteOrder

/**
 * Base Sink interface for LXST audio pipeline.
 *
 * Matches Python LXST Sinks.py structure. Sinks receive decoded
 * audio frames and play them through audio hardware.
 */
abstract class Sink {
    /**
     * Check if sink can accept more frames.
     *
     * Used for backpressure - source checks before pushing.
     * Returns false when internal buffer is near full.
     *
     * @param fromSource Optional source reference for multi-source scenarios
     * @return true if sink can accept a frame, false if backpressure active
     */
    abstract fun canReceive(fromSource: Source? = null): Boolean

    /**
     * Handle an incoming audio frame.
     *
     * Called by source to push decoded audio. Frame format is float32
     * samples in range [-1.0, 1.0].
     *
     * @param frame Float32 audio samples
     * @param source Optional source reference
     */
    abstract fun handleFrame(frame: FloatArray, source: Source? = null)

    /** Start playback (if not auto-started) */
    abstract fun start()

    /** Stop playback and clear buffers */
    abstract fun stop()

    /** Check if sink is currently playing */
    abstract fun isRunning(): Boolean
}

/**
 * LocalSink - base class for local audio playback (speaker).
 *
 * Subclasses: LineSink (speaker)
 * Future: OpusFileSink (file recording) - out of scope for Phase 8
 */
abstract class LocalSink : Sink()

/**
 * RemoteSink - base class for network audio (future).
 *
 * Used for sending audio to remote peers via Reticulum links.
 * Out of scope for Phase 8.
 */
abstract class RemoteSink : Sink()

// ===== Data Conversion Utilities =====
// These convert between KotlinAudioBridge format (int16 bytes) and
// LXST pipeline format (float32 arrays).

/**
 * Convert int16 PCM bytes (little-endian) to float32 samples.
 *
 * Used by LineSource to convert AudioRecord output to pipeline format.
 *
 * @param bytes Raw int16 PCM bytes from AudioRecord
 * @return Float32 samples in range [-1.0, 1.0]
 */
fun bytesToFloat32(bytes: ByteArray): FloatArray {
    val buffer = ByteBuffer.wrap(bytes).order(ByteOrder.LITTLE_ENDIAN)
    return FloatArray(bytes.size / 2) { buffer.short / 32768f }
}

/**
 * Convert float32 samples to int16 PCM bytes (little-endian).
 *
 * Used by LineSink to convert pipeline format for AudioTrack.
 *
 * @param samples Float32 samples in range [-1.0, 1.0]
 * @return Raw int16 PCM bytes for AudioTrack
 */
fun float32ToBytes(samples: FloatArray): ByteArray {
    val buffer = ByteBuffer.allocate(samples.size * 2).order(ByteOrder.LITTLE_ENDIAN)
    samples.forEach { sample ->
        val clamped = sample.coerceIn(-1f, 1f)
        val int16 = (clamped * 32767f).toInt().toShort()
        buffer.putShort(int16)
    }
    return buffer.array()
}
```

Key points:
- canReceive() matches Python Sinks.py:129-134 pattern
- handleFrame() takes FloatArray (decoded audio, not encoded bytes)
- Conversion helpers match 08-RESEARCH.md examples (lines 486-500)
- Use coerceIn for clamping to prevent clipping artifacts
  </action>
  <verify>File exists at path, compiles without errors: `cd /home/tyler/repos/public/columba && JAVA_HOME=/home/tyler/android-studio/jbr ./gradlew :reticulum:compileDebugKotlin 2>&1 | tail -20`</verify>
  <done>Sink.kt exists with Sink, LocalSink, RemoteSink base classes plus bytesToFloat32/float32ToBytes helpers</done>
</task>

<task type="auto">
  <name>Task 3: Verify module compiles and classes are accessible</name>
  <files>N/A</files>
  <action>
Run full module compilation to verify:
1. Source.kt compiles
2. Sink.kt compiles
3. No import conflicts with existing code
4. Package structure matches plan (com.lxmf.messenger.reticulum.audio.lxst)

Commands:
```bash
cd /home/tyler/repos/public/columba
JAVA_HOME=/home/tyler/android-studio/jbr ./gradlew :reticulum:compileDebugKotlin --info 2>&1 | grep -E "(Source|Sink|lxst|error|Error)" | head -30
```

Verify the files exist in the expected location:
```bash
ls -la reticulum/src/main/java/com/lxmf/messenger/reticulum/audio/lxst/
```
  </action>
  <verify>Gradle compiles successfully, `ls` shows both Source.kt and Sink.kt</verify>
  <done>Module compiles, both files exist in lxst package</done>
</task>

</tasks>

<verification>
- [ ] Source.kt exists with Source, LocalSource, RemoteSource classes
- [ ] Sink.kt exists with Sink, LocalSink, RemoteSink classes
- [ ] bytesToFloat32() and float32ToBytes() functions exist in Sink.kt
- [ ] Module compiles without errors
- [ ] Package is com.lxmf.messenger.reticulum.audio.lxst
</verification>

<success_criteria>
Base interfaces compile and provide foundation for LineSource (08-02) and LineSink (08-03)
</success_criteria>

<output>
After completion, create `.planning/phases/08-audio-sources-sinks/08-01-SUMMARY.md`
</output>
