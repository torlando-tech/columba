---
phase: 07-codec-foundation
plan: 03
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - reticulum/src/main/java/com/lxmf/messenger/reticulum/audio/codec/Codec2.kt
  - reticulum/src/test/java/com/lxmf/messenger/reticulum/audio/codec/Codec2Test.kt
  - app/build.gradle.kts
autonomous: true

user_setup:
  - service: codec2-android
    why: "Codec2 encoding/decoding via JNI wrapper"
    gradle_dependency:
      - name: "com.ustadmobile.codec2:codec2-android:1.0.3"
        source: "Add to app/build.gradle.kts dependencies"
        note: "Verify exact artifact name/version via Maven Central or GitHub"

must_haves:
  truths:
    - "Codec2 encoder produces bit-identical output to Python pycodec2 for same input"
    - "All 7 modes (700C through 3200) encode successfully"
    - "Encoded packets have correct header byte (0x00-0x06) for wire format"
    - "Decode reverses encode (round-trip preserves audio quality)"
  artifacts:
    - path: "reticulum/src/main/java/com/lxmf/messenger/reticulum/audio/codec/Codec2.kt"
      provides: "Codec2 codec with all 7 modes"
      min_lines: 150
      exports: ["Codec2", "CODEC2_700C", "CODEC2_3200"]
    - path: "reticulum/src/test/java/com/lxmf/messenger/reticulum/audio/codec/Codec2Test.kt"
      provides: "Wire compatibility tests"
      min_lines: 80
  key_links:
    - from: "Codec2.encode()"
      to: "Codec2 JNI"
      via: "codec2-android library binding"
      pattern: "Codec2.*encode"
    - from: "Codec2.setMode()"
      to: "encoder config (samples_per_frame, bytes_per_frame)"
      via: "mode constant maps to frame parameters"
      pattern: "mode.*samples|bytes"
    - from: "Encoded packet"
      to: "header byte (0x00-0x06)"
      via: "MODE_HEADERS map prepends mode byte"
      pattern: "MODE_HEADERS.*to_bytes|header"
---

<objective>
Implement Codec2 codec in Kotlin with all 7 modes, producing wire-compatible output with Python LXST.

Purpose: Enable ultra-low-bitrate voice encoding (700 bps through 3200 bps) for bandwidth-constrained voice calls.

Output: Working Codec2.kt with encoder/decoder and unit tests verifying bit-identical output to Python pycodec2.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/07-codec-foundation/07-CONTEXT.md
@.planning/REQUIREMENTS.md

# Python reference implementation
@app/build/python/pip/noSentryDebug/common/LXST/Codecs/Codec2.py

# Depends on Plan 01
@.planning/phases/07-codec-foundation/07-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Add codec2-android dependency to build.gradle.kts</name>
  <files>app/build.gradle.kts</files>
  <action>
Add Codec2 library dependency to app/build.gradle.kts:

1. Search Maven Central for the correct artifact:
   - Try `com.ustadmobile.codec2:codec2-android` first
   - If not found, search GitHub for android-codec2 or codec2-android projects
   - Verify .so libraries are bundled (not downloaded at runtime)

2. Add to dependencies block:
```kotlin
dependencies {
    // ... existing dependencies ...

    // Codec2 codec for ultra-low-bitrate voice encoding
    implementation("com.ustadmobile.codec2:codec2-android:1.0.3") // Adjust version after Maven search
}
```

3. Sync Gradle and verify native libraries are included:
```bash
./gradlew :app:dependencies | grep codec2
```

If codec2-android is unavailable, research alternatives or check if opus-jni includes Codec2 support.

Do NOT proceed with stub implementation — make the recommended library work or block until user provides alternative.
  </action>
  <verify>
1. `./gradlew :app:dependencies` shows codec2 library
2. Native .so files present in APK (check with `unzip -l app/build/outputs/apk/debug/*.apk | grep libcodec2`)
  </verify>
  <done>Codec2 library added to dependencies and native libraries verified in build output.</done>
</task>

<task type="auto">
  <name>Implement Codec2.kt with all 7 modes</name>
  <files>reticulum/src/main/java/com/lxmf/messenger/reticulum/audio/codec/Codec2.kt</files>
  <action>
Create Codec2.kt matching Python LXST Codec2.py structure:

**Mode constants and header mapping (exactly match Python):**
```kotlin
class Codec2(mode: Int = CODEC2_2400) : Codec() {
    companion object {
        // Mode constants (match Python exactly)
        const val CODEC2_700C = 700
        const val CODEC2_1200 = 1200
        const val CODEC2_1300 = 1300
        const val CODEC2_1400 = 1400
        const val CODEC2_1600 = 1600
        const val CODEC2_2400 = 2400
        const val CODEC2_3200 = 3200

        const val INPUT_RATE = 8000
        const val OUTPUT_RATE = 8000
        const val FRAME_QUANTA_MS = 40f

        // Header byte mapping (critical for wire compatibility)
        val MODE_HEADERS = mapOf(
            CODEC2_700C to 0x00.toByte(),
            CODEC2_1200 to 0x01.toByte(),
            CODEC2_1300 to 0x02.toByte(),
            CODEC2_1400 to 0x03.toByte(),
            CODEC2_1600 to 0x04.toByte(),
            CODEC2_2400 to 0x05.toByte(),
            CODEC2_3200 to 0x06.toByte()
        )

        val HEADER_MODES = MODE_HEADERS.entries.associate { (k, v) -> v to k }
    }

    private var codec2: Codec2Encoder? = null  // Adjust type based on actual library API
    private var currentMode: Int = mode
    private var modeHeaderByte: Byte = 0x00

    init {
        frameQuantaMs = FRAME_QUANTA_MS
        preferredSamplerate = INPUT_RATE
        setMode(mode)
    }

    fun setMode(mode: Int) {
        currentMode = mode
        modeHeaderByte = MODE_HEADERS[mode] ?: throw CodecError("Invalid Codec2 mode: $mode")

        // Initialize/reinitialize codec2 encoder/decoder
        // API depends on actual library (pycodec2 uses: Codec2(mode))
        codec2?.destroy()  // Clean up old instance
        codec2 = Codec2Encoder(mode)  // Adjust constructor based on library
    }

    override fun encode(frame: FloatArray): ByteArray {
        // Convert FloatArray to int16 samples
        val int16Samples = frame.map { (it * 32767f).toInt().coerceIn(-32768, 32767).toShort() }

        // Codec2 expects mono 8kHz input
        // If frame is multi-channel, take first channel
        val monoSamples = if (frame.size > int16Samples.size) {
            int16Samples.take(int16Samples.size / 2)  // Assume stereo, take left
        } else {
            int16Samples
        }

        val samplesPerFrame = codec2?.samplesPerFrame() ?: throw CodecError("Codec2 not initialized")
        val numFrames = monoSamples.size / samplesPerFrame

        // Encode each frame
        val encoded = ByteArrayOutputStream()
        for (i in 0 until numFrames) {
            val frameStart = i * samplesPerFrame
            val frameEnd = (i + 1) * samplesPerFrame
            val frameSamples = monoSamples.subList(frameStart, frameEnd).toShortArray()

            val encodedFrame = codec2?.encode(frameSamples) ?: throw CodecError("Encode failed")
            encoded.write(encodedFrame)
        }

        // Prepend mode header byte (critical for wire format)
        return byteArrayOf(modeHeaderByte) + encoded.toByteArray()
    }

    override fun decode(frameBytes: ByteArray): FloatArray {
        if (frameBytes.isEmpty()) throw CodecError("Empty frame")

        // Extract header byte and adjust mode if needed
        val frameHeader = frameBytes[0]
        val encodedData = frameBytes.sliceArray(1 until frameBytes.size)

        val frameMode = HEADER_MODES[frameHeader] ?: currentMode
        if (frameMode != currentMode) {
            setMode(frameMode)
        }

        val samplesPerFrame = codec2?.samplesPerFrame() ?: throw CodecError("Codec2 not initialized")
        val bytesPerFrame = codec2?.bytesPerFrame() ?: throw CodecError("Codec2 not initialized")
        val numFrames = encodedData.size / bytesPerFrame

        // Decode each frame
        val decoded = mutableListOf<Short>()
        for (i in 0 until numFrames) {
            val frameStart = i * bytesPerFrame
            val frameEnd = (i + 1) * bytesPerFrame
            val encodedFrame = encodedData.sliceArray(frameStart until frameEnd)

            val decodedFrame = codec2?.decode(encodedFrame) ?: throw CodecError("Decode failed")
            decoded.addAll(decodedFrame.toList())
        }

        // Convert int16 to FloatArray
        return decoded.map { it / 32768f }.toFloatArray()
    }
}
```

**Critical notes:**
1. **Header byte is MANDATORY** — Python LXST prepends mode header to every packet. Kotlin MUST match this exactly (0x00-0x06).
2. **Codec2 is mono only** — always encode/decode as 1 channel.
3. **8kHz fixed** — Codec2 operates at 8kHz input/output.
4. **Frame alignment** — Codec2 has strict samples_per_frame requirements (varies by mode: 160, 320, etc.).

Adjust API calls (Codec2Encoder, samplesPerFrame, bytesPerFrame, encode, decode) based on actual library documentation.
  </action>
  <verify>
1. `./gradlew :reticulum:compileDebugKotlin` succeeds
2. All 7 modes instantiate without error
3. Encode produces ByteArray with correct header byte
4. Decode reverses encode (round-trip works)
  </verify>
  <done>Codec2.kt exists with all 7 modes, encoder/decoder configured correctly, header byte prepended, compilation succeeds.</done>
</task>

<task type="auto">
  <name>Create wire compatibility tests for Codec2</name>
  <files>reticulum/src/test/java/com/lxmf/messenger/reticulum/audio/codec/Codec2Test.kt</files>
  <action>
Create Codec2Test.kt with tests verifying wire compatibility:

**Test all modes instantiate:**
```kotlin
@Test
fun `all seven modes instantiate successfully`() {
    val modes = listOf(
        Codec2.CODEC2_700C, Codec2.CODEC2_1200, Codec2.CODEC2_1300,
        Codec2.CODEC2_1400, Codec2.CODEC2_1600, Codec2.CODEC2_2400,
        Codec2.CODEC2_3200
    )

    modes.forEach { mode ->
        val codec = Codec2(mode)
        assertNotNull(codec)
        assertEquals(mode, codec.currentMode)
    }
}
```

**Test header byte mapping:**
```kotlin
@Test
fun `encoded packet starts with correct mode header byte`() {
    val testCases = mapOf(
        Codec2.CODEC2_700C to 0x00.toByte(),
        Codec2.CODEC2_1200 to 0x01.toByte(),
        Codec2.CODEC2_2400 to 0x05.toByte(),
        Codec2.CODEC2_3200 to 0x06.toByte()
    )

    testCases.forEach { (mode, expectedHeader) ->
        val codec = Codec2(mode)
        val input = FloatArray(320) { 0.5f }  // Enough samples for any mode

        val encoded = codec.encode(input)
        assertTrue(encoded.isNotEmpty(), "Encoded packet is empty for mode $mode")
        assertEquals(expectedHeader, encoded[0], "Header byte mismatch for mode $mode")
    }
}
```

**Test encode-decode round-trip:**
```kotlin
@Test
fun `codec2 encode-decode roundtrip preserves audio`() {
    val codec = Codec2(Codec2.CODEC2_2400)

    // Generate 40ms of test audio at 8kHz (320 samples)
    val input = FloatArray(320) { sin(2.0 * PI * 440.0 * it / 8000.0).toFloat() }

    val encoded = codec.encode(input)
    val decoded = codec.decode(encoded)

    // Lossy codec, check correlation
    val correlation = correlate(input, decoded)
    assertTrue(correlation > 0.7f, "Round-trip correlation too low: $correlation")
}
```

**Test mode switching via header byte:**
```kotlin
@Test
fun `decoder switches mode based on header byte`() {
    val encoder2400 = Codec2(Codec2.CODEC2_2400)
    val decoder700C = Codec2(Codec2.CODEC2_700C)  // Start with different mode

    val input = FloatArray(320) { 0.5f }
    val encoded = encoder2400.encode(input)  // Has 0x05 header

    // Decoder should switch to 2400 mode when it sees 0x05 header
    val decoded = decoder700C.decode(encoded)
    assertNotNull(decoded)
    assertEquals(Codec2.CODEC2_2400, decoder700C.currentMode)
}
```

Run with: `JAVA_HOME=/home/tyler/android-studio/jbr ./gradlew :reticulum:testDebugUnitTest --tests Codec2Test`
  </action>
  <verify>`./gradlew :reticulum:testDebugUnitTest --tests Codec2Test` passes all tests</verify>
  <done>Codec2Test.kt exists with passing tests for all modes, header bytes, round-trip, and mode switching.</done>
</task>

</tasks>

<verification>
1. Codec2.kt compiles without errors
2. All 7 modes work correctly
3. Encode produces packets with correct header byte (0x00-0x06)
4. Decode reverses encode (lossy, but high correlation)
5. Decoder switches mode based on header byte
6. Unit tests pass
7. No crashes or JNI errors when encoding/decoding
</verification>

<success_criteria>
- Codec2 encoder produces wire-compatible output (bit-identical to Python pycodec2 for same input and mode)
- All 7 modes (700C through 3200) encode successfully
- Encoded packets have correct header byte prepended
- Encoder/decoder round-trip preserves audio fidelity (>70% correlation)
- Decoder correctly switches mode based on incoming packet header
- Native .so libraries bundled in APK
</success_criteria>

<output>
After completion, create `.planning/phases/07-codec-foundation/07-03-SUMMARY.md`
</output>
