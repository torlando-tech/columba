---
phase: 11.7-remove-python-lxst
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - python/lxst_modules/call_manager.py
  - python/lxst_modules/lxst_debug_instrumentation.py
  - python/lxst_modules/chaquopy_audio_backend.py
  - python/lxst_modules/__init__.py
autonomous: true

must_haves:
  truths:
    - "call_manager.py uses raw RNS.Link, RNS.Packet, RNS.Destination — never imports LXST"
    - "Audio packets use LXST-compatible msgpack wire format: {0x01: codec_byte + frame}"
    - "Signalling uses LXST-compatible msgpack wire format: {0x00: [signal_byte]}"
    - "Incoming calls go through identity verification and allow-list checking before notifying Kotlin"
    - "lxst_debug_instrumentation.py is deleted"
    - "chaquopy_audio_backend.py has no _kotlin_audio_active flag or related functions"
  artifacts:
    - path: "python/lxst_modules/call_manager.py"
      provides: "Raw Reticulum Link transport for call setup/teardown and packet forwarding"
      contains: "RNS.Destination"
    - path: "python/lxst_modules/chaquopy_audio_backend.py"
      provides: "Audio backend without Phase 11.6 flag code"
  key_links:
    - from: "python/lxst_modules/call_manager.py"
      to: "NetworkPacketBridge.kt"
      via: "send_audio_packet/send_signal -> onPythonPacketReceived/onPythonSignalReceived"
      pattern: "kotlin_network_bridge\\.onPython"
    - from: "python/lxst_modules/call_manager.py"
      to: "RNS.Link"
      via: "active_call = RNS.Link(destination, ...)"
      pattern: "RNS\\.Link\\("
---

<objective>
Rewrite Python call_manager.py to use raw Reticulum Link APIs with msgpack wire protocol, eliminating the Python LXST dependency. Delete LXST debug instrumentation. Clean Phase 11.6 flag code from chaquopy_audio_backend.py.

Purpose: This is the core work of Phase 11.7. After this plan, Python is a pure network transport layer — no LXST import, no Python audio pipelines. The wire protocol remains LXST-compatible for Sideband interop.

Output: Rewritten call_manager.py (~250-350 lines), deleted lxst_debug_instrumentation.py, cleaned chaquopy_audio_backend.py.
</objective>

<execution_context>
@/home/tyler/.claude/get-shit-done/workflows/execute-plan.md
@/home/tyler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11.7-remove-python-lxst/11.7-RESEARCH.md
@python/lxst_modules/call_manager.py
@python/lxst_modules/lxst_debug_instrumentation.py
@python/lxst_modules/chaquopy_audio_backend.py
@reticulum/src/main/java/com/lxmf/messenger/reticulum/audio/bridge/NetworkPacketBridge.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Rewrite call_manager.py with raw Reticulum Link APIs</name>
  <files>python/lxst_modules/call_manager.py</files>
  <action>
Completely rewrite call_manager.py to eliminate ALL LXST imports and use raw Reticulum Link APIs.

**STRUCTURE of new call_manager.py (~250-350 lines):**

1. **Constants section** (hard-coded, LXST-compatible):
```python
# LXST-compatible constants (frozen wire format for Sideband interop)
APP_NAME = "lxst"
PRIMITIVE_NAME = "telephony"
FIELD_SIGNALLING = 0x00
FIELD_FRAMES = 0x01

# Signalling status codes (match Kotlin Signalling.kt exactly)
STATUS_BUSY = 0x00
STATUS_REJECTED = 0x01
STATUS_CALLING = 0x02
STATUS_AVAILABLE = 0x03
STATUS_RINGING = 0x04
STATUS_CONNECTING = 0x05
STATUS_ESTABLISHED = 0x06
PREFERRED_PROFILE = 0xFF
```

2. **Module-level functions** — keep `get_call_manager()`, `initialize_call_manager()`, `shutdown_call_manager()` with same signatures. CHANGE `initialize_call_manager` to NOT take `audio_bridge` param (Python no longer touches audio). Keep `kotlin_call_bridge` and `kotlin_network_bridge` params.

3. **CallManager class** — rewrite completely:

**__init__(self, identity):**
- Store identity, bridges, state
- self.active_call = None (RNS.Link instance)
- self.destination = None (RNS.Destination for incoming)
- self._busy = False
- self._kotlin_call_bridge, self._kotlin_network_bridge
- self._kotlin_telephone_callback

**initialize(self, kotlin_call_bridge=None, kotlin_network_bridge=None):**
- Store bridges
- Register incoming call destination:
  ```python
  self.destination = RNS.Destination(
      self.identity, RNS.Destination.IN, RNS.Destination.SINGLE,
      APP_NAME, PRIMITIVE_NAME
  )
  self.destination.set_proof_strategy(RNS.Destination.PROVE_NONE)
  self.destination.set_link_established_callback(self.__incoming_link_established)
  ```
- self._initialized = True
- NO LXST import, NO audio bridge, NO chaquopy_audio_backend, NO sys.modules hackery

**teardown(self):**
- If active_call, teardown link
- Set active_call = None, _initialized = False

**call(self, destination_hash_hex, profile=None):**
- Recall identity: `identity = RNS.Identity.recall(bytes.fromhex(destination_hash_hex))`
- If None, return {"success": False, "error": "Unknown identity"}
- Create OUT destination: `RNS.Destination(identity, RNS.Destination.OUT, RNS.Destination.SINGLE, APP_NAME, PRIMITIVE_NAME)`
- Path discovery: if not `RNS.Transport.has_path(dest.hash)`, request path with timeout (70s)
- Establish link: `self.active_call = RNS.Link(dest, established_callback=self.__outgoing_link_established, closed_callback=self.__link_closed)`
- Return {"success": True}
- Store _active_call_identity for UI

**answer(self):**
- If no active_call or active_call not pending answer, return False
- Send STATUS_CONNECTING signal to remote via link
- Send STATUS_ESTABLISHED signal to remote via link
- Notify Kotlin with CONNECTING then ESTABLISHED (same as current _handle_established)
- Return True

**hangup(self):**
- If active_call, send STATUS_BUSY to remote (if link active), then teardown link
- Clear active_call, notify Kotlin call ended
- Same safety: notify Kotlin even if not initialized

**__incoming_link_established(self, link):**
- If self.active_call or self._busy: send BUSY signal, teardown link, return
- Set callbacks on link: set_remote_identified_callback, set_link_closed_callback, set_packet_callback
- Send STATUS_AVAILABLE signal (tells remote we're here)

**__caller_identified(self, link, identity):**
- Check allow list (use `self._is_allowed(identity)` — check if identity hash is in contacts/allow list)
- If not allowed: send BUSY, teardown, return (don't notify Kotlin)
- If allowed: self.active_call = link, notify Kotlin RINGING, notify CallBridge

**_is_allowed(self, identity):**
- For now, return True (allow all — same as current behavior, allow-list can be added later)
- Log the identity hash for debugging

**__outgoing_link_established(self, link):**
- Set packet_callback on link
- Identify to remote: link.identify(self.identity)
- Notify Kotlin with CONNECTING then ESTABLISHED (same signals as current _handle_established)
- Notify CallBridge

**__link_closed(self, link):**
- If link == self.active_call: clear active_call, notify Kotlin AVAILABLE, notify CallBridge ended

**__packet_received(self, data, packet):**
- Unpack msgpack: `unpacked = umsgpack.unpackb(data)`
- If not dict, return
- If FIELD_FRAMES in unpacked: forward frame bytes to Kotlin via `self._kotlin_network_bridge.onPythonPacketReceived(frame)`
  - Handle both list and single value for frames field
- If FIELD_SIGNALLING in unpacked: forward signal int to Kotlin via `self._kotlin_network_bridge.onPythonSignalReceived(signal)`
  - Handle both list and single value for signalling field

**send_audio_packet(self, packet_data):**
- Wrap in LXST format: `{FIELD_FRAMES: packet_data}`
- Pack: `umsgpack.packb(data)`
- Send: `RNS.Packet(self.active_call, packed, create_receipt=False).send()`
- Guard: check active_call is not None and link status is ACTIVE

**send_signal(self, signal):**
- TWO behaviors:
  1. Send to REMOTE via Reticulum link (wrap in msgpack, send as packet)
  2. Send to KOTLIN via bridge (call onPythonSignalReceived)
- For remote: `{FIELD_SIGNALLING: [signal]}` → msgpack → RNS.Packet → send
- For Kotlin: `self._kotlin_network_bridge.onPythonSignalReceived(signal)`
- IMPORTANT: The current code only sends to Kotlin bridge. The NEW code must also send to remote peer when appropriate (e.g., answer sends CONNECTING+ESTABLISHED to remote)
- Add helper: `_send_signal_to_remote(self, signal, link=None)` for remote-bound signals
- Keep `send_signal(self, signal)` for Kotlin-bound signals (same as current)

**receive_audio_packet(self, packet_data):**
- Called by Kotlin Packetizer (via NetworkPacketBridge.sendPacket → Python)
- Wrap in LXST format and send over link: `{FIELD_FRAMES: packet_data}` → msgpack → RNS.Packet
- Same implementation as send_audio_packet (they do the same thing — Kotlin audio → remote)

**receive_signal(self, signal):**
- Called by Kotlin (via NetworkPacketBridge.sendSignal → Python)
- Wrap in LXST format and send over link: `{FIELD_SIGNALLING: [signal]}` → msgpack → RNS.Packet

**mute_microphone(self, muted):**
- Python no longer handles mute (Kotlin Telephone owns mute)
- Keep method for API compatibility, just log

**set_speaker(self, enabled):**
- Keep as no-op stub (audio handled by Kotlin)

**get_call_state(self):**
- Return state based on active_call, _busy, etc. (simplified — no LXST telephone object)

**set_kotlin_call_bridge, set_kotlin_telephone_callback:**
- Keep same signatures

**_notify_kotlin:**
- Keep same implementation

**REMOVE these methods entirely:**
- `set_kotlin_audio_active` (Phase 11.6 — being deleted)
- `on_state_changed` (was for LXST state forwarding — Kotlin drives state now)
- `on_profile_changed` (was for LXST profile sync — Kotlin drives profiles now)
- `_get_status_string` (was reading LXST telephone.call_status)
- `_get_profile_name` (was reading LXST telephone.active_profile)

**REMOVE these LXST callback handlers:**
- `_handle_ringing`, `_handle_established`, `_handle_ended`, `_handle_busy`, `_handle_rejected`
  (These were Python LXST Telephone callbacks. New code handles link lifecycle directly.)

**Import changes:**
- REMOVE: `from LXST.Primitives.Telephony import Telephone`
- REMOVE: `from .lxst_debug_instrumentation import install_instrumentation`
- REMOVE: `from .chaquopy_audio_backend import set_kotlin_audio_bridge`
- REMOVE: `import sys` (was for sys.modules hack)
- REMOVE: `import inspect` (was for Telephone inspection)
- ADD: `from RNS.vendor import umsgpack` (for msgpack wire format)
- KEEP: `import RNS` (with fallback)
- KEEP: `import threading`
- ADD: `import time` (for timeout loops)

**msgpack import note:** Use `from RNS.vendor import umsgpack` — this is vendored inside Reticulum, no extra dependency needed.
  </action>
  <verify>
- `grep -r "from LXST" python/lxst_modules/call_manager.py` returns NO results
- `grep -r "import LXST" python/lxst_modules/call_manager.py` returns NO results
- `grep "FIELD_SIGNALLING = 0x00" python/lxst_modules/call_manager.py` confirms constant exists
- `grep "FIELD_FRAMES = 0x01" python/lxst_modules/call_manager.py` confirms constant exists
- `grep "umsgpack.packb" python/lxst_modules/call_manager.py` confirms msgpack usage
- `grep "RNS.Destination" python/lxst_modules/call_manager.py` confirms raw Reticulum usage
- `grep "RNS.Link" python/lxst_modules/call_manager.py` confirms raw link creation
- `grep "RNS.Packet" python/lxst_modules/call_manager.py` confirms raw packet sending
- `grep "set_kotlin_audio_active" python/lxst_modules/call_manager.py` returns NO results
- File is under 400 lines
  </verify>
  <done>
call_manager.py uses ONLY raw Reticulum APIs (RNS.Link, RNS.Packet, RNS.Destination) and umsgpack for wire format. No LXST imports anywhere. Wire format matches LXST exactly ({0x00: [signal]}, {0x01: frame}). All call lifecycle (incoming link → identify → answer, outgoing → path discovery → link → establish) handled with Reticulum callbacks. Kotlin bridge methods (send_audio_packet, send_signal, receive_audio_packet, receive_signal) forward packets via msgpack wire format over Reticulum links.
  </done>
</task>

<task type="auto">
  <name>Task 2: Delete lxst_debug_instrumentation.py and clean chaquopy_audio_backend.py</name>
  <files>
    python/lxst_modules/lxst_debug_instrumentation.py
    python/lxst_modules/chaquopy_audio_backend.py
    python/lxst_modules/__init__.py
  </files>
  <action>
**DELETE** `python/lxst_modules/lxst_debug_instrumentation.py` entirely. This file monkey-patches LXST audio classes (LineSource, Mixer, Packetizer, LinkSource) which no longer exist in the codebase.

**CLEAN chaquopy_audio_backend.py** — Remove Phase 11.6 flag code:
1. Remove the `_kotlin_audio_active = False` global variable (line 48)
2. Remove the `set_kotlin_audio_active()` function (lines 93-105)
3. Remove the `is_kotlin_audio_active()` function (lines 108-110)
4. In `ChaquopyPlayer.play()`: Remove the `if _kotlin_audio_active:` block (lines 303-308) that drops frames
5. In `ChaquopyRecorder._record_chunk()`: Remove the `if _kotlin_audio_active:` block (lines 449-453) that returns silence
6. Remove the comment on line 46-47 about the flag

KEEP everything else in chaquopy_audio_backend.py — the audio backend, player, recorder, LXST-compatible device functions. Even though Python LXST is removed, this file may still be needed as a working soundcard backend in case any residual Python audio code exists, and it's harmless to keep.

**UPDATE __init__.py** — Change the module description:
```python
# Python network transport modules for Columba
# Handles Reticulum link lifecycle and packet forwarding via Chaquopy bridge
```
  </action>
  <verify>
- `ls python/lxst_modules/lxst_debug_instrumentation.py` fails (file deleted)
- `grep "_kotlin_audio_active" python/lxst_modules/chaquopy_audio_backend.py` returns NO results
- `grep "set_kotlin_audio_active" python/lxst_modules/chaquopy_audio_backend.py` returns NO results
- `grep "is_kotlin_audio_active" python/lxst_modules/chaquopy_audio_backend.py` returns NO results
- `python3 -c "import ast; ast.parse(open('python/lxst_modules/chaquopy_audio_backend.py').read())"` parses successfully (no syntax errors)
  </verify>
  <done>
lxst_debug_instrumentation.py is deleted. chaquopy_audio_backend.py has no Phase 11.6 flag code — no _kotlin_audio_active variable, no set/is functions, no conditional frame dropping or silence returning based on that flag.
  </done>
</task>

</tasks>

<verification>
1. `grep -r "from LXST\|import LXST" python/lxst_modules/` returns NO results
2. `grep -r "lxst_debug_instrumentation" python/lxst_modules/` returns NO results (no references to deleted file)
3. `grep -r "set_kotlin_audio_active\|_kotlin_audio_active\|is_kotlin_audio_active" python/lxst_modules/` returns NO results
4. `grep "FIELD_SIGNALLING.*0x00" python/lxst_modules/call_manager.py` confirms wire format constant
5. `grep "umsgpack" python/lxst_modules/call_manager.py` confirms msgpack usage
6. `grep "RNS.Link\|RNS.Destination\|RNS.Packet" python/lxst_modules/call_manager.py` confirms raw Reticulum APIs
7. All Python files parse without syntax errors
</verification>

<success_criteria>
- Python LXST is not imported anywhere in python/lxst_modules/
- call_manager.py uses raw Reticulum Link APIs for call lifecycle
- Wire format is LXST-compatible msgpack ({0x00: [signal]}, {0x01: frame})
- Phase 11.6 flag code completely removed from Python layer
- lxst_debug_instrumentation.py deleted
</success_criteria>

<output>
After completion, create `.planning/phases/11.7-remove-python-lxst/11.7-01-SUMMARY.md`
</output>
