---
phase: 09-mixer-pipeline
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - reticulum/src/main/java/com/lxmf/messenger/reticulum/audio/lxst/Mixer.kt
autonomous: true

must_haves:
  truths:
    - "Multiple audio sources can push frames to Mixer"
    - "Mixer combines frames with global gain control"
    - "Mute prevents output (gain multiplier = 0)"
    - "Backpressure rejects frames when queue full"
  artifacts:
    - path: "reticulum/src/main/java/com/lxmf/messenger/reticulum/audio/lxst/Mixer.kt"
      provides: "Push-based audio mixer"
      min_lines: 120
      contains: "class Mixer"
  key_links:
    - from: "Mixer.kt"
      to: "Source.kt"
      via: "extends LocalSource"
      pattern: "class Mixer.*LocalSource"
    - from: "Mixer.kt"
      to: "Sink.kt"
      via: "extends LocalSink"
      pattern: "class Mixer.*LocalSink"
---

<objective>
Implement Mixer class that combines multiple audio sources with gain control.

Purpose: Mixer is the core audio combiner for voice calls - it mixes local mic + remote stream for receive path, and local sources for transmit path. Must match Python LXST Mixer.py exactly.

Output: Mixer.kt implementing both LocalSource and LocalSink interfaces with push-based frame handling, per-source queues, global gain, mute, and coroutine-based mixing loop.
</objective>

<execution_context>
@/home/tyler/.claude/get-shit-done/workflows/execute-plan.md
@/home/tyler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/09-mixer-pipeline/09-RESEARCH.md

# Existing base classes
@reticulum/src/main/java/com/lxmf/messenger/reticulum/audio/lxst/Source.kt
@reticulum/src/main/java/com/lxmf/messenger/reticulum/audio/lxst/Sink.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Mixer class implementing LocalSource + LocalSink</name>
  <files>reticulum/src/main/java/com/lxmf/messenger/reticulum/audio/lxst/Mixer.kt</files>
  <action>
Create Mixer.kt in the lxst package matching Python LXST Mixer.py (lines 14-177) structure:

**Class declaration:**
```kotlin
class Mixer(
    private val targetFrameMs: Int = 40,
    var codec: Codec? = null,
    var sink: Sink? = null,
    private var globalGain: Float = 0.0f  // dB, 0.0 = unity
) : LocalSource(), LocalSink()
```

Note: Kotlin doesn't support multiple inheritance, but LocalSource and LocalSink are both abstract classes with no state. Use composition or make Mixer implement both interfaces. RECOMMENDED: Create a combined interface `SourceSink` or just implement both interfaces directly:

```kotlin
class Mixer(...) : LocalSource() {
    // Also implements Sink interface methods
}
```

Alternative approach (cleaner): Make Mixer a standalone class that delegates to internal source/sink implementations.

**IMPORTANT:** LocalSource and LocalSink are abstract classes, not interfaces. In Kotlin, you can only extend ONE class. Solution options:
1. Have Mixer extend LocalSource and implement Sink interface manually (add canReceive, handleFrame, start, stop, isRunning)
2. Refactor Sink to be an interface (but this changes Phase 8 code)

**Recommended:** Extend LocalSource, manually implement Sink methods. This matches Python where Mixer inherits from both (Python allows multiple inheritance).

**Properties (from Python Mixer.py:14-39):**
- `incomingFrames: MutableMap<Source, ArrayDeque<FloatArray>>` - per-source queues
- `MAX_FRAMES = 8` - queue depth constant
- `insertLock: Any` - synchronization for queue access
- `shouldRun: AtomicBoolean` - mixer thread flag
- `muted: AtomicBoolean` - mute state
- `sampleRate: Int` - auto-detected from first source
- `channels: Int` - auto-detected from first source
- `scope: CoroutineScope` - for background mixing coroutine

**Methods:**

1. `canReceive(fromSource: Source?): Boolean` (Python lines 66-70)
   - Return true if source not in map or queue size < MAX_FRAMES
   - Lock-free read for performance

2. `handleFrame(frame: FloatArray, source: Source?)` (Python lines 72-93)
   - Synchronized on insertLock
   - Create queue for new source
   - Auto-detect sampleRate/channels from first source
   - Add frame to queue (drop oldest if full with removeFirst())
   - Frame is already decoded float32 (from context research)

3. `mixingGain: Float` (property, Python lines 95-99)
   - If muted: return 0.0f
   - If globalGain == 0.0f: return 1.0f (unity)
   - Else: return 10f.pow(globalGain / 10f) (dB to linear)

4. `start()` (Python lines 51-56)
   - Set shouldRun = true
   - Launch mixerJob() coroutine in scope

5. `stop()` (Python lines 58-63)
   - Set shouldRun = false
   - Clear incomingFrames

6. `isRunning(): Boolean` - return shouldRun.get()

7. `mixerJob()` (suspend function, Python lines 101-139)
   - Loop while shouldRun
   - Check sink?.canReceive(this)
   - Pull one frame from each source queue (synchronized)
   - Mix: first frame * gain, then add subsequent frames * gain
   - Clip to [-1.0f, 1.0f] using coerceIn
   - If codec set: encode then push to sink
   - Else: push float32 directly to sink
   - If no frames: delay(targetFrameMs / 10)

8. `setGain(gain: Float)` - set globalGain
9. `mute(mute: Boolean = true)` - set muted flag

**Key implementation details:**
- Use `synchronized(insertLock)` for thread safety in handleFrame
- Use `ArrayDeque<FloatArray>()` with capacity MAX_FRAMES
- For mixing: `frames.zip(nextFrame) { a, b -> a + b * mixingGain }`
- Sample rate auto-detection happens on first handleFrame call
- Match Python exactly: global gain only (not per-source)
  </action>
  <verify>
Build compiles: `cd /home/tyler/repos/public/columba && ./gradlew :reticulum:compileDebugKotlin 2>&1 | tail -20`
File exists and has expected structure: `grep -c "class Mixer" reticulum/src/main/java/com/lxmf/messenger/reticulum/audio/lxst/Mixer.kt`
  </verify>
  <done>
Mixer.kt exists with:
- Extends LocalSource, implements Sink methods
- handleFrame accepts float32 and stores in per-source queues
- mixerJob combines frames with gain and clips to [-1.0, 1.0]
- mute() sets gain multiplier to 0
- canReceive provides backpressure
- Build compiles successfully
  </done>
</task>

<task type="auto">
  <name>Task 2: Add Source/Sink interface compatibility</name>
  <files>
reticulum/src/main/java/com/lxmf/messenger/reticulum/audio/lxst/Mixer.kt
reticulum/src/main/java/com/lxmf/messenger/reticulum/audio/lxst/Sink.kt
  </files>
  <action>
Since Mixer needs to be both a Source (output) and Sink (input), but Kotlin only allows single inheritance:

**Option A (PREFERRED):** Modify Sink.kt to extract an interface, then have Mixer extend LocalSource and implement SinkInterface.

Add to Sink.kt (before the abstract class):
```kotlin
/**
 * Sink interface for components that can receive audio frames.
 * Extracted to allow Mixer to implement both Source and Sink behaviors.
 */
interface SinkInterface {
    fun canReceive(fromSource: Source? = null): Boolean
    fun handleFrame(frame: FloatArray, source: Source? = null)
    fun start()
    fun stop()
    fun isRunning(): Boolean
}
```

Then modify the abstract class:
```kotlin
abstract class Sink : SinkInterface
```

This is backward-compatible (LineSink still extends Sink which implements SinkInterface).

**Update Mixer.kt:**
```kotlin
class Mixer(...) : LocalSource(), SinkInterface {
    // Now can implement both behaviors
}
```

**Option B (if Option A causes issues):** Keep Mixer as-is extending LocalSource, and use a wrapper/adapter pattern for sink behavior. Less clean but works.

Verify LineSink still compiles after Sink.kt change.
  </action>
  <verify>
Build compiles with both files: `cd /home/tyler/repos/public/columba && ./gradlew :reticulum:compileDebugKotlin 2>&1 | tail -20`
LineSink still works: `grep "class LineSink" reticulum/src/main/java/com/lxmf/messenger/reticulum/audio/lxst/LineSink.kt`
Mixer implements SinkInterface: `grep "SinkInterface" reticulum/src/main/java/com/lxmf/messenger/reticulum/audio/lxst/Mixer.kt`
  </verify>
  <done>
- SinkInterface extracted in Sink.kt
- Sink extends SinkInterface (backward compatible)
- Mixer extends LocalSource and implements SinkInterface
- LineSink still compiles and works
- Build succeeds
  </done>
</task>

</tasks>

<verification>
1. Mixer.kt file exists with ~150+ lines
2. Mixer can accept frames via handleFrame
3. Mixer outputs mixed frames via background coroutine
4. mute() sets gain to 0 (silence)
5. Build compiles: `./gradlew :reticulum:compileDebugKotlin`
</verification>

<success_criteria>
- MIX-01 PARTIAL: Mixer combines frames with global gain (per-source not required by Python)
- MIX-02 PARTIAL: Mute implemented (receive/transmit split is in Telephone, not Mixer)
- Mixer.kt matches Python LXST Mixer.py structure
- Build compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/09-mixer-pipeline/09-01-SUMMARY.md`
</output>
