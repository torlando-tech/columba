---
phase: 10-network-bridge
plan: 02
type: execute
wave: 2
depends_on: ["10-01"]
files_modified:
  - reticulum/src/main/java/com/lxmf/messenger/reticulum/audio/lxst/Packetizer.kt
autonomous: true

must_haves:
  truths:
    - "Packetizer extends RemoteSink and sends encoded frames to Python"
    - "Packetizer prepends codec header byte before sending"
    - "handleFrame encodes float32 to bytes using source's codec"
    - "Transmission is non-blocking (delegates to NetworkPacketBridge)"
    - "canReceive returns true when running (Python handles backpressure)"
  artifacts:
    - path: "reticulum/src/main/java/com/lxmf/messenger/reticulum/audio/lxst/Packetizer.kt"
      provides: "RemoteSink that sends encoded frames to Python Reticulum"
      min_lines: 70
      exports: ["Packetizer"]
  key_links:
    - from: "Packetizer.handleFrame"
      to: "NetworkPacketBridge.sendPacket"
      via: "bridge.sendPacket call"
      pattern: "bridge\\.sendPacket"
    - from: "Packetizer.handleFrame"
      to: "source.codec.encode"
      via: "codec encode call"
      pattern: "codec.*encode"
---

<objective>
Create Packetizer - a RemoteSink that receives float32 frames from Pipeline/Mixer, encodes them, and sends to Python Reticulum.

Purpose: Kotlin-to-Python audio transmission path. Matches Python LXST Network.py Packetizer (lines 49-89).
Output: Packetizer.kt that integrates with NetworkPacketBridge for transmission.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-network-bridge/10-RESEARCH.md

# Phase 10 dependencies
@.planning/phases/10-network-bridge/10-01-SUMMARY.md

# Existing LXST classes
@reticulum/src/main/java/com/lxmf/messenger/reticulum/audio/lxst/Sink.kt
@reticulum/src/main/java/com/lxmf/messenger/reticulum/audio/codec/Codec.kt

# Python reference
@app/build/python/pip/noSentryDebug/common/LXST/Network.py
@app/build/python/pip/noSentryDebug/common/LXST/Codecs/__init__.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Packetizer class</name>
  <files>reticulum/src/main/java/com/lxmf/messenger/reticulum/audio/lxst/Packetizer.kt</files>
  <action>
Create Packetizer extending RemoteSink, matching Python LXST Network.py Packetizer:

1. Package: `com.lxmf.messenger.reticulum.audio.lxst`

2. Imports:
   - `com.lxmf.messenger.reticulum.audio.bridge.NetworkPacketBridge`
   - `com.lxmf.messenger.reticulum.audio.codec.Codec`
   - `java.util.concurrent.atomic.AtomicBoolean`

3. Companion object with codec header byte constants (matching Python LXST Codecs/__init__.py):
   ```kotlin
   companion object {
       // Codec header bytes (match Python LXST)
       const val CODEC_NULL = 0xFF.toByte()
       const val CODEC_RAW = 0x00.toByte()
       const val CODEC_OPUS = 0x01.toByte()
       const val CODEC_CODEC2 = 0x02.toByte()
   }
   ```

4. Constructor:
   ```kotlin
   class Packetizer(
       private val bridge: NetworkPacketBridge,
       private val failureCallback: (() -> Unit)? = null
   ) : RemoteSink()
   ```

5. State:
   - `private val shouldRun = AtomicBoolean(false)`
   - `var source: Source? = null` (set by Pipeline to access codec)
   - `var codec: Codec? = null` (alternative: explicit codec reference)
   - `@Volatile var transmitFailure: Boolean = false`

6. Helper function to get codec header byte:
   ```kotlin
   private fun codecHeaderByte(codec: Codec?): Byte {
       return when (codec) {
           is com.lxmf.messenger.reticulum.audio.codec.Null -> CODEC_NULL
           is com.lxmf.messenger.reticulum.audio.codec.Opus -> CODEC_OPUS
           is com.lxmf.messenger.reticulum.audio.codec.Codec2 -> CODEC_CODEC2
           else -> CODEC_RAW
       }
   }
   ```

7. Override canReceive:
   ```kotlin
   override fun canReceive(fromSource: Source?): Boolean {
       // Always accept - Python/network handles backpressure
       return shouldRun.get()
   }
   ```

8. Override handleFrame (CRITICAL - match Python exactly):
   ```kotlin
   override fun handleFrame(frame: FloatArray, source: Source?) {
       if (!shouldRun.get()) return

       // Get codec from source or explicit property
       val activeCodec = codec ?: (source as? LineSource)?.codec ?: return

       // Encode frame
       val encodedFrame = activeCodec.encode(frame)

       // Prepend codec header byte (match Python LXST format)
       val packet = ByteArray(1 + encodedFrame.size)
       packet[0] = codecHeaderByte(activeCodec)
       encodedFrame.copyInto(packet, 1)

       // Send to Python via bridge (non-blocking)
       try {
           bridge.sendPacket(packet)
       } catch (e: Exception) {
           transmitFailure = true
           failureCallback?.invoke()
       }
   }
   ```

9. Lifecycle methods:
   ```kotlin
   override fun start() {
       shouldRun.set(true)
   }

   override fun stop() {
       shouldRun.set(false)
   }

   override fun isRunning(): Boolean = shouldRun.get()
   ```

CRITICAL: No Log.d() in handleFrame - this is the audio hot path.
  </action>
  <verify>
Build succeeds: `cd /home/tyler/repos/public/columba && JAVA_HOME=/home/tyler/android-studio/jbr ./gradlew :reticulum:compileDebugKotlin 2>&1 | tail -20`
File structure: `grep -E "class Packetizer|override fun handleFrame|codecHeaderByte|CODEC_OPUS" reticulum/src/main/java/com/lxmf/messenger/reticulum/audio/lxst/Packetizer.kt`
  </verify>
  <done>
Packetizer.kt compiles and contains:
- Extends RemoteSink
- Codec header byte constants matching Python (0xFF=Null, 0x00=Raw, 0x01=Opus, 0x02=Codec2)
- handleFrame encodes frame with codec, prepends header byte, calls bridge.sendPacket
- canReceive returns shouldRun.get()
- No synchronous logging in handleFrame
  </done>
</task>

</tasks>

<verification>
1. Build passes: `./gradlew :reticulum:compileDebugKotlin`
2. Packetizer.kt extends RemoteSink
3. Codec header bytes match Python LXST (grep confirms constants)
4. handleFrame calls bridge.sendPacket
</verification>

<success_criteria>
- Packetizer extends RemoteSink and compiles
- handleFrame encodes float32 frame using codec
- Codec header byte prepended (matching Python LXST)
- Sends via NetworkPacketBridge.sendPacket (non-blocking)
</success_criteria>

<output>
After completion, create `.planning/phases/10-network-bridge/10-02-SUMMARY.md`
</output>
