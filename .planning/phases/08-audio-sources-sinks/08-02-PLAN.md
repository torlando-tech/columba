---
phase: 08-audio-sources-sinks
plan: 02
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - reticulum/src/main/java/com/lxmf/messenger/reticulum/audio/lxst/LineSource.kt
autonomous: true

must_haves:
  truths:
    - "LineSource captures audio from microphone via KotlinAudioBridge"
    - "LineSource applies gain before encoding"
    - "LineSource adjusts frame size based on codec constraints"
    - "LineSource pushes encoded frames to sink with backpressure check"
    - "LineSource uses coroutine-based capture loop (not Thread)"
  artifacts:
    - path: "reticulum/src/main/java/com/lxmf/messenger/reticulum/audio/lxst/LineSource.kt"
      provides: "Microphone capture wrapping KotlinAudioBridge"
      min_lines: 120
      exports: ["LineSource"]
  key_links:
    - from: "LineSource.kt"
      to: "KotlinAudioBridge"
      via: "bridge.startRecording/readAudio/stopRecording"
      pattern: "bridge\\.(startRecording|readAudio|stopRecording)"
    - from: "LineSource.kt"
      to: "Codec"
      via: "codec.encode() for frame compression"
      pattern: "codec\\.encode"
    - from: "LineSource.kt"
      to: "Sink"
      via: "sink.handleFrame() push model"
      pattern: "sink\\.handleFrame"
---

<objective>
Implement LineSource that wraps KotlinAudioBridge for microphone capture, matching Python LXST Sources.py pattern.

Purpose: Captures mic audio, applies gain, encodes with codec, pushes to sink (SOURCE-01, SOURCE-02 requirements)
Output: LineSource.kt with coroutine-based capture loop, codec frame size adjustment, backpressure handling
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-audio-sources-sinks/08-CONTEXT.md
@.planning/phases/08-audio-sources-sinks/08-RESEARCH.md
@.planning/phases/08-audio-sources-sinks/08-01-SUMMARY.md
@reticulum/src/main/java/com/lxmf/messenger/reticulum/audio/bridge/KotlinAudioBridge.kt
@reticulum/src/main/java/com/lxmf/messenger/reticulum/audio/codec/Codec.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create LineSource.kt with initialization and frame size adjustment</name>
  <files>reticulum/src/main/java/com/lxmf/messenger/reticulum/audio/lxst/LineSource.kt</files>
  <action>
Create LineSource matching Python LXST Sources.py:159-232 pattern.

Key implementation from 08-RESEARCH.md:

```kotlin
package com.lxmf.messenger.reticulum.audio.lxst

import android.util.Log
import com.lxmf.messenger.reticulum.audio.bridge.KotlinAudioBridge
import com.lxmf.messenger.reticulum.audio.codec.Codec
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.SupervisorJob
import kotlinx.coroutines.cancel
import kotlinx.coroutines.delay
import kotlinx.coroutines.launch
import java.util.concurrent.atomic.AtomicBoolean
import kotlin.math.ceil

/**
 * LineSource - Microphone capture for LXST audio pipeline.
 *
 * Wraps KotlinAudioBridge to provide LXST-compatible source interface.
 * Captures audio in a coroutine, applies gain, encodes with codec,
 * and pushes frames to sink.
 *
 * Matches Python LXST Sources.py LineSource class (lines 159-265).
 *
 * @param bridge KotlinAudioBridge instance for audio capture
 * @param codec Codec instance for encoding (determines sample rate, frame size)
 * @param targetFrameMs Target frame duration in milliseconds (default 80ms)
 * @param gain Audio gain multiplier (1.0 = unity, >1.0 = boost, <1.0 = attenuate)
 */
class LineSource(
    private val bridge: KotlinAudioBridge,
    private val codec: Codec,
    targetFrameMs: Int = 80,
    private val gain: Float = 1.0f
) : LocalSource() {

    companion object {
        private const val TAG = "Columba:LineSource"
        private const val DEFAULT_SAMPLE_RATE = 48000
        private const val DEFAULT_CHANNELS = 1
    }

    /** Sink to push encoded frames to (set by Pipeline) */
    var sink: Sink? = null

    // Audio configuration (derived from codec)
    override var sampleRate: Int = DEFAULT_SAMPLE_RATE
        private set
    override var channels: Int = DEFAULT_CHANNELS
        private set

    private val samplesPerFrame: Int
    private val frameTimeMs: Int

    // Coroutine management
    private val scope = CoroutineScope(Dispatchers.IO + SupervisorJob())
    private val isRunningFlag = AtomicBoolean(false)

    init {
        // Query codec for preferred sample rate (Python LXST Sources.py:202-204)
        sampleRate = codec.preferredSamplerate ?: DEFAULT_SAMPLE_RATE

        // Adjust frame time based on codec constraints (Python LXST Sources.py:196-208)
        frameTimeMs = adjustFrameTime(targetFrameMs, codec)

        // Calculate samples per frame
        samplesPerFrame = ((frameTimeMs / 1000f) * sampleRate).toInt()

        Log.d(TAG, "LineSource initialized: rate=$sampleRate, frameMs=$frameTimeMs, samples=$samplesPerFrame, gain=$gain")
    }

    /**
     * Adjust frame time to match codec constraints.
     *
     * Matches Python LXST Sources.py:196-208 logic:
     * - Quantize to codec.frameQuantaMs (e.g., Opus requires 2.5ms multiples)
     * - Clamp to codec.frameMaxMs (e.g., Opus max 120ms)
     * - Snap to codec.validFrameMs if specified
     */
    private fun adjustFrameTime(targetMs: Int, codec: Codec): Int {
        var adjusted = targetMs

        // Quantize to codec frame quanta (e.g., Opus requires 2.5ms multiples)
        codec.frameQuantaMs?.let { quanta ->
            if (adjusted % quanta.toInt() != 0) {
                adjusted = (ceil(adjusted / quanta) * quanta).toInt()
                Log.d(TAG, "Frame time quantized to ${adjusted}ms for codec")
            }
        }

        // Clamp to codec max frame size (e.g., Opus max 120ms)
        codec.frameMaxMs?.let { maxMs ->
            if (adjusted > maxMs.toInt()) {
                adjusted = maxMs.toInt()
                Log.d(TAG, "Frame time clamped to ${adjusted}ms for codec")
            }
        }

        // Snap to valid frame sizes if codec specifies them
        codec.validFrameMs?.let { validSizes ->
            val closest = validSizes.minByOrNull { kotlin.math.abs(it - adjusted) }
            if (closest != null && closest.toInt() != adjusted) {
                adjusted = closest.toInt()
                Log.d(TAG, "Frame time snapped to ${adjusted}ms (codec valid sizes)")
            }
        }

        return adjusted
    }

    override fun start() {
        if (isRunningFlag.getAndSet(true)) {
            Log.w(TAG, "LineSource already running")
            return
        }

        Log.i(TAG, "Starting LineSource: rate=$sampleRate, samples=$samplesPerFrame")

        // Start bridge recording
        bridge.startRecording(
            sampleRate = sampleRate,
            channels = channels,
            samplesPerFrame = samplesPerFrame
        )

        // Launch capture coroutine
        scope.launch { ingestJob() }
    }

    override fun stop() {
        if (!isRunningFlag.getAndSet(false)) {
            Log.w(TAG, "LineSource not running")
            return
        }

        Log.i(TAG, "Stopping LineSource")
        bridge.stopRecording()
    }

    override fun isRunning(): Boolean = isRunningFlag.get()

    /**
     * Main capture loop - runs in coroutine.
     *
     * Matches Python LXST Sources.py:235-265 __ingest_job pattern:
     * 1. Read frame from bridge (int16 bytes)
     * 2. Convert to float32
     * 3. Apply gain
     * 4. Encode with codec
     * 5. Push to sink with backpressure check
     */
    private suspend fun ingestJob() {
        Log.d(TAG, "Ingest job started")
        var frameCount = 0L

        while (isRunningFlag.get()) {
            // Read raw audio from bridge (int16 bytes)
            val frameBytes = bridge.readAudio(samplesPerFrame)
            if (frameBytes == null) {
                delay(10) // Brief pause if no data
                continue
            }

            frameCount++

            // Convert int16 bytes to float32 samples
            val frameSamples = bytesToFloat32(frameBytes)

            // Apply gain if not unity (Python LXST Sources.py:256-258)
            val gained = if (gain != 1.0f) {
                FloatArray(frameSamples.size) { i -> frameSamples[i] * gain }
            } else {
                frameSamples
            }

            // Encode with codec
            val encoded = try {
                codec.encode(gained)
            } catch (e: Exception) {
                Log.e(TAG, "Codec encode error on frame $frameCount", e)
                continue
            }

            // Push to sink with backpressure check (Python LXST Sources.py:260-263)
            val currentSink = sink
            if (currentSink != null && currentSink.canReceive(this)) {
                currentSink.handleFrame(encoded.let { codec.decode(it) }, this)
                // NOTE: We decode here because Sink expects Float32, not encoded bytes.
                // In full pipeline, this will be: source -> encode -> network -> decode -> sink
                // For Phase 8 local testing, we do encode+decode inline.
            } else if (currentSink != null) {
                // Sink can't receive - drop frame (backpressure)
                if (frameCount % 50L == 0L) {
                    Log.w(TAG, "Sink backpressure, dropping frames")
                }
            }
        }

        Log.d(TAG, "Ingest job ended, captured $frameCount frames")
    }

    /**
     * Release resources.
     */
    fun release() {
        stop()
        scope.cancel()
    }
}
```

Key implementation decisions:
1. **Filters in bridge**: 08-RESEARCH.md recommends letting bridge filters run (already <1ms). LineSource doesn't add extra filters.
2. **Push model**: Matches Python - source calls sink.handleFrame(), not sink pulling
3. **Codec decode inline**: For Phase 8 testing, encode then decode immediately. Phase 9 will wire through network.
4. **AtomicBoolean for thread safety**: Matches Python's should_run pattern
  </action>
  <verify>File exists, compiles: `cd /home/tyler/repos/public/columba && JAVA_HOME=/home/tyler/android-studio/jbr ./gradlew :reticulum:compileDebugKotlin 2>&1 | tail -20`</verify>
  <done>LineSource.kt exists with initialization, frame size adjustment, and capture loop</done>
</task>

<task type="auto">
  <name>Task 2: Verify LineSource integrates with existing bridge and codec</name>
  <files>N/A</files>
  <action>
Run compilation and check for any integration issues:

```bash
cd /home/tyler/repos/public/columba
JAVA_HOME=/home/tyler/android-studio/jbr ./gradlew :reticulum:compileDebugKotlin --info 2>&1 | grep -E "(LineSource|error|Error|warning)" | head -30
```

Also verify imports work correctly:
```bash
grep -n "import.*KotlinAudioBridge\|import.*Codec\|import.*Sink" reticulum/src/main/java/com/lxmf/messenger/reticulum/audio/lxst/LineSource.kt
```

Check the file structure:
```bash
ls -la reticulum/src/main/java/com/lxmf/messenger/reticulum/audio/lxst/
```
  </action>
  <verify>Gradle compiles successfully, imports resolve correctly</verify>
  <done>LineSource compiles and integrates with KotlinAudioBridge and Codec</done>
</task>

</tasks>

<verification>
- [ ] LineSource.kt exists in lxst package
- [ ] LineSource extends LocalSource
- [ ] LineSource has sink property for push model
- [ ] start() calls bridge.startRecording() and launches coroutine
- [ ] stop() calls bridge.stopRecording() and sets flag
- [ ] ingestJob() reads from bridge, converts, applies gain, encodes, pushes
- [ ] Frame size adjustment handles codec constraints
- [ ] Module compiles without errors
</verification>

<success_criteria>
LineSource captures mic audio via KotlinAudioBridge, encodes with codec, pushes to sink (SOURCE-01, SOURCE-02)
</success_criteria>

<output>
After completion, create `.planning/phases/08-audio-sources-sinks/08-02-SUMMARY.md`
</output>
