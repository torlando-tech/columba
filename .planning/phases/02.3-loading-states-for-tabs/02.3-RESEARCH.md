# Phase 2.3 Research: Loading States for Tabs

## Executive Summary

This phase fixes the confusing UX where users see "No conversations yet" or "No contacts yet" flash on screen while data is still loading, making them think no data exists. The fix requires wrapping UI state in a sealed class with Loading/Success/Empty states, following the pattern already established in MapViewModel.

## 1. Current Implementation Analysis

### ChatsViewModel (Lines 51-64)
```kotlin
val conversations: StateFlow<List<Conversation>> =
    searchQuery
        .flatMapLatest { query ->
            if (query.isBlank()) {
                conversationRepository.getConversations()
            } else {
                conversationRepository.searchConversations(query)
            }
        }
        .stateIn(
            scope = viewModelScope,
            started = SharingStarted.WhileSubscribed(5000L),
            initialValue = emptyList(),  // ❌ PROBLEM: Empty list shown immediately
        )
```

**Problem**: `initialValue = emptyList()` means the UI immediately receives an empty list before data loads from the repository.

### ChatsScreen (Lines 159-165)
```kotlin
if (conversations.isEmpty()) {
    EmptyChatsState(
        modifier = Modifier
            .fillMaxSize()
            .padding(paddingValues),
    )
} else {
    // Show list of conversations
}
```

**Problem**: UI checks `isEmpty()` without checking if data is still loading. This shows "No conversations yet" during the initial load.

### ContactsViewModel (Lines 122-138)
```kotlin
val groupedContacts: StateFlow<ContactGroups> =
    filteredContacts
        .combine(MutableStateFlow(Unit)) { contacts, _ ->
            val relay = contacts.find { it.isMyRelay }
            ContactGroups(
                relay = relay,
                pinned = contacts.filter { it.isPinned && !it.isMyRelay },
                all = contacts.filterNot { it.isPinned || it.isMyRelay },
            )
        }
        .stateIn(
            scope = viewModelScope,
            started = SharingStarted.WhileSubscribed(5000L),
            initialValue = ContactGroups(null, emptyList(), emptyList()),  // ❌ Same problem
        )
```

### ContactsScreen (Lines 423-429)
```kotlin
if (groupedContacts.relay == null && groupedContacts.pinned.isEmpty() && groupedContacts.all.isEmpty()) {
    EmptyContactsState(
        modifier = Modifier
            .fillMaxSize()
            .padding(paddingValues),
    )
} else {
    // Show list
}
```

**Same issue**: Checks for empty groups without considering loading state.

## 2. Reference Pattern: MapViewModel (CORRECT IMPLEMENTATION)

### MapState Data Class (Lines 75-88)
```kotlin
@Immutable
data class MapState(
    val userLocation: Location? = null,
    val hasLocationPermission: Boolean = false,
    val isPermissionCardDismissed: Boolean = false,
    val hasUserDismissedPermissionSheet: Boolean = false,
    val contactMarkers: List<ContactMarker> = emptyList(),
    val isLoading: Boolean = true,  // ✅ Explicit loading flag
    val errorMessage: String? = null,
    val isSharing: Boolean = false,
    val activeSessions: List<SharingSession> = emptyList(),
    val lastRefresh: Long = 0L,
    val mapStyleResult: MapStyleResult? = null,
)
```

**Key insight**: Uses a boolean `isLoading` flag within the state class, defaulting to `true`.

### MapViewModel Data Flow (Lines 182-252)
```kotlin
viewModelScope.launch {
    combine(
        receivedLocationDao.getLatestLocationsPerSenderUnfiltered(),
        contacts,
        announceDao.getEnrichedAnnounces(),
        _refreshTrigger,
    ) { locations, contactList, announceList, _ ->
        // Process markers...
        locations.mapNotNull { loc ->
            // Create markers
        }
    }.collect { markers ->
        _state.update { currentState ->
            currentState.copy(
                contactMarkers = markers,
                isLoading = false,  // ✅ Set to false when data arrives
            )
        }
    }
}
```

### MapScreen UI Logic (Lines 907-918)
```kotlin
// Loading indicator
if (state.isLoading) {
    Box(
        modifier = Modifier.fillMaxSize(),
        contentAlignment = Alignment.Center,
    ) {
        Text(
            text = "Loading map...",
            style = MaterialTheme.typography.bodyLarge,
        )
    }
}
```

**UI Pattern**: Check `isLoading` FIRST, then check for empty data.

## 3. Alternative Pattern: Sealed Class UiState

### Example from BleConnectionsViewModel
```kotlin
sealed class BleConnectionsUiState {
    object Loading : BleConnectionsUiState()

    data class Success(
        val connections: List<BleConnectionInfo>,
        val totalConnections: Int,
        val centralConnections: Int,
        val peripheralConnections: Int,
    ) : BleConnectionsUiState()

    data class Error(val message: String) : BleConnectionsUiState()
}
```

**Benefits**:
- Type-safe state transitions
- Impossible to show empty state while loading (compiler-enforced)
- Clear separation of concerns
- More idiomatic Compose pattern

**Drawbacks**:
- Slightly more verbose than boolean flag
- Requires wrapping existing data classes

## 4. Compose Best Practices for Loading States

### Pattern 1: Boolean Flag (MapViewModel approach)
```kotlin
when {
    state.isLoading -> LoadingContent()
    state.data.isEmpty() -> EmptyContent()
    else -> DataContent(state.data)
}
```

**Pros**: Simple, less boilerplate
**Cons**: Not type-safe, can accidentally show wrong state

### Pattern 2: Sealed Class (Recommended for new code)
```kotlin
when (val uiState = state.conversations) {
    is ConversationsUiState.Loading -> LoadingContent()
    is ConversationsUiState.Empty -> EmptyContent()
    is ConversationsUiState.Success -> DataContent(uiState.conversations)
}
```

**Pros**: Type-safe, compiler catches missing states, clear intent
**Cons**: More boilerplate

## 5. Search Query Edge Case

### Current Search Implementation (ChatsViewModel Lines 51-64)
```kotlin
val conversations: StateFlow<List<Conversation>> =
    searchQuery
        .flatMapLatest { query ->
            if (query.isBlank()) {
                conversationRepository.getConversations()
            } else {
                conversationRepository.searchConversations(query)
            }
        }
        .stateIn(...)
```

**Edge case to handle**: When user changes search query, should we show loading state during the search operation?

**Answer**: No. The data flow is reactive - as the user types, the list filters immediately. We should only show loading during initial app startup, not during search filtering.

**Implementation**: Loading flag should only be true until the FIRST data emission, then remain false even during search query changes.

## 6. Empty State Logic After Loading

### Current Empty States

**ChatsScreen - EmptyChatsState (Lines 550-575)**:
- Icon: Chat icon
- Title: "No conversations yet"
- Subtitle: "Messages from peers will appear here"

**ContactsScreen - EmptyContactsState (Lines 1272-1299)**:
- Icon: People icon
- Title: "No contacts yet"
- Subtitle: "Star peers in the Announce Stream\nor add contacts via QR code"

**These are good designs** - they should only appear after data has loaded and is genuinely empty.

## 7. Implementation Strategy

### Option A: Boolean Flag (Follows MapViewModel pattern)
**Recommended for this phase** - maintains consistency with existing MapScreen implementation.

#### ChatsViewModel Changes:
1. Add `ChatsState` data class:
   ```kotlin
   data class ChatsState(
       val conversations: List<Conversation> = emptyList(),
       val isLoading: Boolean = true,
   )
   ```

2. Change StateFlow from `StateFlow<List<Conversation>>` to `StateFlow<ChatsState>`

3. Emit `isLoading = false` when first data arrives

#### ContactsViewModel Changes:
1. Add `ContactsState` data class:
   ```kotlin
   data class ContactsState(
       val groupedContacts: ContactGroups = ContactGroups(null, emptyList(), emptyList()),
       val isLoading: Boolean = true,
   )
   ```

2. Change StateFlow type accordingly

3. Emit `isLoading = false` when first data arrives

#### UI Changes:
```kotlin
// ChatsScreen
when {
    state.isLoading -> LoadingConversations()
    state.conversations.isEmpty() -> EmptyChatsState()
    else -> ConversationsList(state.conversations)
}

// ContactsScreen
when {
    state.isLoading -> LoadingContacts()
    state.groupedContacts.all.isEmpty() && ... -> EmptyContactsState()
    else -> ContactsList(state.groupedContacts)
}
```

### Option B: Sealed Class UiState (More idiomatic)
Would require more refactoring but is more type-safe and prevents impossible states.

## 8. Loading UI Design

### Following MapScreen Pattern:
```kotlin
Box(
    modifier = Modifier.fillMaxSize(),
    contentAlignment = Alignment.Center,
) {
    Text(
        text = "Loading conversations...",  // or "Loading contacts..."
        style = MaterialTheme.typography.bodyLarge,
    )
}
```

**Could enhance with**:
- CircularProgressIndicator above text
- Material 3 surface/card background
- Fade-in animation (optional)

**Keep it simple**: MapScreen uses just text, which is sufficient. Users won't see it for long since data loads quickly from Room database.

## 9. Testing Considerations

### Manual Testing Scenarios:
1. **Fresh install** - Clear app data, launch app
   - Expected: See "Loading conversations..." → then list or empty state
   - Bug to fix: Currently shows "No conversations yet" immediately

2. **After Skip on onboarding** - User skips setup, navigates to tabs
   - Expected: Same as fresh install
   - Bug: Shows empty states immediately

3. **Tab switching** - Switch between Chats/Contacts/Map
   - Expected: If data already loaded, show immediately (no loading flash)
   - Implementation: Keep `isLoading = false` after first load

4. **Search query active** - Type in search bar
   - Expected: Filter list immediately, no loading state
   - Implementation: Don't reset `isLoading` when search changes

5. **Slow database** - Simulate with delay in repository (testing only)
   - Expected: Loading state visible for duration of delay

### Unit Testing:
- Test that `isLoading` starts as `true`
- Test that `isLoading` becomes `false` after first emission
- Test that `isLoading` stays `false` during search query changes
- Test that empty state only shows when `isLoading == false && data.isEmpty()`

## 10. Files to Modify

### ViewModels:
- `/app/src/main/java/com/lxmf/messenger/viewmodel/ChatsViewModel.kt`
  - Add ChatsState data class
  - Wrap conversations StateFlow
  - Set isLoading = false on first emission

- `/app/src/main/java/com/lxmf/messenger/viewmodel/ContactsViewModel.kt`
  - Add ContactsState data class
  - Wrap groupedContacts StateFlow
  - Set isLoading = false on first emission

### Screens:
- `/app/src/main/java/com/lxmf/messenger/ui/screens/ChatsScreen.kt`
  - Update state collection
  - Add loading state check before empty state
  - Add LoadingConversations composable

- `/app/src/main/java/com/lxmf/messenger/ui/screens/ContactsScreen.kt`
  - Update state collection
  - Add loading state check before empty state
  - Add LoadingContacts composable

## 11. Success Criteria Verification

✅ **Criterion 1**: User sees "Loading conversations..." when navigating to Chats tab before data loads
- Implementation: Check `state.isLoading` in ChatsScreen, show loading composable

✅ **Criterion 2**: User sees "Loading contacts..." when navigating to Contacts tab before data loads
- Implementation: Check `state.isLoading` in ContactsScreen, show loading composable

✅ **Criterion 3**: User does NOT see "No conversations yet" or "No contacts yet" while data is still loading
- Implementation: Only show empty state when `!isLoading && data.isEmpty()`

✅ **Criterion 4**: After Skip on onboarding, user sees loading state (not empty state) until data loads
- Implementation: Default `isLoading = true` in state initialization

✅ **Criterion 5**: Empty states only appear when data has finished loading AND is actually empty
- Implementation: Boolean check: `!state.isLoading && state.data.isEmpty()`

## 12. Potential Complications

### 1. Search Query Resets
**Issue**: When user changes search query, `flatMapLatest` cancels previous flow and starts new one.
**Solution**: Don't reset `isLoading` on search query changes - only on initial load.

### 2. Tab Switching
**Issue**: With `SharingStarted.WhileSubscribed(5000L)`, flow may stop/restart when switching tabs.
**Solution**: Consider using `SharingStarted.Lazily` like MapViewModel does for contacts (line 148).

### 3. Empty Database vs Loading
**Issue**: How to distinguish "database is empty" from "database hasn't loaded yet"?
**Solution**: The first emission from repository (even if empty) sets `isLoading = false`.

### 4. Syncing State Confusion
**Issue**: ChatsScreen already has a `isSyncing` indicator for propagation node sync. Users might confuse this with loading state.
**Solution**: Loading state is for initial data load (brief). Syncing is for network operations (longer). They're separate concerns - loading happens once, syncing can happen multiple times.

## 13. Recommended Approach for Implementation

1. **Use Boolean Flag Pattern** (Option A) - consistent with MapViewModel
2. **Keep loading UI simple** - just text and spinner, like MapScreen
3. **Set isLoading = false on first emission** - use `.onEach { }` before `.stateIn()`
4. **Don't show loading during search** - isLoading is only for initial load
5. **Use combine() for complex flows** - like ContactsViewModel's groupedContacts
6. **Test with fresh install** - clear app data to verify loading state appears

## 14. Code Examples

### ChatsViewModel (Proposed)
```kotlin
data class ChatsState(
    val conversations: List<Conversation> = emptyList(),
    val isLoading: Boolean = true,
)

val chatsState: StateFlow<ChatsState> =
    searchQuery
        .flatMapLatest { query ->
            if (query.isBlank()) {
                conversationRepository.getConversations()
            } else {
                conversationRepository.searchConversations(query)
            }
        }
        .map { conversations ->
            ChatsState(
                conversations = conversations,
                isLoading = false,  // Data has arrived
            )
        }
        .stateIn(
            scope = viewModelScope,
            started = SharingStarted.WhileSubscribed(5000L),
            initialValue = ChatsState(isLoading = true),
        )
```

### ChatsScreen (Proposed)
```kotlin
val state by viewModel.chatsState.collectAsState()

Scaffold(topBar = { ... }) { paddingValues ->
    when {
        state.isLoading -> {
            Box(
                modifier = Modifier.fillMaxSize().padding(paddingValues),
                contentAlignment = Alignment.Center,
            ) {
                Column(horizontalAlignment = Alignment.CenterHorizontally) {
                    CircularProgressIndicator()
                    Spacer(modifier = Modifier.height(16.dp))
                    Text(
                        text = "Loading conversations...",
                        style = MaterialTheme.typography.bodyLarge,
                    )
                }
            }
        }
        state.conversations.isEmpty() -> {
            EmptyChatsState(
                modifier = Modifier.fillMaxSize().padding(paddingValues),
            )
        }
        else -> {
            ConversationsList(state.conversations, paddingValues)
        }
    }
}
```

## 15. Additional Notes

### Why Not Use Repository Loading State?
Some architectures emit `Result<T>` from repositories with Loading/Success/Error states. We're not doing this because:
1. Room database queries are already reactive (Flow-based)
2. Loading time is minimal (local database)
3. Adding repository-level states would require refactoring existing repository interface
4. ViewModel-level loading state is sufficient for this use case

### Why Initial Loading Only?
The loading state is only for the initial load because:
1. After initial load, data updates are reactive (Room Flow)
2. Search filtering is instant (no network/disk delay)
3. Subsequent updates (new messages, added contacts) should appear incrementally, not trigger loading state
4. This matches user expectations - loading on first launch, live updates after

### Migration Path
If we later want to add error states, network loading, etc., we can refactor to sealed class:
```kotlin
sealed class ChatsUiState {
    object Loading : ChatsUiState()
    data class Success(val conversations: List<Conversation>) : ChatsUiState()
    data class Error(val message: String) : ChatsUiState()
}
```

But for now, the boolean flag is sufficient and matches the MapViewModel pattern.
