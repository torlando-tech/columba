# Phase 11.7: Remove Python LXST - Research

**Researched:** 2026-02-05
**Domain:** Python Reticulum Link API, msgpack wire protocol, Python-Kotlin bridge refactoring
**Confidence:** HIGH

## Summary

This research investigates how to remove the Python LXST library dependency and rewrite call_manager.py to use raw Reticulum Link APIs with msgpack wire protocol. The goal is to eliminate the dual-pipeline audio conflict at the architectural level (rather than the flag-based workaround in Phase 11.6) and simplify the Python layer to pure network transport.

**Key findings:**
- Python LXST Telephony.py is 897 lines with complex state machine, audio pipelines, and callbacks
- Kotlin already has complete LXST equivalents (Telephone, codecs, mixers, pipelines)
- Python LXST wire protocol uses simple msgpack format: `{0x00: [signals]}` for signalling, `{0x01: [frames]}` for audio
- Reticulum Link API is straightforward: RNS.Destination with set_link_established_callback(), RNS.Link with callbacks, RNS.Packet.send()
- Current Python wrapper (call_manager.py) is 664 lines but most is LXST integration that can be removed
- Phase 11.6 code (_kotlin_audio_active flag, chaquopy_audio_backend changes, instrumentation) should be reverted/deleted

**Primary recommendation:** Replace Python LXST Telephone with minimal call_manager.py that only handles Reticulum link lifecycle and msgpack packet forwarding. Keep exact same wire format for compatibility.

## Standard Stack

### Core Dependencies (Current)
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| LXST | 0.4.5 | Full telephony stack with audio pipelines | **TO BE REMOVED** - Kotlin now provides all functionality |
| Reticulum (RNS) | ~0.7.x | Network transport layer | Keep - core network protocol |
| umsgpack | vendored in RNS | msgpack serialization | Keep - wire format encoding |

### Core Dependencies (After Phase 11.7)
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| Reticulum (RNS) | ~0.7.x | Network transport layer | Core network protocol |
| umsgpack | vendored in RNS | msgpack serialization | Wire format encoding (LXST-compatible) |

**Installation (current):**
```bash
# app/build.gradle.kts lines 350-353
options("--find-links", file("../wheels/lxst").absolutePath)
install("lxst==0.4.5")
```

**Installation (after Phase 11.7):**
```bash
# Remove LXST wheel installation from app/build.gradle.kts
# Keep only Reticulum (installed via requirements.txt)
```

## Architecture Patterns

### Current Architecture (Phase 11.6)
```
Kotlin Telephone (state machine, codecs, pipelines)
    │
    ▼
NetworkTransport (interface)
    │
    ▼
PythonNetworkTransport (Chaquopy bridge)
    │
    ▼
CallManager (wraps Python LXST Telephone)
    │
    ▼
Python LXST Telephone (897 lines, DISABLED via flag)
    │
    ▼
Python LXST Network.py (Packetizer, LinkSource)
    │
    ▼
Reticulum Link APIs
```

### Target Architecture (Phase 11.7)
```
Kotlin Telephone (state machine, codecs, pipelines)
    │
    ▼
NetworkTransport (interface)
    │
    ▼
PythonNetworkTransport (Chaquopy bridge)
    │
    ▼
CallManager (REWRITTEN: raw Reticulum Link + msgpack)
    │
    ▼
Reticulum Link APIs (RNS.Destination, RNS.Link, RNS.Packet)
```

### Pattern 1: LXST Wire Format (Retain for Compatibility)

**What:** msgpack-encoded packets with field IDs for signalling and audio frames

**LXST Network.py wire format:**
```python
# Source: /app/build/python/pip/noSentryDebug/common/LXST/Network.py lines 10-11
FIELD_SIGNALLING = 0x00
FIELD_FRAMES     = 0x01

# Signalling packet (lines 26-33)
signalling_data = {FIELD_SIGNALLING: [signal]}
signalling_packet = RNS.Packet(destination, mp.packb(signalling_data), create_receipt=False)
signalling_packet.send()

# Audio packet (lines 62-67)
frame = codec_header_byte(type(source.codec)) + frame  # Prepend codec type byte
packet_data = {FIELD_FRAMES: frame}
frame_packet = RNS.Packet(destination, mp.packb(packet_data), create_receipt=False)
frame_packet.send()

# Receive handler (lines 112-133)
unpacked = mp.unpackb(data)
if FIELD_FRAMES in unpacked:
    frames = unpacked[FIELD_FRAMES]
    for frame in frames:
        frame_codec = codec_type(frame[0])  # First byte is codec type
        decoded_frame = codec.decode(frame[1:])  # Rest is encoded audio
if FIELD_SIGNALLING in unpacked:
    signalling = unpacked[FIELD_SIGNALLING]
```

**msgpack encoding details:**
- Signalling: `{0x00: [0x04]}` → Single-byte signal (STATUS_RINGING = 0x04)
- Audio: `{0x01: [b'\x42\x...']}` → Codec byte (0x42 = Opus MQ) + encoded frame
- Both use `create_receipt=False` (fire-and-forget, acceptable packet loss)

### Pattern 2: Reticulum Link Lifecycle (Outgoing Calls)

**What:** Path discovery → Link creation → Callbacks

**Example from Python LXST Telephony.py call() (lines 648-673):**
```python
# Create destination
call_destination = RNS.Destination(
    identity,                    # Remote identity (recalled from hash)
    RNS.Destination.OUT,        # Outgoing
    RNS.Destination.SINGLE,     # Point-to-point
    APP_NAME,                   # "lxst"
    PRIMITIVE_NAME              # "telephony"
)

# Request path if not known
if not RNS.Transport.has_path(call_destination.hash):
    RNS.Transport.request_path(call_destination.hash)
    # Wait up to wait_time (70s) for path
    while not RNS.Transport.has_path(call_destination.hash) and time.time() < timeout:
        time.sleep(0.2)

# Establish link
self.active_call = RNS.Link(
    call_destination,
    established_callback=self.__outgoing_link_established,
    closed_callback=self.__link_closed
)
```

### Pattern 3: Reticulum Link Lifecycle (Incoming Calls)

**What:** Destination registration → Link callback → Identity verification

**Example from Python LXST Telephony.py __init__ (lines 138-143):**
```python
# Register destination for incoming calls
self.destination = RNS.Destination(
    self.identity,               # Our identity
    RNS.Destination.IN,         # Incoming
    RNS.Destination.SINGLE,     # Point-to-point
    APP_NAME,                   # "lxst"
    PRIMITIVE_NAME              # "telephony"
)
self.destination.set_proof_strategy(RNS.Destination.PROVE_NONE)
self.destination.set_link_established_callback(self.__incoming_link_established)

# Incoming link callback (lines 318-334)
def __incoming_link_established(self, link):
    if self.active_call or self.busy:
        self.signal(Signalling.STATUS_BUSY, link)
        link.teardown()
    else:
        link.set_remote_identified_callback(self.__caller_identified)
        link.set_link_closed_callback(self.__link_closed)
        self.signal(Signalling.STATUS_AVAILABLE, link)

# Identity verification callback (lines 336-364)
def __caller_identified(self, link, identity):
    if not self.__is_allowed(identity):
        self.signal(Signalling.STATUS_BUSY, link)
        link.teardown()
    else:
        self.active_call = link
        self.signal(Signalling.STATUS_RINGING, self.active_call)
        # Start ring tone, set timeout
```

### Pattern 4: Link Packet Handling

**What:** Set packet callback on Link to receive all packets on that link

**Example from Python LXST Network.py LinkSource.__init__ (lines 98-107):**
```python
def __init__(self, link, signalling_receiver, sink=None):
    self.link = link
    self.link.set_packet_callback(self._packet)

def _packet(self, data, packet):
    unpacked = mp.unpackb(data)
    if FIELD_FRAMES in unpacked:
        # Handle audio frames
    if FIELD_SIGNALLING in unpacked:
        # Handle signalling
```

### Anti-Patterns to Avoid

- **Changing wire format**: Keep exact LXST msgpack format for interoperability
- **Blocking Python GIL in callbacks**: Use Dispatchers.IO for Kotlin→Python calls
- **Synchronous logging in packet path**: Causes audio choppiness (NetworkPacketBridge pattern)
- **Importing LXST**: After Phase 11.7, LXST should not be imported anywhere

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| msgpack encoding/decoding | Custom binary protocol | RNS.vendor.umsgpack | Already vendored in Reticulum, LXST-compatible |
| Link state management | Custom TCP-style state machine | RNS.Link with callbacks | Reticulum handles crypto, retries, timeouts |
| Path discovery | Manual DHT queries | RNS.Transport.request_path() | Reticulum knows network topology |
| Identity recall | Store identity bytes manually | RNS.Identity.recall(hash) | Reticulum caches known identities |

**Key insight:** Reticulum Link API provides everything needed for call signalling and packet transfer. LXST's Telephony.py added audio pipeline complexity that Kotlin now handles.

## Common Pitfalls

### Pitfall 1: Forgetting Link Directionality

**What goes wrong:** Creating RNS.Destination with wrong direction (IN vs OUT) causes link establishment to fail silently.

**Why it happens:** Destination direction is conceptual (who initiates). Outgoing call = OUT destination (we initiate), incoming call = IN destination (we receive).

**How to avoid:**
- Outgoing: `RNS.Destination(identity, RNS.Destination.OUT, RNS.Destination.SINGLE, app, aspect)`
- Incoming: Register IN destination once in __init__, set_link_established_callback

**Warning signs:**
- Link never reaches ACTIVE status
- Path exists but link fails to establish
- No error message (silent failure)

### Pitfall 2: Not Handling Link Closed Gracefully

**What goes wrong:** Remote hangs up → link_closed callback fires → Python doesn't notify Kotlin → Kotlin thinks call still active.

**Why it happens:** Link can close due to remote hangup, timeout, or network failure. Must forward to Kotlin Telephone.

**How to avoid:**
```python
def __link_closed(self, link):
    if link == self.active_call:
        # Notify Kotlin via NetworkPacketBridge.onPythonSignalReceived(STATUS_AVAILABLE)
        self.send_signal(Signalling.STATUS_AVAILABLE)
        self.active_call = None
```

**Warning signs:**
- Call UI stuck in "Connecting" after remote hangs up
- Cannot make new call after previous call ended
- active_call is not None after remote disconnect

### Pitfall 3: Missing Identity Recall Before Link Creation

**What goes wrong:** Creating RNS.Link with unknown identity (not in Reticulum's recall cache) causes cryptographic verification to fail.

**Why it happens:** Reticulum needs the remote's public key to verify link. If identity never seen before, recall returns None.

**How to avoid:**
```python
identity = RNS.Identity.recall(destination_hash)
if identity is None:
    return {"success": False, "error": "Unknown identity"}
destination = RNS.Destination(identity, RNS.Destination.OUT, ...)
```

**Warning signs:**
- Link establishment fails with crypto error
- "Identity could not be recalled" in logs
- Works with previously-contacted peers, fails with new peers

### Pitfall 4: Double-Decoding msgpack Packets

**What goes wrong:** Python unpacks msgpack, forwards raw bytes to Kotlin, Kotlin tries to unpack again → fails.

**Why it happens:** Confusion about packet format at bridge boundary.

**How to avoid:**
- Python receives msgpack from Reticulum → unpacks → forwards FIELD_FRAMES value (codec byte + frame) to Kotlin
- Python receives from Kotlin → packs as `{0x01: [frame]}` → sends msgpack to Reticulum
- Kotlin never sees msgpack dict structure (only frame bytes)

**Warning signs:**
- "Invalid msgpack data" errors in Kotlin
- Audio frames appear corrupted
- Signalling values wrong (e.g., 0x81 instead of 0x04)

### Pitfall 5: Ignoring Timeouts

**What goes wrong:** Outgoing call hangs forever if remote never responds.

**Why it happens:** Python LXST has explicit timeouts (wait_time=70s, ring_time=60s). Without them, resources leak.

**How to avoid:**
```python
# Outgoing call timeout
timeout = time.time() + self.wait_time
while not link_established and time.time() < timeout:
    time.sleep(0.2)
if not link_established:
    self.hangup()

# Ring timeout (incoming)
timeout = time.time() + self.ring_time
# Check in separate thread, call hangup() if not answered by timeout
```

**Warning signs:**
- Call never transitions from CALLING state
- active_call persists after failed call attempt
- Cannot make new call after timeout (previous call not cleaned up)

## Code Examples

Verified patterns from Python LXST and Reticulum:

### Example 1: Outgoing Call with Path Discovery

**Source:** Python LXST Telephony.py lines 648-673

```python
def call(self, destination_hash_hex):
    """Initiate outgoing call with path discovery."""
    # Recall identity
    identity_hash = bytes.fromhex(destination_hash_hex)
    identity = RNS.Identity.recall(identity_hash)
    if identity is None:
        return {"success": False, "error": "Unknown identity"}

    # Create destination
    call_destination = RNS.Destination(
        identity,
        RNS.Destination.OUT,
        RNS.Destination.SINGLE,
        "lxst",
        "telephony"
    )

    # Request path if not known
    if not RNS.Transport.has_path(call_destination.hash):
        RNS.Transport.request_path(call_destination.hash)
        timeout = time.time() + 70  # wait_time
        while not RNS.Transport.has_path(call_destination.hash) and time.time() < timeout:
            time.sleep(0.2)

        if not RNS.Transport.has_path(call_destination.hash):
            return {"success": False, "error": "Path timeout"}

    # Establish link
    self.active_call = RNS.Link(
        call_destination,
        established_callback=self.__link_established,
        closed_callback=self.__link_closed
    )
    self.active_call.set_packet_callback(self.__packet_received)

    return {"success": True}
```

### Example 2: Incoming Call Destination Registration

**Source:** Python LXST Telephony.py lines 138-143, 318-334

```python
def __init__(self, identity):
    """Register destination for incoming calls."""
    self.identity = identity
    self.destination = RNS.Destination(
        self.identity,
        RNS.Destination.IN,
        RNS.Destination.SINGLE,
        "lxst",
        "telephony"
    )
    self.destination.set_proof_strategy(RNS.Destination.PROVE_NONE)
    self.destination.set_link_established_callback(self.__incoming_link_established)
    self.active_call = None

def __incoming_link_established(self, link):
    """Handle incoming link (pre-identification)."""
    if self.active_call or self.busy:
        # Already in call, reject
        self.send_signal(Signalling.STATUS_BUSY, link)
        link.teardown()
    else:
        # Accept link, wait for identity verification
        link.set_remote_identified_callback(self.__caller_identified)
        link.set_link_closed_callback(self.__link_closed)
        link.set_packet_callback(self.__packet_received)
        self.send_signal(Signalling.STATUS_AVAILABLE, link)

def __caller_identified(self, link, identity):
    """Handle caller identity verification."""
    if not self.is_allowed(identity):
        self.send_signal(Signalling.STATUS_BUSY, link)
        link.teardown()
    else:
        self.active_call = link
        self.send_signal(Signalling.STATUS_RINGING, link)
        # Notify Kotlin via NetworkPacketBridge
        self.kotlin_bridge.onPythonSignalReceived(Signalling.STATUS_RINGING)
```

### Example 3: Send Audio Packet with LXST Format

**Source:** Python LXST Network.py lines 57-67

```python
from RNS.vendor import umsgpack as mp

def send_audio_packet(self, encoded_frame):
    """Send encoded audio frame over active link.

    Args:
        encoded_frame: bytes (codec header byte + encoded frame from Kotlin)
    """
    if self.active_call is None or self.active_call.status != RNS.Link.ACTIVE:
        return

    # Wrap in LXST msgpack format
    packet_data = {0x01: encoded_frame}  # FIELD_FRAMES = 0x01
    packet = RNS.Packet(self.active_call, mp.packb(packet_data), create_receipt=False)
    packet.send()
```

### Example 4: Receive and Parse Packets

**Source:** Python LXST Network.py lines 109-137

```python
from RNS.vendor import umsgpack as mp

def __packet_received(self, data, packet):
    """Handle incoming packet (audio or signalling).

    Called by Reticulum when packet arrives on link.
    """
    try:
        unpacked = mp.unpackb(data)
        if type(unpacked) != dict:
            return

        # Audio frames
        if 0x01 in unpacked:  # FIELD_FRAMES
            frames = unpacked[0x01]
            if type(frames) != list:
                frames = [frames]
            for frame in frames:
                # Forward to Kotlin via NetworkPacketBridge
                self.kotlin_bridge.onPythonPacketReceived(frame)

        # Signalling
        if 0x00 in unpacked:  # FIELD_SIGNALLING
            signals = unpacked[0x00]
            if type(signals) != list:
                signals = [signals]
            for signal in signals:
                # Forward to Kotlin via NetworkPacketBridge
                self.kotlin_bridge.onPythonSignalReceived(signal)

    except Exception as e:
        RNS.log(f"Error processing packet: {e}", RNS.LOG_ERROR)
```

### Example 5: Send Signalling

**Source:** Python LXST Network.py lines 25-33

```python
from RNS.vendor import umsgpack as mp

def send_signal(self, signal):
    """Send signalling to remote peer.

    Args:
        signal: int (Signalling.STATUS_* constant)
    """
    if self.active_call is None or self.active_call.status != RNS.Link.ACTIVE:
        return

    # Wrap in LXST msgpack format
    signalling_data = {0x00: [signal]}  # FIELD_SIGNALLING = 0x00
    packet = RNS.Packet(self.active_call, mp.packb(signalling_data), create_receipt=False)
    packet.send()
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Python LXST Telephone (897 lines) with audio pipelines | Kotlin Telephone + Python network transport | Phase 11 (v0.8.0) | Eliminates JNI bridge latency, enables native Android audio |
| Pyjnius for Android audio (incompatible with Chaquopy) | Chaquopy + KotlinAudioBridge | Phase 11 | Makes Python LXST audio pipelines obsolete |
| Single-language telephony stack | Kotlin (audio) + Python (network) split | Phase 11 | Requires careful bridge design, but eliminates dual-pipeline conflict |

**Deprecated/outdated:**
- **Python LXST Telephony.py**: Lines 138-732 handle audio pipelines, state machine, callbacks. After Phase 11, Kotlin owns these. Python should only handle network (lines 1-145 of Network.py patterns).
- **Phase 11.6 flag-based audio disable**: _kotlin_audio_active flag was band-aid for dual-pipeline conflict. Phase 11.7 removes Python audio entirely, making flag unnecessary.

## Open Questions

### 1. Should we keep LXST wheel dependency temporarily?

**What we know:**
- LXST provides `APP_NAME="lxst"` and `PRIMITIVE_NAME="telephony"` constants
- Wire format field constants: `FIELD_SIGNALLING=0x00`, `FIELD_FRAMES=0x01`
- Signalling status codes match Kotlin exactly (STATUS_BUSY=0x00 through STATUS_ESTABLISHED=0x06)

**What's unclear:**
- Can we hard-code these constants in call_manager.py, or should we keep minimal LXST import?
- If LXST removed completely, will other Columba installations (running old versions) still be able to call us?

**Recommendation:**
Hard-code constants in call_manager.py. Wire format is frozen (msgpack with 0x00/0x01 field IDs). LXST wheel is 4.5MB, removing it speeds up build and deployment. Constants are simple:
```python
# LXST-compatible constants
APP_NAME = "lxst"
PRIMITIVE_NAME = "telephony"
FIELD_SIGNALLING = 0x00
FIELD_FRAMES = 0x01

# Signalling status codes (from Kotlin Signalling.kt)
STATUS_BUSY = 0x00
STATUS_REJECTED = 0x01
STATUS_CALLING = 0x02
STATUS_AVAILABLE = 0x03
STATUS_RINGING = 0x04
STATUS_CONNECTING = 0x05
STATUS_ESTABLISHED = 0x06
```

### 2. How much of NetworkPacketBridge survives Phase 11.7?

**What we know:**
- NetworkPacketBridge currently forwards packets bidirectionally (Python ↔ Kotlin)
- It has sendPacket/sendSignal (Kotlin→Python) and onPythonPacketReceived/onPythonSignalReceived (Python→Kotlin)
- Lines 89-98: sendPacket() calls pythonNetworkHandler.send_audio_packet()
- Lines 108-115: sendSignal() calls pythonNetworkHandler.send_signal()

**What's unclear:**
- After Phase 11.7, does PythonNetworkTransport still use NetworkPacketBridge, or direct call_manager methods?
- NetworkPacketBridge has "Phase 10 network bridge" comment — is it Phase 10 infrastructure we're keeping?

**Recommendation:**
Keep NetworkPacketBridge. It provides clean separation between Chaquopy mechanics (PyObject calls, Dispatchers.IO) and business logic (packet/signal handling). PythonNetworkTransport.sendPacket() → NetworkPacketBridge.sendPacket() → call_manager.send_audio_packet() keeps layers clean.

### 3. What about the incoming call answer flow?

**What we know:**
- Python LXST has two-step incoming flow: __incoming_link_established → __caller_identified → answer()
- Identity verification ensures caller is in allow list before ringing
- answer() method called by UI (via Kotlin → Python bridge)

**What's unclear:**
- Should call_manager.py handle allow list checking, or delegate to Kotlin?
- Phase 11 Kotlin Telephone doesn't seem to have allow list concept (no isAllowed check visible)

**Recommendation:**
Python call_manager.py handles allow list. Rationale:
1. Allow list is stored Python-side (Reticulum identity management)
2. Network layer (Python) should reject unwanted links before signalling Kotlin
3. Avoids round-trip: Link arrives → Python checks allow → if rejected, sends BUSY and tears down WITHOUT Kotlin involvement
4. Kotlin Telephone only sees allowed calls (simpler state machine)

Pattern:
```python
def __caller_identified(self, link, identity):
    if not self.is_allowed(identity):
        self.send_signal(STATUS_BUSY, link)
        link.teardown()
        return  # Don't notify Kotlin

    # Allowed - notify Kotlin
    self.active_call = link
    self.kotlin_bridge.onPythonSignalReceived(STATUS_RINGING)
```

## Sources

### Primary (HIGH confidence)

- **Python LXST Telephony.py** - `/app/build/python/pip/noSentryDebug/common/LXST/Primitives/Telephony.py` (897 lines)
  - Full state machine implementation (lines 114-732)
  - Incoming/outgoing call patterns (lines 318-364, 648-673)
  - Signalling and timeout handling

- **Python LXST Network.py** - `/app/build/python/pip/noSentryDebug/common/LXST/Network.py` (145 lines)
  - msgpack wire format (lines 10-11: FIELD_SIGNALLING=0x00, FIELD_FRAMES=0x01)
  - Packetizer.handle_frame() sending pattern (lines 57-67)
  - LinkSource._packet() receiving pattern (lines 109-137)

- **Current call_manager.py** - `/python/lxst_modules/call_manager.py` (664 lines)
  - Python LXST wrapper patterns
  - Kotlin callback bridge (lines 222-283, 493-600)
  - Methods to preserve: call(), answer(), hangup(), mute_microphone()

- **Reticulum Link.py** - `/app/build/python/pip/noSentryDebug/common/RNS/Link.py`
  - Link.__init__ signature (established_callback, closed_callback)
  - Callback registration: set_link_established_callback, set_packet_callback, set_remote_identified_callback
  - Link.status constants (ACTIVE, etc.)

- **Reticulum Destination.py** - `/app/build/python/pip/noSentryDebug/common/RNS/Destination.py`
  - Destination.__init__ signature (identity, direction, type, app_name, *aspects)
  - set_link_established_callback() for incoming calls
  - Direction constants: IN, OUT, SINGLE

- **Kotlin Telephone.kt** - `/reticulum/src/main/java/.../call/telephone/Telephone.kt` (897 lines)
  - State machine (matches Python exactly)
  - Profile management (Kotlin is single source of truth)
  - NetworkTransport interface usage

- **Phase 11.6 VERIFICATION.md** - `.planning/phases/11.6-python-audio-disable/11.6-VERIFICATION.md`
  - Flag-based audio disable pattern (to be reverted)
  - chaquopy_audio_backend.py changes (lines 46-110: _kotlin_audio_active flag)
  - lxst_debug_instrumentation.py changes (lines 103-110: skip processing check)

### Secondary (MEDIUM confidence)

- **app/build.gradle.kts** - LXST dependency declaration (lines 350-353, 372)
  - Shows LXST version: 0.4.5
  - extractPackages includes LXST (will be removed)

- **NetworkPacketBridge.kt** - `/reticulum/src/main/java/.../audio/bridge/NetworkPacketBridge.kt` (226 lines)
  - Bridge pattern for packet/signal forwarding
  - Threading model (Dispatchers.IO for Python calls)
  - Callback registration (setPacketCallback, setSignalCallback)

### Tertiary (LOW confidence)

- **WebSearch: "Reticulum RNS Link API patterns"** - Not performed (sufficient primary sources)
- **WebSearch: "msgpack Python encoding patterns"** - Not needed (umsgpack usage clear from LXST code)

## Metadata

**Confidence breakdown:**
- Wire format: HIGH - Directly verified in LXST Network.py source code
- Link lifecycle: HIGH - Multiple examples in Reticulum utilities and LXST code
- State machine flow: HIGH - Complete Python LXST Telephony.py implementation available
- Identity verification: HIGH - Clear pattern in __caller_identified callback
- Phase 11.6 revert scope: HIGH - VERIFICATION.md documents exact changes to revert

**Research date:** 2026-02-05
**Valid until:** 2026-03-05 (30 days - stable APIs, unlikely to change)

**Key assumptions:**
1. LXST wire format is frozen (interoperability requirement)
2. Reticulum Link API is stable (mature library)
3. Kotlin Telephone state machine won't change during Phase 11.7 (single-phase scope)
4. NetworkPacketBridge survives Phase 11.7 (clean architecture separation)
