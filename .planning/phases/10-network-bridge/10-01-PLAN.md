---
phase: 10-network-bridge
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - reticulum/src/main/java/com/lxmf/messenger/reticulum/audio/bridge/NetworkPacketBridge.kt
autonomous: true

must_haves:
  truths:
    - "NetworkPacketBridge singleton exists and is accessible"
    - "sendPacket() accepts ByteArray and calls Python handler"
    - "onPythonPacketReceived() accepts ByteArray and invokes Kotlin callback"
    - "sendSignal() accepts Int and calls Python handler"
    - "Bridge uses Dispatchers.IO for non-blocking Python calls"
  artifacts:
    - path: "reticulum/src/main/java/com/lxmf/messenger/reticulum/audio/bridge/NetworkPacketBridge.kt"
      provides: "Low-level packet handoff between Kotlin and Python"
      min_lines: 80
      exports: ["NetworkPacketBridge", "getInstance"]
  key_links:
    - from: "NetworkPacketBridge.sendPacket"
      to: "pythonNetworkHandler.callAttr"
      via: "Chaquopy PyObject call"
      pattern: "pythonNetworkHandler.*callAttr"
    - from: "NetworkPacketBridge.onPythonPacketReceived"
      to: "onPacketReceived callback"
      via: "lambda invocation"
      pattern: "onPacketReceived\\?.*invoke"
---

<objective>
Create NetworkPacketBridge - the low-level coordination layer for packet transfer between Kotlin and Python.

Purpose: Foundation for Phase 10 network bridge. All packet/signalling traffic flows through this single point.
Output: NetworkPacketBridge.kt singleton with sendPacket, onPythonPacketReceived, sendSignal methods.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-network-bridge/10-RESEARCH.md
@.planning/phases/10-network-bridge/10-CONTEXT.md

# Reference implementations
@reticulum/src/main/java/com/lxmf/messenger/reticulum/audio/bridge/KotlinAudioBridge.kt
@reticulum/src/main/java/com/lxmf/messenger/reticulum/call/bridge/CallBridge.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create NetworkPacketBridge singleton</name>
  <files>reticulum/src/main/java/com/lxmf/messenger/reticulum/audio/bridge/NetworkPacketBridge.kt</files>
  <action>
Create NetworkPacketBridge following the KotlinAudioBridge singleton pattern:

1. Package: `com.lxmf.messenger.reticulum.audio.bridge`

2. Companion object with:
   - `private const val TAG = "Columba:NetBridge"`
   - `@Volatile private var instance: NetworkPacketBridge? = null`
   - `fun getInstance(context: Context): NetworkPacketBridge` (double-checked locking)
   - `internal fun resetInstance()` for testing

3. Private state:
   - `@Volatile private var pythonNetworkHandler: PyObject? = null` (set by PythonWrapperManager)
   - `@Volatile private var onPacketReceived: ((ByteArray) -> Unit)? = null` (set by LinkSource)
   - `@Volatile private var onSignalReceived: ((Int) -> Unit)? = null` (set by SignallingReceiver)
   - `private val scope = CoroutineScope(Dispatchers.IO + SupervisorJob())` (dedicated bridge thread)

4. Public methods:

   `fun sendPacket(encodedFrame: ByteArray)`:
   - Launch coroutine on scope (non-blocking)
   - Call `pythonNetworkHandler?.callAttr("send_audio_packet", encodedFrame)`
   - Catch exceptions silently (no blocking Log.d in hot path)
   - CRITICAL: No synchronous logging in this method

   `fun onPythonPacketReceived(packetData: ByteArray)`:
   - Called by Python via Chaquopy (must be fast - GIL held)
   - Simply invoke `onPacketReceived?.invoke(packetData)`
   - No processing, no logging (queue handoff only)

   `fun sendSignal(signal: Int)`:
   - Launch coroutine on scope (non-blocking)
   - Call `pythonNetworkHandler?.callAttr("send_signal", signal)`
   - Catch exceptions silently

   `fun onPythonSignalReceived(signal: Int)`:
   - Called by Python via Chaquopy
   - Invoke `onSignalReceived?.invoke(signal)`

5. Setup methods:
   - `fun setPythonNetworkHandler(handler: PyObject)` - stores Python reference
   - `fun setPacketCallback(callback: (ByteArray) -> Unit)` - for LinkSource
   - `fun setSignalCallback(callback: (Int) -> Unit)` - for SignallingReceiver

6. Shutdown:
   - `fun shutdown()` - cancel scope, null out references

CRITICAL: No Log.d() calls in sendPacket or onPythonPacketReceived methods - this blocks audio thread.
Use Log only in setup/teardown methods where blocking is acceptable.
  </action>
  <verify>
Build succeeds: `cd /home/tyler/repos/public/columba && JAVA_HOME=/home/tyler/android-studio/jbr ./gradlew :reticulum:compileDebugKotlin 2>&1 | tail -20`
File exists with expected exports: `grep -E "class NetworkPacketBridge|fun sendPacket|fun onPythonPacketReceived|fun sendSignal" reticulum/src/main/java/com/lxmf/messenger/reticulum/audio/bridge/NetworkPacketBridge.kt`
  </verify>
  <done>
NetworkPacketBridge.kt compiles and contains:
- Singleton with getInstance(context)
- sendPacket(ByteArray) using Dispatchers.IO coroutine
- onPythonPacketReceived(ByteArray) with callback invocation
- sendSignal(Int) using Dispatchers.IO coroutine
- No synchronous logging in packet hot path
  </done>
</task>

</tasks>

<verification>
1. Build passes: `./gradlew :reticulum:compileDebugKotlin`
2. NetworkPacketBridge.kt exists with ~80+ lines
3. Uses Dispatchers.IO for Python calls (grep confirms)
4. No Log.d in sendPacket or onPythonPacketReceived methods
</verification>

<success_criteria>
- NetworkPacketBridge singleton compiles
- sendPacket and sendSignal use coroutine scope (non-blocking)
- onPythonPacketReceived invokes callback without processing
- No synchronous logging in packet path
</success_criteria>

<output>
After completion, create `.planning/phases/10-network-bridge/10-01-SUMMARY.md`
</output>
