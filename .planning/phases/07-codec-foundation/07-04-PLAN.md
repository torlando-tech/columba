---
phase: 07-codec-foundation
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - reticulum/src/androidTest/java/com/lxmf/messenger/reticulum/audio/codec/OpusInstrumentedTest.kt
  - reticulum/build.gradle.kts
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "All 9 Opus profiles (VOICE_LOW through AUDIO_MAX) encode successfully"
    - "Opus.encode() returns non-empty ByteArray for each profile"
    - "Opus.decode() successfully decodes encoded packets"
  artifacts:
    - path: "reticulum/src/androidTest/java/com/lxmf/messenger/reticulum/audio/codec/OpusInstrumentedTest.kt"
      provides: "Instrumented tests for Opus encode/decode on device"
      min_lines: 100
  key_links:
    - from: "OpusInstrumentedTest"
      to: "Opus.encode()"
      via: "JNI native library call"
      pattern: "opus\\.encode\\(.*\\)"
    - from: "OpusInstrumentedTest"
      to: "Opus.decode()"
      via: "JNI native library call"
      pattern: "opus\\.decode\\(.*\\)"
---

<objective>
Create instrumented tests that verify Opus encoder/decoder functionality with JNI libraries on Android device.

Purpose: Close gap from VERIFICATION.md - "All 9 profiles encode successfully" failed because no tests call encode() method. JNI libraries only load on Android runtime, not Robolectric.

Output: Instrumented tests in reticulum/src/androidTest/ that run on device/emulator and verify all 9 Opus profiles can encode audio frames.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-codec-foundation/07-VERIFICATION.md
@reticulum/src/main/java/com/lxmf/messenger/reticulum/audio/codec/Opus.kt
@reticulum/src/test/java/com/lxmf/messenger/reticulum/audio/codec/OpusTest.kt
@app/src/androidTest/java/com/lxmf/messenger/smoke/SmokeTest.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add instrumented test dependencies to reticulum module</name>
  <files>reticulum/build.gradle.kts</files>
  <action>
Add androidTest dependencies to reticulum/build.gradle.kts:

```kotlin
androidTestImplementation(libs.test.runner)
androidTestImplementation(libs.test.ext.junit)
androidTestImplementation(libs.test.core)
```

These are likely already defined in libs.versions.toml from the app module. If not, use:
```kotlin
androidTestImplementation("androidx.test:runner:1.5.2")
androidTestImplementation("androidx.test.ext:junit:1.1.5")
androidTestImplementation("androidx.test:core:1.5.0")
```

Do NOT add any other dependencies. The Opus library is already a dependency.
  </action>
  <verify>
Run: `JAVA_HOME=/home/tyler/android-studio/jbr ./gradlew :reticulum:dependencies --configuration androidTestImplementation`
Should show test runner, junit ext, and core in dependency tree.
  </verify>
  <done>Instrumented test dependencies available in reticulum module</done>
</task>

<task type="auto">
  <name>Task 2: Create Opus instrumented test for all 9 profiles</name>
  <files>reticulum/src/androidTest/java/com/lxmf/messenger/reticulum/audio/codec/OpusInstrumentedTest.kt</files>
  <action>
Create instrumented test file that tests all 9 Opus profiles on device.

Structure:
1. Create directory: reticulum/src/androidTest/java/com/lxmf/messenger/reticulum/audio/codec/
2. Create OpusInstrumentedTest.kt with @RunWith(AndroidJUnit4::class)

Tests to implement:

```kotlin
package com.lxmf.messenger.reticulum.audio.codec

import androidx.test.ext.junit.runners.AndroidJUnit4
import org.junit.After
import org.junit.Assert.*
import org.junit.Test
import org.junit.runner.RunWith

/**
 * Instrumented tests for Opus codec.
 *
 * These tests run on Android device/emulator where JNI libraries can load.
 * Verifies actual encode/decode functionality for all 9 profiles.
 */
@RunWith(AndroidJUnit4::class)
class OpusInstrumentedTest {

    private var opus: Opus? = null

    @After
    fun cleanup() {
        opus?.release()
        opus = null
    }

    /**
     * Generate test audio: 20ms of 440Hz sine wave at given sample rate.
     */
    private fun generateTestTone(sampleRate: Int, channels: Int): FloatArray {
        val samplesPerChannel = (sampleRate * 0.02).toInt() // 20ms frame
        val totalSamples = samplesPerChannel * channels
        return FloatArray(totalSamples) { i ->
            val sampleIndex = i / channels
            val phase = (sampleIndex.toFloat() / sampleRate) * 440f * 2f * Math.PI.toFloat()
            kotlin.math.sin(phase) * 0.5f // 50% amplitude
        }
    }

    @Test
    fun voiceLow_encodesSuccessfully() {
        opus = Opus(Opus.PROFILE_VOICE_LOW)
        val sampleRate = Opus.profileSamplerate(Opus.PROFILE_VOICE_LOW) // 8000
        val channels = Opus.profileChannels(Opus.PROFILE_VOICE_LOW) // 1
        val testAudio = generateTestTone(sampleRate, channels)

        val encoded = opus!!.encode(testAudio)

        assertTrue("Encoded output should not be empty", encoded.isNotEmpty())
        println("VOICE_LOW encoded ${testAudio.size} samples to ${encoded.size} bytes")
    }

    @Test
    fun voiceMedium_encodesSuccessfully() {
        opus = Opus(Opus.PROFILE_VOICE_MEDIUM)
        val sampleRate = Opus.profileSamplerate(Opus.PROFILE_VOICE_MEDIUM) // 24000
        val channels = Opus.profileChannels(Opus.PROFILE_VOICE_MEDIUM) // 1
        val testAudio = generateTestTone(sampleRate, channels)

        val encoded = opus!!.encode(testAudio)

        assertTrue("Encoded output should not be empty", encoded.isNotEmpty())
        println("VOICE_MEDIUM encoded ${testAudio.size} samples to ${encoded.size} bytes")
    }

    @Test
    fun voiceHigh_encodesSuccessfully() {
        opus = Opus(Opus.PROFILE_VOICE_HIGH)
        val sampleRate = Opus.profileSamplerate(Opus.PROFILE_VOICE_HIGH) // 48000
        val channels = Opus.profileChannels(Opus.PROFILE_VOICE_HIGH) // 1
        val testAudio = generateTestTone(sampleRate, channels)

        val encoded = opus!!.encode(testAudio)

        assertTrue("Encoded output should not be empty", encoded.isNotEmpty())
        println("VOICE_HIGH encoded ${testAudio.size} samples to ${encoded.size} bytes")
    }

    @Test
    fun voiceMax_encodesSuccessfully() {
        opus = Opus(Opus.PROFILE_VOICE_MAX)
        val sampleRate = Opus.profileSamplerate(Opus.PROFILE_VOICE_MAX) // 48000
        val channels = Opus.profileChannels(Opus.PROFILE_VOICE_MAX) // 2
        val testAudio = generateTestTone(sampleRate, channels)

        val encoded = opus!!.encode(testAudio)

        assertTrue("Encoded output should not be empty", encoded.isNotEmpty())
        println("VOICE_MAX encoded ${testAudio.size} samples to ${encoded.size} bytes")
    }

    @Test
    fun audioMin_encodesSuccessfully() {
        opus = Opus(Opus.PROFILE_AUDIO_MIN)
        val sampleRate = Opus.profileSamplerate(Opus.PROFILE_AUDIO_MIN) // 8000
        val channels = Opus.profileChannels(Opus.PROFILE_AUDIO_MIN) // 1
        val testAudio = generateTestTone(sampleRate, channels)

        val encoded = opus!!.encode(testAudio)

        assertTrue("Encoded output should not be empty", encoded.isNotEmpty())
        println("AUDIO_MIN encoded ${testAudio.size} samples to ${encoded.size} bytes")
    }

    @Test
    fun audioLow_encodesSuccessfully() {
        opus = Opus(Opus.PROFILE_AUDIO_LOW)
        val sampleRate = Opus.profileSamplerate(Opus.PROFILE_AUDIO_LOW) // 12000
        val channels = Opus.profileChannels(Opus.PROFILE_AUDIO_LOW) // 1
        val testAudio = generateTestTone(sampleRate, channels)

        val encoded = opus!!.encode(testAudio)

        assertTrue("Encoded output should not be empty", encoded.isNotEmpty())
        println("AUDIO_LOW encoded ${testAudio.size} samples to ${encoded.size} bytes")
    }

    @Test
    fun audioMedium_encodesSuccessfully() {
        opus = Opus(Opus.PROFILE_AUDIO_MEDIUM)
        val sampleRate = Opus.profileSamplerate(Opus.PROFILE_AUDIO_MEDIUM) // 24000
        val channels = Opus.profileChannels(Opus.PROFILE_AUDIO_MEDIUM) // 2
        val testAudio = generateTestTone(sampleRate, channels)

        val encoded = opus!!.encode(testAudio)

        assertTrue("Encoded output should not be empty", encoded.isNotEmpty())
        println("AUDIO_MEDIUM encoded ${testAudio.size} samples to ${encoded.size} bytes")
    }

    @Test
    fun audioHigh_encodesSuccessfully() {
        opus = Opus(Opus.PROFILE_AUDIO_HIGH)
        val sampleRate = Opus.profileSamplerate(Opus.PROFILE_AUDIO_HIGH) // 48000
        val channels = Opus.profileChannels(Opus.PROFILE_AUDIO_HIGH) // 2
        val testAudio = generateTestTone(sampleRate, channels)

        val encoded = opus!!.encode(testAudio)

        assertTrue("Encoded output should not be empty", encoded.isNotEmpty())
        println("AUDIO_HIGH encoded ${testAudio.size} samples to ${encoded.size} bytes")
    }

    @Test
    fun audioMax_encodesSuccessfully() {
        opus = Opus(Opus.PROFILE_AUDIO_MAX)
        val sampleRate = Opus.profileSamplerate(Opus.PROFILE_AUDIO_MAX) // 48000
        val channels = Opus.profileChannels(Opus.PROFILE_AUDIO_MAX) // 2
        val testAudio = generateTestTone(sampleRate, channels)

        val encoded = opus!!.encode(testAudio)

        assertTrue("Encoded output should not be empty", encoded.isNotEmpty())
        println("AUDIO_MAX encoded ${testAudio.size} samples to ${encoded.size} bytes")
    }

    @Test
    fun voiceLow_decodesSuccessfully() {
        opus = Opus(Opus.PROFILE_VOICE_LOW)
        val sampleRate = Opus.profileSamplerate(Opus.PROFILE_VOICE_LOW)
        val channels = Opus.profileChannels(Opus.PROFILE_VOICE_LOW)
        val testAudio = generateTestTone(sampleRate, channels)

        val encoded = opus!!.encode(testAudio)
        val decoded = opus!!.decode(encoded)

        assertTrue("Decoded output should not be empty", decoded.isNotEmpty())
        println("VOICE_LOW round-trip: ${testAudio.size} -> ${encoded.size} bytes -> ${decoded.size} samples")
    }

    @Test
    fun allProfiles_encodeWithoutException() {
        val profiles = listOf(
            Opus.PROFILE_VOICE_LOW to "VOICE_LOW",
            Opus.PROFILE_VOICE_MEDIUM to "VOICE_MEDIUM",
            Opus.PROFILE_VOICE_HIGH to "VOICE_HIGH",
            Opus.PROFILE_VOICE_MAX to "VOICE_MAX",
            Opus.PROFILE_AUDIO_MIN to "AUDIO_MIN",
            Opus.PROFILE_AUDIO_LOW to "AUDIO_LOW",
            Opus.PROFILE_AUDIO_MEDIUM to "AUDIO_MEDIUM",
            Opus.PROFILE_AUDIO_HIGH to "AUDIO_HIGH",
            Opus.PROFILE_AUDIO_MAX to "AUDIO_MAX"
        )

        val results = mutableListOf<String>()

        for ((profile, name) in profiles) {
            opus?.release()
            opus = Opus(profile)

            val sampleRate = Opus.profileSamplerate(profile)
            val channels = Opus.profileChannels(profile)
            val testAudio = generateTestTone(sampleRate, channels)

            try {
                val encoded = opus!!.encode(testAudio)
                assertTrue("$name should produce non-empty output", encoded.isNotEmpty())
                results.add("$name: OK (${encoded.size} bytes)")
            } catch (e: Exception) {
                fail("$name failed to encode: ${e.message}")
            }
        }

        println("All profiles encode summary:")
        results.forEach { println("  $it") }
    }
}
```

IMPORTANT:
- Use exact profile constants from Opus.kt companion object
- Use @After to release native resources after each test
- Log output to help debug if tests fail
  </action>
  <verify>
Build with: `JAVA_HOME=/home/tyler/android-studio/jbr ./gradlew :reticulum:assembleDebugAndroidTest`
Should compile without errors. Full test run requires device/emulator.
  </verify>
  <done>OpusInstrumentedTest.kt exists with tests for all 9 profiles calling encode() and decode()</done>
</task>

</tasks>

<verification>
1. Build succeeds: `./gradlew :reticulum:assembleDebugAndroidTest`
2. Test file exists: reticulum/src/androidTest/java/com/lxmf/messenger/reticulum/audio/codec/OpusInstrumentedTest.kt
3. Test count: At least 11 tests (9 profile encode + 1 decode + 1 all-profiles)
</verification>

<success_criteria>
- OpusInstrumentedTest.kt created with instrumented tests
- All 9 profiles have individual encode tests
- Tests actually call Opus.encode() and Opus.decode()
- Build compiles successfully for androidTest
- Tests are ready to run on device/emulator
</success_criteria>

<output>
After completion, create `.planning/phases/07-codec-foundation/07-04-SUMMARY.md`
</output>
