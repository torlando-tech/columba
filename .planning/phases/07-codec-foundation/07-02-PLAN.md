---
phase: 07-codec-foundation
plan: 02
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - reticulum/src/main/java/com/lxmf/messenger/reticulum/audio/codec/Opus.kt
  - reticulum/src/test/java/com/lxmf/messenger/reticulum/audio/codec/OpusTest.kt
  - app/build.gradle.kts
autonomous: true

user_setup:
  - service: opus-jni
    why: "Opus encoding/decoding via JNI wrapper"
    gradle_dependency:
      - name: "io.rebble.cobble:opus-jni:1.0.0"
        source: "Add to app/build.gradle.kts dependencies"
        note: "May need to verify exact artifact name/version via Maven Central search"

must_haves:
  truths:
    - "Opus encoder produces bit-identical output to Python pyogg for same input"
    - "All 9 profiles (VOICE_LOW through AUDIO_MAX) encode successfully"
    - "Encoded packets have correct bitrate ceiling for each profile"
    - "Decode reverses encode (round-trip preserves audio quality)"
  artifacts:
    - path: "reticulum/src/main/java/com/lxmf/messenger/reticulum/audio/codec/Opus.kt"
      provides: "Opus codec with all 9 profiles"
      min_lines: 200
      exports: ["Opus", "PROFILE_VOICE_LOW", "PROFILE_AUDIO_MAX"]
    - path: "reticulum/src/test/java/com/lxmf/messenger/reticulum/audio/codec/OpusTest.kt"
      provides: "Wire compatibility tests"
      min_lines: 80
  key_links:
    - from: "Opus.encode()"
      to: "OpusEncoder JNI"
      via: "opus-jni library binding"
      pattern: "OpusEncoder.*encode"
    - from: "Opus.setProfile()"
      to: "encoder config (channels, samplerate, application, bitrate)"
      via: "profile constants map to encoder parameters"
      pattern: "profile.*channels|samplerate|application"
---

<objective>
Implement Opus codec in Kotlin with all 9 quality profiles, producing wire-compatible output with Python LXST.

Purpose: Enable low-bitrate voice encoding (VOICE_LOW through VOICE_MAX) and higher-quality audio encoding (AUDIO_MIN through AUDIO_MAX) for different call quality scenarios.

Output: Working Opus.kt with encoder/decoder and unit tests verifying bit-identical output to Python pyogg.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/07-codec-foundation/07-CONTEXT.md
@.planning/REQUIREMENTS.md

# Python reference implementation
@app/build/python/pip/noSentryDebug/common/LXST/Codecs/Opus.py

# Depends on Plan 01
@.planning/phases/07-codec-foundation/07-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Add opus-jni dependency to build.gradle.kts</name>
  <files>app/build.gradle.kts</files>
  <action>
Add Opus JNI library dependency to app/build.gradle.kts:

1. Search Maven Central for the correct artifact:
   - Try `io.rebble.cobble:opus-jni` first
   - If not found, search for alternative android-opus-codec libraries
   - Verify .so libraries are bundled (not downloaded at runtime)

2. Add to dependencies block:
```kotlin
dependencies {
    // ... existing dependencies ...

    // Opus codec for voice/audio encoding
    implementation("io.rebble.cobble:opus-jni:1.0.0") // Adjust version after Maven search
}
```

3. Sync Gradle and verify native libraries are included:
```bash
./gradlew :app:dependencies | grep opus
```

If opus-jni is unavailable, research alternative: `com.ustadmobile.codec2:codec2-android` includes Opus support, or find android-opus-codec on GitHub.

Do NOT proceed with stub implementation â€” make the recommended library work or block until user provides alternative.
  </action>
  <verify>
1. `./gradlew :app:dependencies` shows opus library
2. Native .so files present in APK (check with `unzip -l app/build/outputs/apk/debug/*.apk | grep libopus`)
  </verify>
  <done>Opus JNI library added to dependencies and native libraries verified in build output.</done>
</task>

<task type="auto">
  <name>Implement Opus.kt with all 9 profiles</name>
  <files>reticulum/src/main/java/com/lxmf/messenger/reticulum/audio/codec/Opus.kt</files>
  <action>
Create Opus.kt matching Python LXST Opus.py structure:

**Profile constants (exactly match Python hex values):**
```kotlin
class Opus(profile: Int = PROFILE_VOICE_LOW) : Codec() {
    companion object {
        const val FRAME_QUANTA_MS = 2.5f
        const val FRAME_MAX_MS = 60f
        val VALID_FRAME_MS = listOf(2.5f, 5f, 10f, 20f, 40f, 60f)

        // Profile constants (match Python exactly)
        const val PROFILE_VOICE_LOW = 0x00
        const val PROFILE_VOICE_MEDIUM = 0x01
        const val PROFILE_VOICE_HIGH = 0x02
        const val PROFILE_VOICE_MAX = 0x03
        const val PROFILE_AUDIO_MIN = 0x04
        const val PROFILE_AUDIO_LOW = 0x05
        const val PROFILE_AUDIO_MEDIUM = 0x06
        const val PROFILE_AUDIO_HIGH = 0x07
        const val PROFILE_AUDIO_MAX = 0x08

        fun profileChannels(profile: Int): Int = when (profile) {
            PROFILE_VOICE_LOW, PROFILE_VOICE_MEDIUM, PROFILE_VOICE_HIGH,
            PROFILE_AUDIO_MIN, PROFILE_AUDIO_LOW -> 1
            else -> 2  // VOICE_MAX, AUDIO_MEDIUM, AUDIO_HIGH, AUDIO_MAX
        }

        fun profileSamplerate(profile: Int): Int = when (profile) {
            PROFILE_VOICE_LOW, PROFILE_AUDIO_MIN -> 8000
            PROFILE_AUDIO_LOW -> 12000
            PROFILE_VOICE_MEDIUM, PROFILE_AUDIO_MEDIUM -> 24000
            else -> 48000  // VOICE_HIGH, VOICE_MAX, AUDIO_HIGH, AUDIO_MAX
        }

        fun profileApplication(profile: Int): String = when (profile) {
            PROFILE_VOICE_LOW, PROFILE_VOICE_MEDIUM,
            PROFILE_VOICE_HIGH, PROFILE_VOICE_MAX -> "voip"
            else -> "audio"  // All AUDIO profiles
        }

        fun profileBitrateCeiling(profile: Int): Int = when (profile) {
            PROFILE_VOICE_LOW -> 6000
            PROFILE_VOICE_MEDIUM -> 8000
            PROFILE_AUDIO_MIN -> 8000
            PROFILE_AUDIO_LOW -> 14000
            PROFILE_VOICE_HIGH -> 16000
            PROFILE_AUDIO_MEDIUM -> 28000
            PROFILE_VOICE_MAX -> 32000
            PROFILE_AUDIO_HIGH -> 56000
            PROFILE_AUDIO_MAX -> 128000
            else -> throw CodecError("Unsupported profile: $profile")
        }

        fun maxBytesPerFrame(bitrateCeiling: Int, frameDurationMs: Float): Int =
            ceil((bitrateCeiling / 8.0) * (frameDurationMs / 1000.0)).toInt()
    }

    private var opusEncoder: OpusEncoder? = null
    private var opusDecoder: OpusDecoder? = null
    private var encoderConfigured = false
    private var decoderConfigured = false
    private var currentProfile: Int = profile
    private var outputSamplerate: Int = 0
    private var channels: Int = 1

    init {
        frameQuantaMs = FRAME_QUANTA_MS
        frameMaxMs = FRAME_MAX_MS
        validFrameMs = VALID_FRAME_MS
        setProfile(profile)
    }

    fun setProfile(profile: Int) {
        currentProfile = profile
        channels = profileChannels(profile)
        outputSamplerate = profileSamplerate(profile)
        preferredSamplerate = outputSamplerate

        // Reset encoder/decoder (will reconfigure on next encode/decode)
        encoderConfigured = false
        decoderConfigured = false
    }

    fun updateBitrate(frameDurationMs: Float) {
        val bitrateCeiling = profileBitrateCeiling(currentProfile)
        val maxBytes = maxBytesPerFrame(bitrateCeiling, frameDurationMs)
        opusEncoder?.setMaxBytesPerFrame(maxBytes)
    }

    override fun encode(frame: FloatArray): ByteArray {
        // Configure encoder on first call
        if (!encoderConfigured) {
            opusEncoder = OpusEncoder()
            opusEncoder?.setSamplingFrequency(outputSamplerate)
            opusEncoder?.setChannels(channels)
            opusEncoder?.setApplication(profileApplication(currentProfile))
            encoderConfigured = true
        }

        // Convert FloatArray to int16 samples
        val int16Samples = frame.map { (it * 32767f).toInt().coerceIn(-32768, 32767).toShort() }

        // Calculate frame duration and update bitrate
        val frameDurationMs = (int16Samples.size.toFloat() / channels / outputSamplerate) * 1000f
        updateBitrate(frameDurationMs)

        // Encode
        val inputBytes = int16ToBytes(int16Samples)
        return opusEncoder?.encode(inputBytes) ?: throw CodecError("Encoder not initialized")
    }

    override fun decode(frameBytes: ByteArray): FloatArray {
        // Configure decoder on first call
        if (!decoderConfigured) {
            opusDecoder = OpusDecoder()
            opusDecoder?.setChannels(channels)
            opusDecoder?.setSamplingFrequency(outputSamplerate)
            decoderConfigured = true
        }

        val decodedBytes = opusDecoder?.decode(frameBytes) ?: throw CodecError("Decoder not initialized")
        val int16Samples = bytesToInt16(decodedBytes)

        // Convert int16 to FloatArray
        return int16Samples.map { it / 32768f }.toFloatArray()
    }
}
```

**Critical:** Opus encoder output MUST be bit-identical to Python pyogg. Any mismatch breaks wire compatibility.
  </action>
  <verify>
1. `./gradlew :reticulum:compileDebugKotlin` succeeds
2. All 9 profiles instantiate without error
3. Encode produces non-empty ByteArray
4. Decode reverses encode (round-trip works)
  </verify>
  <done>Opus.kt exists with all 9 profiles, encoder/decoder configured correctly, compilation succeeds.</done>
</task>

<task type="auto">
  <name>Create wire compatibility tests for Opus</name>
  <files>reticulum/src/test/java/com/lxmf/messenger/reticulum/audio/codec/OpusTest.kt</files>
  <action>
Create OpusTest.kt with tests verifying wire compatibility:

**Test all profiles instantiate:**
```kotlin
@Test
fun `all nine profiles instantiate successfully`() {
    val profiles = listOf(
        Opus.PROFILE_VOICE_LOW, Opus.PROFILE_VOICE_MEDIUM, Opus.PROFILE_VOICE_HIGH,
        Opus.PROFILE_VOICE_MAX, Opus.PROFILE_AUDIO_MIN, Opus.PROFILE_AUDIO_LOW,
        Opus.PROFILE_AUDIO_MEDIUM, Opus.PROFILE_AUDIO_HIGH, Opus.PROFILE_AUDIO_MAX
    )

    profiles.forEach { profile ->
        val codec = Opus(profile)
        assertNotNull(codec)
        assertEquals(Opus.profileChannels(profile), codec.channels)
    }
}
```

**Test encode-decode round-trip:**
```kotlin
@Test
fun `opus encode-decode roundtrip preserves audio`() {
    val codec = Opus(Opus.PROFILE_VOICE_LOW)

    // Generate 20ms of test audio at 8kHz (VOICE_LOW samplerate)
    val input = FloatArray(160) { sin(2.0 * PI * 440.0 * it / 8000.0).toFloat() }

    val encoded = codec.encode(input)
    val decoded = codec.decode(encoded)

    // Lossy codec, so check correlation instead of exact match
    val correlation = correlate(input, decoded)
    assertTrue(correlation > 0.9f, "Round-trip correlation too low: $correlation")
}
```

**Test bitrate ceiling:**
```kotlin
@Test
fun `encoded frame respects bitrate ceiling`() {
    val codec = Opus(Opus.PROFILE_VOICE_LOW)
    val input = FloatArray(160) { 0.5f }  // 20ms at 8kHz

    val encoded = codec.encode(input)
    val frameDurationMs = 20f
    val maxBytes = Opus.maxBytesPerFrame(Opus.profileBitrateCeiling(Opus.PROFILE_VOICE_LOW), frameDurationMs)

    assertTrue(encoded.size <= maxBytes, "Encoded size ${encoded.size} exceeds max $maxBytes")
}
```

**Test wire format (header byte if applicable):**
If Opus packets need a header byte (like Codec2), verify it here. Otherwise, verify raw Opus packets.

Run with: `JAVA_HOME=/home/tyler/android-studio/jbr ./gradlew :reticulum:testDebugUnitTest --tests OpusTest`
  </action>
  <verify>`./gradlew :reticulum:testDebugUnitTest --tests OpusTest` passes all tests</verify>
  <done>OpusTest.kt exists with passing tests for all profiles, round-trip, and bitrate compliance.</done>
</task>

</tasks>

<verification>
1. Opus.kt compiles without errors
2. All 9 profiles work correctly
3. Encode produces packets within bitrate ceiling
4. Decode reverses encode (lossy, but high correlation)
5. Unit tests pass
6. No crashes or JNI errors when encoding/decoding
</verification>

<success_criteria>
- Opus encoder produces wire-compatible output (bit-identical to Python pyogg for same input and settings)
- All 9 profiles (VOICE_LOW through AUDIO_MAX) encode successfully
- Encoded packets respect bitrate ceilings
- Encoder/decoder round-trip preserves audio fidelity (>90% correlation)
- Native .so libraries bundled in APK
</success_criteria>

<output>
After completion, create `.planning/phases/07-codec-foundation/07-02-SUMMARY.md`
</output>
