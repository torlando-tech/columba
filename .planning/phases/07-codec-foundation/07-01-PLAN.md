---
phase: 07-codec-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - reticulum/src/main/java/com/lxmf/messenger/reticulum/audio/codec/Codec.kt
  - reticulum/src/test/java/com/lxmf/messenger/reticulum/audio/codec/CodecTest.kt
autonomous: true

must_haves:
  truths:
    - "Null codec passes audio through without modification"
    - "Resample utilities convert between sample rates correctly"
    - "Codec base class provides framework for encode/decode"
  artifacts:
    - path: "reticulum/src/main/java/com/lxmf/messenger/reticulum/audio/codec/Codec.kt"
      provides: "Base Codec interface, Null codec, resample utilities"
      min_lines: 80
    - path: "reticulum/src/test/java/com/lxmf/messenger/reticulum/audio/codec/CodecTest.kt"
      provides: "Unit tests for Null codec and resample"
      min_lines: 40
  key_links:
    - from: "Null.encode()"
      to: "input frame"
      via: "passthrough (no modification)"
      pattern: "return frame"
    - from: "resample()"
      to: "Android AudioTrack resampler or manual SRC"
      via: "sample rate conversion"
      pattern: "AudioTrack|resample"
---

<objective>
Implement base Codec infrastructure in Kotlin with Null passthrough codec and audio resampling utilities.

Purpose: Provide foundation for Opus and Codec2 codecs, establishing the encode/decode interface and sample rate conversion tools.

Output: Working Codec.kt with base class, Null codec, and resample functions, plus unit tests verifying passthrough and resampling accuracy.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/07-codec-foundation/07-CONTEXT.md
@.planning/REQUIREMENTS.md

# Python reference implementation
@app/build/python/pip/noSentryDebug/common/LXST/Codecs/Codec.py
</context>

<tasks>

<task type="auto">
  <name>Create Codec.kt base infrastructure</name>
  <files>reticulum/src/main/java/com/lxmf/messenger/reticulum/audio/codec/Codec.kt</files>
  <action>
Create Codec.kt matching Python LXST structure:

**Abstract base class Codec:**
```kotlin
abstract class Codec {
    var preferredSamplerate: Int? = null
    var frameQuantaMs: Float? = null
    var frameMaxMs: Float? = null
    var validFrameMs: List<Float>? = null
    // Note: source/sink omitted for now (Phase 8 will add)

    abstract fun encode(frame: FloatArray): ByteArray
    abstract fun decode(frameBytes: ByteArray): FloatArray
}
```

**Exception class:**
```kotlin
class CodecError(message: String) : Exception(message)
```

**Null codec (passthrough):**
```kotlin
class Null : Codec() {
    override fun encode(frame: FloatArray): ByteArray {
        // Convert float32 (-1.0 to 1.0) to int16 bytes
        val buffer = ByteBuffer.allocate(frame.size * 2).order(ByteOrder.LITTLE_ENDIAN)
        frame.forEach { sample ->
            val int16 = (sample * 32767f).toInt().coerceIn(-32768, 32767).toShort()
            buffer.putShort(int16)
        }
        return buffer.array()
    }

    override fun decode(frameBytes: ByteArray): FloatArray {
        // Convert int16 bytes to float32
        val buffer = ByteBuffer.wrap(frameBytes).order(ByteOrder.LITTLE_ENDIAN)
        return FloatArray(frameBytes.size / 2) { buffer.short / 32768f }
    }
}
```

**Resampling utilities:**
Use Android's built-in AudioTrack/AudioRecord resampling or implement simple linear interpolation. Priority is correctness over efficiency.

```kotlin
// Resample float samples (main API)
fun resample(
    inputSamples: FloatArray,
    bitdepth: Int,
    channels: Int,
    inputRate: Int,
    outputRate: Int
): FloatArray {
    if (inputRate == outputRate) return inputSamples

    // Convert to bytes, resample, convert back
    val bytes = samplesToBytes(inputSamples, bitdepth)
    val resampledBytes = resampleBytes(bytes, bitdepth, channels, inputRate, outputRate)
    return bytesToSamples(resampledBytes, bitdepth)
}

// Resample byte array (int16 PCM)
fun resampleBytes(
    sampleBytes: ByteArray,
    bitdepth: Int,
    channels: Int,
    inputRate: Int,
    outputRate: Int
): ByteArray {
    // Use linear interpolation or Android AudioTrack resampler
    // Return resampled bytes in same format (little-endian int16)
}
```

Place in package `com.lxmf.messenger.reticulum.audio.codec`.
  </action>
  <verify>
1. `./gradlew :reticulum:compileDebugKotlin` succeeds
2. Null codec round-trip: `encode(decode(bytes)) == bytes` (within float precision)
3. Resample 48kHz→8kHz produces correct output length
  </verify>
  <done>
Codec.kt exists with abstract base, Null codec, and resample utilities. Compilation succeeds. Null codec passthrough works correctly.
  </done>
</task>

<task type="auto">
  <name>Create unit tests for Codec base classes</name>
  <files>reticulum/src/test/java/com/lxmf/messenger/reticulum/audio/codec/CodecTest.kt</files>
  <action>
Create CodecTest.kt with JUnit tests:

**Test Null codec passthrough:**
```kotlin
@Test
fun `null codec encode-decode roundtrip preserves data`() {
    val codec = Null()
    val input = floatArrayOf(-1f, -0.5f, 0f, 0.5f, 1f)
    val encoded = codec.encode(input)
    val decoded = codec.decode(encoded)

    // Should match within float32 precision
    assertArrayEquals(input, decoded, 0.0001f)
}
```

**Test resampling:**
```kotlin
@Test
fun `resample 48kHz to 8kHz reduces sample count by 6x`() {
    val input48k = FloatArray(960) { (it / 960f) * 2f - 1f } // 20ms at 48kHz
    val resampled8k = resample(input48k, 16, 1, 48000, 8000)

    assertEquals(160, resampled8k.size) // 20ms at 8kHz
}

@Test
fun `resample preserves DC offset`() {
    val input = FloatArray(480) { 0.5f } // DC offset at 0.5
    val resampled = resample(input, 16, 1, 48000, 8000)

    // Average should still be ~0.5
    val avg = resampled.average().toFloat()
    assertEquals(0.5f, avg, 0.05f)
}
```

Run tests with: `JAVA_HOME=/home/tyler/android-studio/jbr ./gradlew :reticulum:testDebugUnitTest --tests CodecTest`
  </action>
  <verify>`./gradlew :reticulum:testDebugUnitTest --tests CodecTest` passes all tests</verify>
  <done>CodecTest.kt exists with passing tests for Null codec and resample utilities.</done>
</task>

</tasks>

<verification>
1. Codec.kt compiles without errors
2. Null codec round-trip test passes (encode→decode preserves data)
3. Resample tests pass (correct output length, preserves signal characteristics)
4. No runtime exceptions when instantiating Null()
</verification>

<success_criteria>
- Codec base class provides abstract encode/decode interface
- Null codec successfully passes audio through without corruption
- Resample utilities correctly convert between sample rates
- Unit tests verify correctness
- Code follows Kotlin conventions and matches existing KotlinAudioBridge style
</success_criteria>

<output>
After completion, create `.planning/phases/07-codec-foundation/07-01-SUMMARY.md`
</output>
