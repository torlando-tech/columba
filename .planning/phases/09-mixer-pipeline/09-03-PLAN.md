---
phase: 09-mixer-pipeline
plan: 03
type: execute
wave: 2
depends_on: ["09-01", "09-02"]
files_modified:
  - reticulum/src/main/java/com/lxmf/messenger/reticulum/audio/lxst/Pipeline.kt
autonomous: true

must_haves:
  truths:
    - "Pipeline wires source.sink = sink for frame flow"
    - "Pipeline.start() delegates to source.start()"
    - "Pipeline.stop() delegates to source.stop()"
    - "Pipeline.running reflects source running state"
  artifacts:
    - path: "reticulum/src/main/java/com/lxmf/messenger/reticulum/audio/lxst/Pipeline.kt"
      provides: "Component orchestration wrapper"
      min_lines: 50
      contains: "class Pipeline"
  key_links:
    - from: "Pipeline.kt"
      to: "Source.kt"
      via: "holds source reference"
      pattern: "val source: Source"
    - from: "Pipeline.kt"
      to: "Sink.kt"
      via: "wires source to sink"
      pattern: "source.*sink"
---

<objective>
Implement Pipeline class that orchestrates source -> codec -> sink flow.

Purpose: Pipeline is the glue that wires audio components together. It provides unified start/stop lifecycle and component wiring. Must match Python LXST Pipeline.py exactly.

Output: Pipeline.kt that wires source.sink = sink, delegates start/stop to source, and exposes running state.
</objective>

<execution_context>
@/home/tyler/.claude/get-shit-done/workflows/execute-plan.md
@/home/tyler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/09-mixer-pipeline/09-RESEARCH.md

# Dependencies from Wave 1
@reticulum/src/main/java/com/lxmf/messenger/reticulum/audio/lxst/Mixer.kt
@reticulum/src/main/java/com/lxmf/messenger/reticulum/audio/lxst/ToneSource.kt
@reticulum/src/main/java/com/lxmf/messenger/reticulum/audio/lxst/Source.kt
@reticulum/src/main/java/com/lxmf/messenger/reticulum/audio/lxst/Sink.kt
@reticulum/src/main/java/com/lxmf/messenger/reticulum/audio/lxst/LineSource.kt
@reticulum/src/main/java/com/lxmf/messenger/reticulum/audio/lxst/LineSink.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Pipeline class for component orchestration</name>
  <files>reticulum/src/main/java/com/lxmf/messenger/reticulum/audio/lxst/Pipeline.kt</files>
  <action>
Create Pipeline.kt in the lxst package matching Python LXST Pipeline.py (lines 10-58):

**Class declaration:**
```kotlin
/**
 * Pipeline - Orchestrates audio component wiring and lifecycle.
 *
 * Matches Python LXST Pipeline.py structure. Pipeline is a thin wrapper
 * that wires source -> sink and provides unified start/stop.
 *
 * Pipeline delegates all work to source - it's pure coordination, no processing.
 *
 * @param source Audio source (LineSource, ToneSource, or Mixer)
 * @param codec Codec for encoding (optional, set on source if source supports it)
 * @param sink Audio sink (LineSink or Mixer)
 */
class Pipeline(
    val source: Source,
    codec: Codec,
    val sink: Sink
)
```

**Note on codec:** Python Pipeline.py sets codec on source (line 42-44). Our sources (LineSource, ToneSource, Mixer) have codec properties. Need to wire this.

**Properties:**
- `private var _codec: Codec? = null`

**init block (Python lines 20-31):**
Wire components in constructor:
```kotlin
init {
    // Wire source to sink (source pushes frames to sink)
    wireSourceToSink(source, sink)

    // Set codec (triggers codec setter)
    this.codec = codec
}
```

**wireSourceToSink helper (private):**
Different source types have different sink properties:
```kotlin
private fun wireSourceToSink(source: Source, sink: Sink) {
    when (source) {
        is LineSource -> source.sink = sink
        is Mixer -> source.sink = sink
        is ToneSource -> source.sink = sink
        else -> {
            // Try reflection or log warning for unknown source types
            Log.w(TAG, "Unknown source type: ${source::class.simpleName}, cannot wire sink")
        }
    }
}
```

**codec property (Python lines 33-44):**
```kotlin
var codec: Codec
    get() = _codec ?: throw IllegalStateException("Codec not set")
    set(value) {
        if (_codec != value) {
            _codec = value
            // Set codec on source if source supports it
            wireCodecToSource(source, value)
        }
    }

private fun wireCodecToSource(source: Source, codec: Codec) {
    when (source) {
        is LineSource -> {
            // LineSource codec is immutable (set in constructor)
            // No runtime codec change supported - this is by design
            // Python behavior: LineSource.codec is set at creation time
        }
        is ToneSource -> source.codec = codec
        is Mixer -> source.codec = codec
        else -> Log.w(TAG, "Unknown source type, cannot set codec")
    }
}
```

**Note:** LineSource.codec is `private val` (immutable, set in constructor). This matches Python behavior - LineSource.codec is set at creation. Pipeline.codec setter only affects sources that support runtime codec changes (ToneSource, Mixer). No modification to LineSource.kt needed.

**running property (Python lines 46-48):**
```kotlin
val running: Boolean
    get() = source.isRunning()
```

**start() (Python lines 50-52):**
```kotlin
fun start() {
    if (!running) {
        source.start()
    }
}
```

**stop() (Python lines 54-58):**
```kotlin
fun stop() {
    if (running) {
        source.stop()
    }
}
```

**Companion object:**
```kotlin
companion object {
    private const val TAG = "Columba:Pipeline"
}
```

**Full class should be ~60-80 lines** - Pipeline is intentionally thin.
  </action>
  <verify>
Build compiles: `cd /home/tyler/repos/public/columba && ./gradlew :reticulum:compileDebugKotlin 2>&1 | tail -20`
File exists: `grep -c "class Pipeline" reticulum/src/main/java/com/lxmf/messenger/reticulum/audio/lxst/Pipeline.kt`
Has start/stop: `grep -E "fun (start|stop)" reticulum/src/main/java/com/lxmf/messenger/reticulum/audio/lxst/Pipeline.kt`
Has running property: `grep "val running" reticulum/src/main/java/com/lxmf/messenger/reticulum/audio/lxst/Pipeline.kt`
LineSource unchanged: `git diff --name-only reticulum/src/main/java/com/lxmf/messenger/reticulum/audio/lxst/LineSource.kt | wc -l` should be 0
  </verify>
  <done>
Pipeline.kt exists with:
- Constructor wires source.sink = sink
- codec property wired to source (where supported)
- LineSource codec handled gracefully (immutable by design, no modification needed)
- start() delegates to source.start()
- stop() delegates to source.stop()
- running reflects source.isRunning()
- Build compiles successfully
  </done>
</task>

</tasks>

<verification>
1. Pipeline.kt file exists with ~60-80 lines
2. Constructor wires source.sink = sink
3. start() calls source.start()
4. stop() calls source.stop()
5. running returns source.isRunning()
6. LineSource.kt is UNCHANGED (codec immutable by design)
7. Build compiles: `./gradlew :reticulum:compileDebugKotlin`
</verification>

<success_criteria>
- PIPE-01: Pipeline correctly wires source->codec->sink
- Pipeline is thin wrapper (no audio processing)
- start/stop delegates to source
- No modifications to Phase 8 code (LineSource.kt unchanged)
- Build compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/09-mixer-pipeline/09-03-SUMMARY.md`
</output>
