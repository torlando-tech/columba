---
phase: 05-memory-optimization
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - python/reticulum_wrapper.py
  - python/memory_profiler.py
  - app/src/main/java/com/lxmf/messenger/service/manager/PythonWrapperManager.kt
autonomous: false

must_haves:
  truths:
    - "Memory growth rate reduced from ~1.4 MB/min to < 0.1 MB/min"
    - "No PyObject reference leaks in Kotlin code"
    - "Profiling identifies specific allocation sites responsible for growth"
    - "Fixes do not break existing functionality (tests pass)"
  artifacts:
    - path: "python/reticulum_wrapper.py"
      provides: "Memory leak fixes in Python code"
      contains: "# Memory optimization"
    - path: "app/src/main/java/com/lxmf/messenger/service/manager/PythonWrapperManager.kt"
      provides: "PyObject lifecycle fixes"
      contains: ".close()"
  key_links:
    - from: "python/memory_profiler.py"
      to: "python/reticulum_wrapper.py"
      via: "Profiling identifies leak sites"
      pattern: "take_snapshot"
---

<objective>
Identify and fix memory leaks using profiling data from Plan 01.

Purpose: Reduce memory growth rate from ~1.4 MB/min to near-zero (< 0.1 MB/min) so the app survives 5+ days without OOM.

Output: Specific leak fixes in Python and/or Kotlin code, verified by profiling showing reduced growth rate.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-memory-optimization/05-CONTEXT.md
@.planning/phases/05-memory-optimization/05-RESEARCH.md
@.planning/phases/05-memory-optimization/05-01-SUMMARY.md

# Key source files
@python/reticulum_wrapper.py
@python/memory_profiler.py
@app/src/main/java/com/lxmf/messenger/service/manager/PythonWrapperManager.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Profile and identify leak sources</name>
  <files>python/memory_profiler.py</files>
  <action>
Run the profiling infrastructure from Plan 01 for an extended session to identify leak sources:

1. Install debug build on physical device: `./gradlew installSentryDebug`
2. Run app for 30+ minutes with typical usage (send messages, view contacts, etc.)
3. Collect profiling output: `adb logcat -s MemoryProfilerManager:I > memory_profile.log`

4. Analyze profiling output to identify:
   - Which Python files/lines show consistent growth
   - Whether native heap grows independently of Python heap (indicates Chaquopy/JNI leak)
   - Top 5 allocation sites by cumulative growth

5. Document findings in `python/memory_profiler.py` comments:
   ```python
   # Profiling Results (YYYY-MM-DD):
   # - reticulum_wrapper.py:XXX - +Y.Y MiB (description)
   # - RNS/XXX.py:XXX - +Y.Y MiB (description)
   # Root cause: (summary)
   ```

IMPORTANT per CONTEXT.md: "Triple-check before concluding Reticulum itself has a memory leak" - if leak appears to be in RNS/LXMF code, verify with upstream Reticulum (not Columba fork) first.

If no clear Python leak but native heap grows: Focus on Task 2 (PyObject lifecycle audit).
  </action>
  <verify>
1. memory_profile.log exists with 30+ minutes of data
2. Top allocation sites are documented in memory_profiler.py comments
3. Root cause hypothesis is documented
  </verify>
  <done>
Leak sources identified via profiling, documented with specific file:line locations and growth rates.
  </done>
</task>

<task type="auto">
  <name>Task 2: Audit and fix PyObject lifecycle in Kotlin</name>
  <files>app/src/main/java/com/lxmf/messenger/service/manager/PythonWrapperManager.kt</files>
  <action>
Per RESEARCH.md Pitfall 3, audit all Kotlin code for PyObject reference leaks:

1. Search for all PyObject usage: `grep -r "PyObject" app/src/main/java/`
2. For each PyObject returned from Python:
   - Check if `.close()` is called (or try-with-resources pattern)
   - If not, add proper cleanup

3. In PythonWrapperManager.kt, review all `withWrapper { }` blocks:
   - Any PyObject stored beyond the block scope? (leak)
   - Any PyObject returned to callers without lifecycle management? (leak)

4. Fix patterns:
   ```kotlin
   // BEFORE (potential leak):
   fun getDebugInfo(): PyObject? = withWrapper { wrapper ->
       wrapper.callAttr("get_debug_info")
   }

   // AFTER (safe - convert to Kotlin type immediately):
   fun getDebugInfo(): Map<String, Any>? = withWrapper { wrapper ->
       val pyResult = wrapper.callAttr("get_debug_info")
       try {
           pyResult?.asMap()?.mapKeys { it.key.toString() }
               ?.mapValues { convertPyObjectToKotlin(it.value) }
       } finally {
           pyResult?.close()
       }
   }
   ```

5. Add explicit `.close()` calls where PyObjects are created but not immediately converted.

IMPORTANT: The `generateStampForPython()` method creates and returns PyObjects to Python - verify this doesn't cause reference leaks on the Kotlin side.
  </action>
  <verify>
1. `grep -r "PyObject" app/src/main/java/` shows all usages have lifecycle management
2. No PyObject stored in class fields without explicit cleanup in onDestroy/shutdown
3. Unit tests pass: `./gradlew testSentryDebugUnitTest`
  </verify>
  <done>
All PyObject references in Kotlin have proper lifecycle management (.close() or immediate conversion to Kotlin types).
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Memory profiling with identified leak sources and PyObject lifecycle fixes</what-built>
  <how-to-verify>
1. Install updated debug build: `./gradlew installSentryDebug`
2. Run app for 30+ minutes with typical usage
3. Check logcat: `adb logcat -s MemoryProfilerManager:I`
4. Compare memory growth rate:
   - Before: ~1.4 MB/min (~42 MB in 30 min)
   - Target: < 0.1 MB/min (< 3 MB in 30 min)

Expected output in logcat:
```
MemoryProfilerManager: Memory: JVM=XXmb/512MB, Native=XXmb
MemoryProfilerManager: Python growth: +X.X MiB (should be small)
```

If growth rate is still high, describe what you observe.
  </how-to-verify>
  <resume-signal>Type "approved" if growth rate is acceptable, or describe remaining issues</resume-signal>
</task>

</tasks>

<verification>
After all tasks complete:
1. Profiling identifies specific leak sources (documented)
2. PyObject lifecycle fixes applied
3. Memory growth rate verified via 30+ minute profiling session
4. All existing tests pass: `./gradlew testSentryDebugUnitTest`
</verification>

<success_criteria>
- Leak sources identified and documented in memory_profiler.py
- PyObject lifecycle properly managed in all Kotlin code
- Memory growth rate reduced to < 0.1 MB/min (verified by profiling)
- No regression in functionality (tests pass)
</success_criteria>

<output>
After completion, create `.planning/phases/05-memory-optimization/05-02-SUMMARY.md`
</output>
