---
phase: 10-network-bridge
plan: 03
type: execute
wave: 2
depends_on: ["10-01"]
files_modified:
  - reticulum/src/main/java/com/lxmf/messenger/reticulum/audio/lxst/LinkSource.kt
autonomous: true

must_haves:
  truths:
    - "LinkSource extends RemoteSource and receives encoded frames from Python"
    - "LinkSource parses codec header byte to select decoder"
    - "LinkSource decodes frames and pushes to downstream sink"
    - "Packet queue with max 8 entries for thread-safe handoff"
    - "Dynamic codec switching supported (remote can change codec mid-call)"
  artifacts:
    - path: "reticulum/src/main/java/com/lxmf/messenger/reticulum/audio/lxst/LinkSource.kt"
      provides: "RemoteSource that receives encoded frames from Python Reticulum"
      min_lines: 100
      exports: ["LinkSource"]
  key_links:
    - from: "LinkSource.onPacketReceived"
      to: "packetQueue.addLast"
      via: "thread-safe queue"
      pattern: "packetQueue.*add"
    - from: "LinkSource.processPacket"
      to: "codec.decode"
      via: "codec decode call"
      pattern: "codec.*decode"
    - from: "LinkSource.processPacket"
      to: "sink.handleFrame"
      via: "push to downstream"
      pattern: "sink.*handleFrame"
---

<objective>
Create LinkSource - a RemoteSource that receives encoded frames from Python Reticulum, decodes them, and pushes to Mixer/Sink.

Purpose: Python-to-Kotlin audio reception path. Matches Python LXST Network.py LinkSource (lines 98-145).
Output: LinkSource.kt that processes incoming packets via NetworkPacketBridge callback.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-network-bridge/10-RESEARCH.md

# Phase 10 dependencies
@.planning/phases/10-network-bridge/10-01-SUMMARY.md

# Existing LXST classes
@reticulum/src/main/java/com/lxmf/messenger/reticulum/audio/lxst/Source.kt
@reticulum/src/main/java/com/lxmf/messenger/reticulum/audio/lxst/Sink.kt
@reticulum/src/main/java/com/lxmf/messenger/reticulum/audio/codec/Codec.kt

# Python reference
@app/build/python/pip/noSentryDebug/common/LXST/Network.py
@app/build/python/pip/noSentryDebug/common/LXST/Codecs/__init__.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create LinkSource class</name>
  <files>reticulum/src/main/java/com/lxmf/messenger/reticulum/audio/lxst/LinkSource.kt</files>
  <action>
Create LinkSource extending RemoteSource, matching Python LXST Network.py LinkSource:

1. Package: `com.lxmf.messenger.reticulum.audio.lxst`

2. Imports:
   - `com.lxmf.messenger.reticulum.audio.bridge.NetworkPacketBridge`
   - `com.lxmf.messenger.reticulum.audio.codec.*`
   - `kotlinx.coroutines.*`
   - `java.util.concurrent.atomic.AtomicBoolean`

3. Companion object with constants:
   ```kotlin
   companion object {
       const val MAX_PACKETS = 8  // Match Mixer backpressure from context

       // Codec header bytes (must match Packetizer and Python)
       const val CODEC_NULL: Byte = 0xFF.toByte()
       const val CODEC_RAW: Byte = 0x00
       const val CODEC_OPUS: Byte = 0x01
       const val CODEC_CODEC2: Byte = 0x02
   }
   ```

4. Constructor:
   ```kotlin
   class LinkSource(
       private val bridge: NetworkPacketBridge,
       var sink: Sink? = null
   ) : RemoteSource()
   ```

5. RemoteSource properties:
   ```kotlin
   override var sampleRate: Int = 48000
   override var channels: Int = 1
   ```

6. State:
   - `private val shouldRun = AtomicBoolean(false)`
   - `private var codec: Codec = Null()` (default, switches dynamically)
   - `private val packetQueue = ArrayDeque<ByteArray>(MAX_PACKETS)`
   - `private val receiveLock = Any()` (thread safety for queue)
   - `private val scope = CoroutineScope(Dispatchers.IO + SupervisorJob())`

7. Callback registration (called during init):
   ```kotlin
   init {
       bridge.setPacketCallback { packetData ->
           onPacketReceived(packetData)
       }
   }
   ```

8. onPacketReceived (called by Python via bridge - must be FAST):
   ```kotlin
   /**
    * Called by Python via NetworkPacketBridge when packet arrives.
    * Must be fast - Python GIL is held during this call.
    * Just queue the packet for processing.
    */
   fun onPacketReceived(packetData: ByteArray) {
       if (!shouldRun.get()) return

       synchronized(receiveLock) {
           // Drop oldest if full (backpressure)
           if (packetQueue.size >= MAX_PACKETS) {
               packetQueue.removeFirst()
           }
           packetQueue.addLast(packetData)
       }
   }
   ```

9. processPacket (called by processing coroutine):
   ```kotlin
   private fun processPacket(data: ByteArray) {
       if (data.isEmpty()) return
       val currentSink = sink ?: return

       // Parse codec header byte (first byte)
       val codecType = data[0]
       val frameData = data.copyOfRange(1, data.size)

       // Switch codec if needed (match Python LXST dynamic switching)
       val newCodec = getCodecForHeader(codecType)
       if (newCodec::class != codec::class) {
           codec = newCodec
       }

       // Decode frame
       val decodedFrame = codec.decode(frameData)

       // Push to sink (Mixer)
       currentSink.handleFrame(decodedFrame, this)
   }

   private fun getCodecForHeader(header: Byte): Codec {
       return when (header) {
           CODEC_NULL -> Null()
           CODEC_OPUS -> Opus()
           CODEC_CODEC2 -> Codec2()
           else -> Null()  // Fall back to Null for unknown
       }
   }
   ```

10. Processing coroutine:
    ```kotlin
    private suspend fun processingLoop() {
        while (shouldRun.get()) {
            val packet: ByteArray?
            synchronized(receiveLock) {
                packet = packetQueue.removeFirstOrNull()
            }
            if (packet != null) {
                processPacket(packet)
            } else {
                delay(2)  // Brief sleep when queue empty
            }
        }
    }
    ```

11. Lifecycle methods:
    ```kotlin
    override fun start() {
        if (shouldRun.getAndSet(true)) return
        scope.launch { processingLoop() }
    }

    override fun stop() {
        shouldRun.set(false)
        synchronized(receiveLock) {
            packetQueue.clear()
        }
    }

    override fun isRunning(): Boolean = shouldRun.get()
    ```

Note: Opus() and Codec2() constructors may need default parameters. Check Phase 7 codec implementations.
CRITICAL: No Log.d() in onPacketReceived or processPacket - these are hot paths.
  </action>
  <verify>
Build succeeds: `cd /home/tyler/repos/public/columba && JAVA_HOME=/home/tyler/android-studio/jbr ./gradlew :reticulum:compileDebugKotlin 2>&1 | tail -20`
File structure: `grep -E "class LinkSource|fun onPacketReceived|fun processPacket|getCodecForHeader" reticulum/src/main/java/com/lxmf/messenger/reticulum/audio/lxst/LinkSource.kt`
  </verify>
  <done>
LinkSource.kt compiles and contains:
- Extends RemoteSource
- Codec header byte constants matching Packetizer and Python
- onPacketReceived queues packet (non-blocking)
- processPacket parses header, switches codec, decodes, pushes to sink
- MAX_PACKETS=8 queue with backpressure (drop oldest)
- processingLoop coroutine for async processing
  </done>
</task>

</tasks>

<verification>
1. Build passes: `./gradlew :reticulum:compileDebugKotlin`
2. LinkSource.kt extends RemoteSource
3. Queue-based packet handling with MAX_PACKETS=8
4. Dynamic codec switching based on header byte
5. No synchronous logging in hot path methods
</verification>

<success_criteria>
- LinkSource extends RemoteSource and compiles
- onPacketReceived queues packets thread-safely
- processPacket parses codec header and decodes
- Dynamic codec switching supported
- Decoded frames pushed to sink
</success_criteria>

<output>
After completion, create `.planning/phases/10-network-bridge/10-03-SUMMARY.md`
</output>
