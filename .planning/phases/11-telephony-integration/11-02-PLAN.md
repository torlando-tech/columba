---
phase: 11-telephony-integration
plan: 02
type: execute
wave: 2
depends_on: ["11-01"]
files_modified:
  - reticulum/src/main/java/com/lxmf/messenger/reticulum/call/telephone/PythonNetworkTransport.kt
  - reticulum/src/main/java/com/lxmf/messenger/reticulum/call/telephone/Telephone.kt
autonomous: true

must_haves:
  truths:
    - "Telephone can initiate outgoing calls"
    - "Telephone can answer incoming calls"
    - "Telephone can hang up active calls"
    - "State machine mirrors Python LXST exactly"
    - "Mute controls work and persist across profile switches"
  artifacts:
    - path: "reticulum/src/main/java/com/lxmf/messenger/reticulum/call/telephone/PythonNetworkTransport.kt"
      provides: "NetworkTransport implementation wrapping Python bridge"
      exports: ["PythonNetworkTransport"]
    - path: "reticulum/src/main/java/com/lxmf/messenger/reticulum/call/telephone/Telephone.kt"
      provides: "Main call lifecycle controller"
      exports: ["Telephone"]
  key_links:
    - from: "Telephone.kt"
      to: "NetworkTransport"
      via: "Constructor injection"
      pattern: "class Telephone.*networkTransport: NetworkTransport"
    - from: "Telephone.kt"
      to: "Mixer.mute()"
      via: "transmitMixer?.mute()"
      pattern: "transmitMixer\\??\\.mute"
    - from: "PythonNetworkTransport.kt"
      to: "NetworkPacketBridge"
      via: "Bridge delegation"
      pattern: "bridge\\.send"
---

<objective>
Create PythonNetworkTransport and Telephone class core with call lifecycle management.

Purpose: Telephone is the main call controller owning state machine and coordinating audio pipelines. PythonNetworkTransport wraps NetworkPacketBridge for Python communication.

Output:
- PythonNetworkTransport.kt implementing NetworkTransport interface
- Telephone.kt with call(), answer(), hangup(), switchProfile(), mute controls
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-telephony-integration/11-RESEARCH.md
@.planning/phases/11-telephony-integration/11-CONTEXT.md

# Prior plan
@.planning/phases/11-telephony-integration/11-01-SUMMARY.md

# Reference files
@reticulum/src/main/java/com/lxmf/messenger/reticulum/audio/bridge/NetworkPacketBridge.kt
@reticulum/src/main/java/com/lxmf/messenger/reticulum/audio/lxst/SignallingReceiver.kt
@reticulum/src/main/java/com/lxmf/messenger/reticulum/audio/lxst/Mixer.kt
@reticulum/src/main/java/com/lxmf/messenger/reticulum/call/bridge/CallBridge.kt
@python/lxst_modules/call_manager.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create PythonNetworkTransport</name>
  <files>reticulum/src/main/java/com/lxmf/messenger/reticulum/call/telephone/PythonNetworkTransport.kt</files>
  <action>
Create `reticulum/src/main/java/com/lxmf/messenger/reticulum/call/telephone/PythonNetworkTransport.kt`.

Implement NetworkTransport interface, wrapping existing NetworkPacketBridge and call_manager.py:

```kotlin
class PythonNetworkTransport(
    private val bridge: NetworkPacketBridge,
    private val callManager: PyObject
) : NetworkTransport {
    // Implementation delegates to bridge for packets/signals
    // Uses callManager for link establishment/teardown
}
```

Key implementation details:
1. `establishLink()`: Call callManager.callAttr("call", destinationHashHex) - returns true if call initiated successfully. Use withContext(Dispatchers.IO) for Python calls.
2. `teardownLink()`: Call callManager.callAttr("hangup")
3. `sendPacket()`: Delegate to bridge.sendPacket()
4. `sendSignal()`: Delegate to bridge.sendSignal()
5. `setPacketCallback()`: Delegate to bridge.setPacketCallback()
6. `setSignalCallback()`: Delegate to bridge.setSignalCallback()
7. `isLinkActive`: Track state based on establishLink/teardownLink calls

Note: PyObject comes from Chaquopy (com.chaquo.python.PyObject). This is the ONLY place PyObject appears in telephony code (CONTEXT.md decision).

Add companion with TAG for logging.
  </action>
  <verify>
File compiles:
```bash
cd /home/tyler/repos/public/columba && JAVA_HOME=/home/tyler/android-studio/jbr ./gradlew :reticulum:compileDebugKotlin 2>&1 | head -50
```
  </verify>
  <done>
PythonNetworkTransport.kt implements NetworkTransport interface, wrapping NetworkPacketBridge and call_manager.py PyObject.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Telephone class core</name>
  <files>reticulum/src/main/java/com/lxmf/messenger/reticulum/call/telephone/Telephone.kt</files>
  <action>
Create `reticulum/src/main/java/com/lxmf/messenger/reticulum/call/telephone/Telephone.kt`.

Structure matching Python LXST Telephony.py (lines 114-732):

```kotlin
class Telephone(
    private val networkTransport: NetworkTransport,
    private val audioBridge: KotlinAudioBridge,
    private val callBridge: CallBridge,
    private val ringTime: Long = RING_TIME_MS,
    private val waitTime: Long = WAIT_TIME_MS
) {
    companion object {
        private const val TAG = "Columba:Telephone"
        const val RING_TIME_MS = 60_000L
        const val WAIT_TIME_MS = 70_000L
        const val CONNECT_TIME_MS = 5_000L
    }

    // State (matching Python Telephony.py lines 159-180)
    private var callStatus = Signalling.STATUS_AVAILABLE
    private var activeProfile: Profile = Profile.DEFAULT
    private var transmitMuted = false
    private var receiveMuted = false
    private var isIncomingCall = false

    // Audio pipeline components (null when no call)
    private var receiveMixer: Mixer? = null
    private var transmitMixer: Mixer? = null
    private var audioInput: LineSource? = null
    private var audioOutput: LineSink? = null
    private var linkSource: LinkSource? = null
    private var packetizer: Packetizer? = null

    // Coroutine scope for async operations
    private val scope = CoroutineScope(Dispatchers.Default + SupervisorJob())
}
```

**Public API methods:**

1. `suspend fun call(destinationHash: ByteArray, profile: Profile = Profile.DEFAULT)`:
   - Check not already in call
   - Set callStatus = CALLING
   - Call networkTransport.establishLink()
   - Start timeout coroutine (waitTime)
   - Update CallBridge state

2. `fun answer()`:
   - Check active incoming call exists
   - Call openPipelines()
   - Call startPipelines()
   - Signal STATUS_ESTABLISHED

3. `fun hangup(reason: Int? = null)`:
   - Signal rejection if incoming and unanswered
   - Call networkTransport.teardownLink()
   - Call stopPipelines()
   - Clear all pipeline references
   - Reset state to STATUS_AVAILABLE
   - Notify CallBridge

4. `fun switchProfile(profile: Profile)`:
   - Skip if same profile or not ESTABLISHED
   - Signal profile change to remote
   - Call reconfigureTransmitPipeline()
   - Restore mute state (CONTEXT.md: mute persists)

5. `fun muteTransmit(mute: Boolean = true)`:
   - Store transmitMuted state
   - Call transmitMixer?.mute(mute)

6. `fun muteReceive(mute: Boolean = true)`:
   - Store receiveMuted state
   - Call receiveMixer?.mute(mute)

**Private methods for pipeline management:**

- `prepareDiallingPipelines()`: Create receiveMixer, audioOutput, LineSink
- `openPipelines()`: Create full transmit/receive pipeline (LinkSource, Packetizer, LineSource)
- `startPipelines()`: Start all mixers and pipelines
- `stopPipelines()`: Stop all mixers and pipelines
- `reconfigureTransmitPipeline()`: Recreate transmit path with new profile codec

**Signal handling (wire up in init block):**

Register with networkTransport.setSignalCallback() to handle:
- STATUS_BUSY -> playBusyTone(), hangup
- STATUS_REJECTED -> playBusyTone(), hangup
- STATUS_AVAILABLE -> callStatus = signal
- STATUS_RINGING -> prepareDiallingPipelines(), activateDialTone()
- STATUS_CONNECTING -> resetDiallingPipelines(), openPipelines()
- STATUS_ESTABLISHED -> startPipelines(), disableDialTone(), notify CallBridge
- signal >= PREFERRED_PROFILE -> profile change handling

Match Python Telephony.py signalling_received() (lines 683-729) exactly.

**Important:** Do NOT import PyObject in this file. Use NetworkTransport interface only. All Python interaction goes through PythonNetworkTransport.
  </action>
  <verify>
File compiles:
```bash
cd /home/tyler/repos/public/columba && JAVA_HOME=/home/tyler/android-studio/jbr ./gradlew :reticulum:compileDebugKotlin 2>&1 | head -50
```
  </verify>
  <done>
Telephone.kt exists with:
- State machine matching Python LXST
- call(), answer(), hangup() working
- switchProfile() with mute persistence
- muteTransmit(), muteReceive() controls
- Signal handling wired up
  </done>
</task>

</tasks>

<verification>
Both files compile:
```bash
cd /home/tyler/repos/public/columba && JAVA_HOME=/home/tyler/android-studio/jbr ./gradlew :reticulum:compileDebugKotlin --info 2>&1 | grep -E "(BUILD|error|Telephone|PythonNetworkTransport)"
```

Verify no PyObject import in Telephone.kt:
```bash
grep -c "PyObject" /home/tyler/repos/public/columba/reticulum/src/main/java/com/lxmf/messenger/reticulum/call/telephone/Telephone.kt
# Should output 0
```
</verification>

<success_criteria>
1. PythonNetworkTransport implements NetworkTransport interface
2. Telephone class compiles with all public methods
3. Telephone does NOT import PyObject directly
4. State machine uses same constants as Python LXST (Signalling object)
5. muteTransmit stores state and calls Mixer.mute()
6. switchProfile restores mute state after pipeline reconfiguration
</success_criteria>

<output>
After completion, create `.planning/phases/11-telephony-integration/11-02-SUMMARY.md`
</output>
