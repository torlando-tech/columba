---
phase: 10-network-bridge
plan: 04
type: execute
wave: 2
depends_on: ["10-01"]
files_modified:
  - reticulum/src/main/java/com/lxmf/messenger/reticulum/audio/lxst/SignallingReceiver.kt
autonomous: true

must_haves:
  truths:
    - "SignallingReceiver sends signals to Python via NetworkPacketBridge"
    - "SignallingReceiver receives signals from Python via callback"
    - "Signalling constants match Python LXST Telephony.py exactly"
    - "Profile change signals (0xFF + profile) are parsed correctly"
    - "signal() method is fire-and-forget (non-blocking)"
  artifacts:
    - path: "reticulum/src/main/java/com/lxmf/messenger/reticulum/audio/lxst/SignallingReceiver.kt"
      provides: "Bidirectional signalling handler for call state and profile changes"
      min_lines: 60
      exports: ["SignallingReceiver", "Signalling"]
  key_links:
    - from: "SignallingReceiver.signal"
      to: "NetworkPacketBridge.sendSignal"
      via: "bridge sendSignal call"
      pattern: "bridge\\.sendSignal"
    - from: "SignallingReceiver.handleSignalling"
      to: "onSignalReceived callback"
      via: "lambda invocation"
      pattern: "onSignalReceived.*invoke"
---

<objective>
Create SignallingReceiver - handles bidirectional call signalling (status changes, profile switches).

Purpose: Inband signalling channel matching Python LXST Network.py SignallingReceiver (lines 13-47) and Telephony.py Signalling constants.
Output: SignallingReceiver.kt with signal sending and receiving methods.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-network-bridge/10-RESEARCH.md

# Phase 10 dependencies
@.planning/phases/10-network-bridge/10-01-SUMMARY.md

# Python reference
@app/build/python/pip/noSentryDebug/common/LXST/Network.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SignallingReceiver class</name>
  <files>reticulum/src/main/java/com/lxmf/messenger/reticulum/audio/lxst/SignallingReceiver.kt</files>
  <action>
Create SignallingReceiver matching Python LXST Network.py SignallingReceiver:

1. Package: `com.lxmf.messenger.reticulum.audio.lxst`

2. Create Signalling object with constants (match Python LXST Telephony.py exactly):
   ```kotlin
   /**
    * Signalling constants matching Python LXST Telephony.Signalling.
    */
   object Signalling {
       // Call status signals
       const val STATUS_BUSY = 0x00
       const val STATUS_REJECTED = 0x01
       const val STATUS_CALLING = 0x02
       const val STATUS_AVAILABLE = 0x03
       const val STATUS_RINGING = 0x04
       const val STATUS_CONNECTING = 0x05
       const val STATUS_ESTABLISHED = 0x06

       // Profile change prefix
       // Actual signal = PREFERRED_PROFILE + profile_byte
       // e.g., 0xFF + 0x40 = profile MQ
       const val PREFERRED_PROFILE = 0xFF
   }
   ```

3. SignallingReceiver class:
   ```kotlin
   import com.lxmf.messenger.reticulum.audio.bridge.NetworkPacketBridge

   /**
    * SignallingReceiver - Handles bidirectional call signalling.
    *
    * Matches Python LXST Network.py SignallingReceiver (lines 13-47).
    * Signals include call status changes and profile switches.
    *
    * @param bridge NetworkPacketBridge for sending signals to Python
    * @param onSignalReceived Callback when signal received from remote
    */
   class SignallingReceiver(
       private val bridge: NetworkPacketBridge,
       private val onSignalReceived: (signal: Int, isProfileChange: Boolean, profile: Int?) -> Unit
   ) {
   ```

4. Init block to register callback:
   ```kotlin
   init {
       bridge.setSignalCallback { signal ->
           handleSignalling(signal)
       }
   }
   ```

5. Send signal method (fire-and-forget):
   ```kotlin
   /**
    * Send signal to remote peer.
    *
    * @param signal Signal value (STATUS_* or PREFERRED_PROFILE + profile)
    * @param immediate If true, send immediately (default). If false, queue for inband (future).
    */
   fun signal(signal: Int, immediate: Boolean = true) {
       if (immediate) {
           bridge.sendSignal(signal)
       }
       // Note: Non-immediate (inband) signalling not implemented yet
       // Python LXST has TODO for this too
   }

   /**
    * Send profile change signal.
    * Convenience method that adds PREFERRED_PROFILE prefix.
    *
    * @param profile Profile byte (e.g., 0x40 for MQ)
    */
   fun signalProfileChange(profile: Int) {
       signal(Signalling.PREFERRED_PROFILE + profile)
   }
   ```

6. Handle incoming signal:
   ```kotlin
   /**
    * Handle signal received from remote peer.
    * Parses signal type and invokes callback.
    */
   private fun handleSignalling(signal: Int) {
       when {
           signal >= Signalling.PREFERRED_PROFILE -> {
               // Profile change: signal = 0xFF + profile_byte
               val profile = signal - Signalling.PREFERRED_PROFILE
               onSignalReceived(signal, true, profile)
           }
           else -> {
               // Status signal
               onSignalReceived(signal, false, null)
           }
       }
   }

   /**
    * Handle multiple signals (for future batch processing).
    */
   fun handleSignalling(signals: List<Int>) {
       signals.forEach { handleSignalling(it) }
   }
   ```

7. Helper to convert status to string (for debugging):
   ```kotlin
   companion object {
       /**
        * Convert status signal to human-readable string.
        * For debug logging only - do not call in hot path.
        */
       fun statusToString(status: Int): String = when (status) {
           Signalling.STATUS_BUSY -> "BUSY"
           Signalling.STATUS_REJECTED -> "REJECTED"
           Signalling.STATUS_CALLING -> "CALLING"
           Signalling.STATUS_AVAILABLE -> "AVAILABLE"
           Signalling.STATUS_RINGING -> "RINGING"
           Signalling.STATUS_CONNECTING -> "CONNECTING"
           Signalling.STATUS_ESTABLISHED -> "ESTABLISHED"
           else -> "UNKNOWN($status)"
       }
   }
   ```

IMPORTANT: onSignalReceived callback should NOT block - it's called from bridge thread.
  </action>
  <verify>
Build succeeds: `cd /home/tyler/repos/public/columba && JAVA_HOME=/home/tyler/android-studio/jbr ./gradlew :reticulum:compileDebugKotlin 2>&1 | tail -20`
File structure: `grep -E "object Signalling|class SignallingReceiver|fun signal|STATUS_ESTABLISHED|PREFERRED_PROFILE" reticulum/src/main/java/com/lxmf/messenger/reticulum/audio/lxst/SignallingReceiver.kt`
  </verify>
  <done>
SignallingReceiver.kt compiles and contains:
- Signalling object with STATUS_* constants matching Python LXST
- PREFERRED_PROFILE = 0xFF for profile change signals
- signal() method that sends via NetworkPacketBridge
- signalProfileChange() convenience method
- handleSignalling() that parses signal type and invokes callback
- Profile change detection (signal >= PREFERRED_PROFILE)
  </done>
</task>

</tasks>

<verification>
1. Build passes: `./gradlew :reticulum:compileDebugKotlin`
2. SignallingReceiver.kt exists with Signalling constants
3. Constants match Python LXST (STATUS_ESTABLISHED = 0x06, PREFERRED_PROFILE = 0xFF)
4. signal() and handleSignalling() methods present
</verification>

<success_criteria>
- SignallingReceiver compiles
- Signalling constants match Python LXST exactly
- signal() sends via NetworkPacketBridge (fire-and-forget)
- Profile change signals parsed correctly (>= 0xFF)
- Callback invoked for both status and profile signals
</success_criteria>

<output>
After completion, create `.planning/phases/10-network-bridge/10-04-SUMMARY.md`
</output>
