---
phase: 09-mixer-pipeline
plan: 04
type: execute
wave: 3
depends_on: ["09-01", "09-02", "09-03"]
files_modified:
  - reticulum/src/test/java/com/lxmf/messenger/reticulum/audio/lxst/MixerTest.kt
  - reticulum/src/test/java/com/lxmf/messenger/reticulum/audio/lxst/ToneSourceTest.kt
  - reticulum/src/test/java/com/lxmf/messenger/reticulum/audio/lxst/PipelineTest.kt
autonomous: true

must_haves:
  truths:
    - "Unit tests verify Mixer gain calculation logic"
    - "Unit tests verify ToneSource fade calculations"
    - "Unit tests verify Pipeline wiring"
    - "Tests run without Android device (mocked dependencies)"
  artifacts:
    - path: "reticulum/src/test/java/com/lxmf/messenger/reticulum/audio/lxst/MixerTest.kt"
      provides: "Mixer unit tests"
      min_lines: 40
      contains: "class MixerTest"
    - path: "reticulum/src/test/java/com/lxmf/messenger/reticulum/audio/lxst/ToneSourceTest.kt"
      provides: "ToneSource unit tests"
      min_lines: 40
      contains: "class ToneSourceTest"
    - path: "reticulum/src/test/java/com/lxmf/messenger/reticulum/audio/lxst/PipelineTest.kt"
      provides: "Pipeline unit tests"
      min_lines: 30
      contains: "class PipelineTest"
  key_links:
    - from: "MixerTest.kt"
      to: "Mixer.kt"
      via: "tests Mixer class"
      pattern: "import.*Mixer"
---

<objective>
Create unit tests for Mixer, ToneSource, and Pipeline configuration logic.

Purpose: Validate gain calculations, fade parameters, and wiring without requiring Android device. Tests must run in JVM (no JNI/native code).

Output: Unit test files that verify configuration logic with mocked dependencies, runnable via `./gradlew :reticulum:test`.
</objective>

<execution_context>
@/home/tyler/.claude/get-shit-done/workflows/execute-plan.md
@/home/tyler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md

# Implementation files to test
@reticulum/src/main/java/com/lxmf/messenger/reticulum/audio/lxst/Mixer.kt
@reticulum/src/main/java/com/lxmf/messenger/reticulum/audio/lxst/ToneSource.kt
@reticulum/src/main/java/com/lxmf/messenger/reticulum/audio/lxst/Pipeline.kt

# Existing test patterns
@reticulum/src/test/java/com/lxmf/messenger/reticulum/audio/lxst/LineSourceConfigTest.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Mixer unit tests</name>
  <files>reticulum/src/test/java/com/lxmf/messenger/reticulum/audio/lxst/MixerTest.kt</files>
  <action>
Create MixerTest.kt following existing test patterns (see LineSourceConfigTest.kt).

**Test class structure:**
```kotlin
package com.lxmf.messenger.reticulum.audio.lxst

import org.junit.Assert.*
import org.junit.Before
import org.junit.Test
import kotlin.math.pow

/**
 * Unit tests for Mixer configuration logic.
 *
 * Tests gain calculations, mute behavior, and queue management
 * without requiring Android (no JNI/native code).
 *
 * Note: Full audio mixing tests require instrumented tests on device.
 */
class MixerTest {
```

**Test cases:**

1. `testGainCalculation_Unity()`:
   - Create Mixer with globalGain = 0.0f
   - Assert mixingGain == 1.0f (unity)

2. `testGainCalculation_Boost()`:
   - Create Mixer with globalGain = 10.0f (+10 dB)
   - Assert mixingGain ≈ 10.0f (10^(10/10) = 10)
   - Use delta tolerance for float comparison

3. `testGainCalculation_Attenuate()`:
   - Create Mixer with globalGain = -10.0f (-10 dB)
   - Assert mixingGain ≈ 0.1f (10^(-10/10) = 0.1)

4. `testMute_SetsGainToZero()`:
   - Create Mixer
   - Call mute(true)
   - Assert mixingGain == 0.0f

5. `testMute_Unmute()`:
   - Create Mixer with globalGain = 6.0f
   - mute(true), assert gain == 0
   - mute(false), assert gain ≈ 10^(6/10) ≈ 4.0

6. `testCanReceive_NewSource()`:
   - Create Mixer
   - Assert canReceive(mockSource) == true (empty queue)

7. `testCanReceive_FullQueue()`:
   - Create Mixer
   - Add MAX_FRAMES frames for a source
   - Assert canReceive(that source) == false

8. `testSampleRateAutoDetect()`:
   - Create Mixer with sampleRate = 0
   - Mock source with sampleRate = 48000
   - Call handleFrame with mock source
   - Assert mixer.sampleRate == 48000

**Note on testing private properties:**
Mixer.mixingGain is a private property. Options:
1. Make it internal for testing (add @VisibleForTesting)
2. Test indirectly via output (requires actual mixing, needs device)
3. Use reflection (fragile)

**Recommended:** Make mixingGain property `internal` with @VisibleForTesting annotation:
```kotlin
@VisibleForTesting
internal val mixingGain: Float
    get() = ...
```

If Mixer doesn't have mixingGain exposed, test gain logic by:
- Testing that mute() sets the muted flag (if exposed)
- Testing that setGain() updates globalGain (if exposed)

For canReceive and handleFrame tests, need mock Source:
```kotlin
class MockSource : LocalSource() {
    override var sampleRate = 48000
    override var channels = 1
    override fun start() {}
    override fun stop() {}
    override fun isRunning() = false
}
```
  </action>
  <verify>
Test file created: `test -f reticulum/src/test/java/com/lxmf/messenger/reticulum/audio/lxst/MixerTest.kt && echo "exists"`
Tests compile: `cd /home/tyler/repos/public/columba && ./gradlew :reticulum:compileTestKotlin 2>&1 | tail -20`
Tests run: `cd /home/tyler/repos/public/columba && ./gradlew :reticulum:test --tests "*.MixerTest" 2>&1 | tail -30`
  </verify>
  <done>
MixerTest.kt exists with:
- Gain calculation tests (dB to linear conversion)
- Mute/unmute tests
- canReceive backpressure tests
- Sample rate auto-detection test
- All tests pass
  </done>
</task>

<task type="auto">
  <name>Task 2: Create ToneSource unit tests</name>
  <files>reticulum/src/test/java/com/lxmf/messenger/reticulum/audio/lxst/ToneSourceTest.kt</files>
  <action>
Create ToneSourceTest.kt for ToneSource configuration logic.

**Test cases:**

1. `testDefaultFrequency()`:
   - Create ToneSource with defaults
   - Assert frequency == 382f (matches Python LXST)

2. `testCustomFrequency()`:
   - Create ToneSource(frequency = 440f)
   - Assert frequency == 440f

3. `testEaseStepCalculation()`:
   - Create ToneSource with easeTimeMs = 20f, sampleRate = 48000
   - Expected easeStep = 1.0f / (48000 * 0.020) ≈ 0.00104f
   - Assert easeStep is close to expected (with tolerance)

4. `testGainStepCalculation()`:
   - Create ToneSource with easeTimeMs = 20f, sampleRate = 48000
   - Expected gainStep = 0.02f / (48000 * 0.020) ≈ 0.0000208f
   - Assert gainStep is close to expected

5. `testInitialEaseGain_WithEase()`:
   - Create ToneSource with ease = true
   - Call start()
   - Assert easeGain == 0f (starts silent for fade in)

6. `testInitialEaseGain_WithoutEase()`:
   - Create ToneSource with ease = false
   - Call start()
   - Assert easeGain == 1f (no fade, full volume immediately)

7. `testSamplesPerFrameCalculation()`:
   - Create ToneSource with targetFrameMs = 80, sampleRate = 48000
   - Expected: (80/1000) * 48000 = 3840 samples
   - Assert samplesPerFrame == 3840

8. `testStopWithEase_TriggersEasingOut()`:
   - Create ToneSource with ease = true
   - Call start(), then stop()
   - Assert easingOut == true
   - Assert shouldRun still true (waits for fade)

9. `testStopWithoutEase_ImmediateStop()`:
   - Create ToneSource with ease = false
   - Call start(), then stop()
   - Assert shouldRun == false (immediate)

**Note:** Many ToneSource properties are private. Need to:
1. Expose key properties as internal @VisibleForTesting
2. Or test indirectly via isRunning() behavior

For testStopWithEase: after stop(), isRunning() should return false even though shouldRun might still be true. Check ToneSource.isRunning() implementation.
  </action>
  <verify>
Test file created: `test -f reticulum/src/test/java/com/lxmf/messenger/reticulum/audio/lxst/ToneSourceTest.kt && echo "exists"`
Tests compile: `cd /home/tyler/repos/public/columba && ./gradlew :reticulum:compileTestKotlin 2>&1 | tail -20`
Tests run: `cd /home/tyler/repos/public/columba && ./gradlew :reticulum:test --tests "*.ToneSourceTest" 2>&1 | tail -30`
  </verify>
  <done>
ToneSourceTest.kt exists with:
- Default frequency test (382Hz)
- Ease parameter calculation tests
- Start/stop behavior tests
- All tests pass
  </done>
</task>

<task type="auto">
  <name>Task 3: Create Pipeline unit tests</name>
  <files>reticulum/src/test/java/com/lxmf/messenger/reticulum/audio/lxst/PipelineTest.kt</files>
  <action>
Create PipelineTest.kt for Pipeline wiring and lifecycle tests.

**Mock classes needed:**
```kotlin
class MockSource : LocalSource() {
    override var sampleRate = 48000
    override var channels = 1
    var sink: Sink? = null
    var codec: Codec? = null
    private var running = false

    override fun start() { running = true }
    override fun stop() { running = false }
    override fun isRunning() = running
}

class MockSink : LocalSink() {
    private var running = false
    override fun canReceive(fromSource: Source?) = true
    override fun handleFrame(frame: FloatArray, source: Source?) {}
    override fun start() { running = true }
    override fun stop() { running = false }
    override fun isRunning() = running
}

class MockCodec : Codec() {
    override val preferredSamplerate: Int? = 48000
    // ... other required overrides
}
```

**Test cases:**

1. `testPipelineWiresSinkToSource()`:
   - Create Pipeline with MockSource, MockCodec, MockSink
   - Assert mockSource.sink == mockSink

2. `testPipelineStartDelegatesToSource()`:
   - Create Pipeline
   - pipeline.start()
   - Assert mockSource.isRunning() == true

3. `testPipelineStopDelegatesToSource()`:
   - Create Pipeline
   - pipeline.start()
   - pipeline.stop()
   - Assert mockSource.isRunning() == false

4. `testPipelineRunningReflectsSource()`:
   - Create Pipeline
   - Assert pipeline.running == false
   - pipeline.start()
   - Assert pipeline.running == true

5. `testPipelineCodecSetter()`:
   - Create Pipeline with codec1
   - Change pipeline.codec = codec2
   - Assert mockSource.codec == codec2 (if source supports codec)

6. `testPipelineStartIdempotent()`:
   - Create Pipeline
   - pipeline.start()
   - pipeline.start() // second call
   - Should not throw, should remain running
  </action>
  <verify>
Test file created: `test -f reticulum/src/test/java/com/lxmf/messenger/reticulum/audio/lxst/PipelineTest.kt && echo "exists"`
Tests compile: `cd /home/tyler/repos/public/columba && ./gradlew :reticulum:compileTestKotlin 2>&1 | tail -20`
Tests run: `cd /home/tyler/repos/public/columba && ./gradlew :reticulum:test --tests "*.PipelineTest" 2>&1 | tail -30`
  </verify>
  <done>
PipelineTest.kt exists with:
- Wiring tests (source.sink set)
- Lifecycle delegation tests
- running property reflection tests
- All tests pass
  </done>
</task>

</tasks>

<verification>
1. All three test files exist
2. Tests compile: `./gradlew :reticulum:compileTestKotlin`
3. Tests pass: `./gradlew :reticulum:test --tests "*.MixerTest" --tests "*.ToneSourceTest" --tests "*.PipelineTest"`
4. No Android dependencies in tests (JVM only)
</verification>

<success_criteria>
- Unit tests verify configuration logic without device
- Mixer gain calculations tested
- ToneSource fade parameters tested
- Pipeline wiring tested
- All tests pass in JVM
</success_criteria>

<output>
After completion, create `.planning/phases/09-mixer-pipeline/09-04-SUMMARY.md`
</output>
