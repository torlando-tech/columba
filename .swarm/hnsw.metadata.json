[["entry_1770158341274_4gqb6",{"id":"entry_1770158341274_4gqb6","key":"columba-architecture","namespace":"codebase","content":"# Architecture\n\n**Analysis Date:** 2026-01-23\n\n## Pattern Overview\n\n**Overall:** Multi-process Android application with clean layered architecture (UI → ViewModel → Repository → Database + Service IPC).\n\n**Key Characteristics:**\n- Clean Architecture with clear separation of concerns across modules\n- Dependency Injection (Hilt) for testability and flexibility\n- Service-based background processing for Python Reticulum networking stack\n- Protocol abstraction layer enabling future Rust/UniFFI migration\n- Cross-process communication via AIDL for reliable message passing\n- Reactive data flow using Kotlin Coroutines and StateFlow\n\n## Layers\n\n**UI Layer:**\n- Purpose: Compose-based user interface, Material Design 3 themes\n- Location: `app/src/main/java/com/lxmf/messenger/ui/`\n- Contains: Screens, Components, Theme definitions, UI models, Utilities\n- Depends on: ViewModels, Repositories, Domain models, Utilities\n- Used by: MainActivity (entry point)\n\n**ViewModel Layer:**\n- Purpose: State management, business logic orchestration, screen-specific state\n- Location: `app/src/main/java/com/lxmf/messenger/viewmodel/`\n- Contains: ViewModel classes for each major screen/feature\n- Depends on: Repositories, use case logic, Coroutines\n- Used by: UI Layer (Composables)\n\n**Repository Layer:**\n- Purpose: Data access abstraction, combining database and service sources\n- Location: `data/src/main/java/com/lxmf/messenger/data/repository/` and `app/src/main/java/com/lxmf/messenger/repository/`\n- Contains: Repository implementations for conversations, contacts, settings, identities\n- Depends on: DAOs, Services, DataStore, External protocols\n- Used by: ViewModels, Service managers\n\n**Service Layer (Background Process):**\n- Purpose: Long-running Reticulum networking service in separate `:reticulum` process\n- Location: `app/src/main/java/com/lxmf/messenger/service/`\n- Contains: ReticulumService (lifecycle shell), ServiceModule (DI), managers, state\n- Depends on: ReticulumProtocol, Database, Python/Chaquopy\n- Used by: Main app process via AIDL binder\n\n**Data/Database Layer:**\n- Purpose: Persistent data storage using Room ORM\n- Location: `data/src/main/java/com/lxmf/messenger/data/db/`\n- Contains: Database schema, DAOs, Entities, Migrations\n- Depends on: Room, SQLite\n- Used by: Repositories, Service managers\n\n**Reticulum Protocol Layer:**\n- Purpose: Network stack abstraction for mesh networking protocol\n- Location: `reticulum/src/main/java/com/lxmf/messenger/reticulum/`\n- Contains: Protocol interface, ServiceReticulumProtocol (service-based), BLE bridge, RNode USB\n- Depends on: Python/Chaquopy (via Chaquopy), Android APIs, Coroutines\n- Used by: Service managers, ViewModels\n\n**Domain/Shared Models:**\n- Purpose: Core data models and business logic\n- Location: `reticulum/src/main/java/com/lxmf/messenger/reticulum/model/` and `app/src/main/java/com/lxmf/messenger/data/model/`\n- Contains: Identity, Destination, Link, Message, AnnounceEvent, configuration models\n- Depends on: Nothing (pure data)\n- Used by: All layers\n\n## Data Flow\n\n**Initialization Flow (Cold Start):**\n\n1. `ColumbaApplication.onCreate()` initializes DI and starts core managers\n2. `MainActivity.onCreate()` sets up UI, navigates based on onboarding state\n3. `ReticulumService.onCreate()` in background process initializes:\n   - ServiceModule creates all managers (BLE, Messaging, Health Check, etc.)\n   - PythonWrapperManager initializes Chaquopy and Python Reticulum instance\n   - HealthCheckManager starts heartbeat polling (~5s intervals)\n4. `ServiceReticulumProtocol` in main process establishes AIDL connection to service\n5. UI ViewModels query repositories which delegate to service via IPC\n\n**Message Reception Flow:**\n\n1. Python Reticulum instance (in service process) receives packets\n2. EventHandler in service parses packet to domain models (ReceivedPacket, LinkEvent, etc.)\n3. CallbackBroadcaster sends broadcasts to main app process\n4. Main app broadcasts received via BroadcastReceiver\n5. Repository updates database (Message, Conversation, Announce tables)\n6. StateFlow<> in repository notifies ViewModels\n7. ViewModel recomposes UI\n\n**Message Sending Flow:**\n\n1. User composes message in ConversationScreen\n2. ChatsViewModel calls MessagingRepository.sendMessage()\n3. Repository delegates to service via AIDL (ReticulumServiceBinder)\n4. Service's MessagingManager hands to Python for LXMF delivery\n5. PacketReceipt returned via AIDL response\n6. ViewModel updates conversation with delivery status\n\n**State Management:**\n\n- **Service State:** `ServiceState` (atomic thread-safe holder) in service process\n- **UI State:** StateFlow-based repositories in main app process\n- **Cross-Process Sync:** DataStore (protocol buffers) for persistent state\n- **Network Status:** StateFlow from ReticulumProtocol, updated by HealthCheckManager\n\n## Key Abstractions\n\n**ReticulumProtocol (Interface):**\n- Purpose: Network stack contract enabling implementation swapping\n- Examples: `reticulum/src/main/java/com/lxmf/messenger/reticulum/protocol/ReticulumProtocol.kt`\n- Pattern: Strategy pattern with async/suspend functions for non-blocking ops\n- Implementations: `ServiceReticulumProtocol` (production), `MockReticulumProtocol` (testing)\n\n**ReticulumServiceBinder (AIDL):**\n- Purpose: IPC interface for main app to call service functions\n- Examples: `app/src/main/java/com/lxmf/messenger/service/binder/ReticulumServiceBinder.kt`\n- Pattern: Adapter pattern converting AIDL calls to internal manager methods\n- Converts Python results to Kotlin types via `PythonResultConverter`\n\n**Repository Pattern:**\n- Purpose: Abstract data sources (database, service, DataStore)\n- Examples: `ConversationRepository`, `IdentityRepository`, `SettingsRepository`\n- Pattern: Combines database queries with service calls, exposes StateFlow<>\n- Consistent across app - all repositories follow this structure\n\n**Manager Pattern (Service Layer):**\n- Purpose: Orchestrate complex operations, manage lifecycle\n- Examples: `PythonWrapperManager`, `HealthCheckManager`, `MessagingManager`, `NetworkChangeManager`\n- Pattern: Each manager handles one domain (Python, Health, Messaging, Network)\n- Initialized in `ServiceModule.createManagers()`, all share `ServiceState`\n\n**DAO Pattern (Database):**\n- Purpose: Type-safe database queries\n- Examples: `ConversationDao`, `MessageDao`, `PeerIdentityDao`\n- Pattern: Room @Dao annotated interfaces returning Flow<> for reactive queries\n- One DAO per entity type in `data/src/main/java/com/lxmf/messenger/data/db/dao/`\n\n## Entry Points\n\n**MainActivity:**\n- Location: `app/src/main/java/com/lxmf/messenger/MainActivity.kt`\n- Triggers: Intent.ACTION_MAIN, deep links (lxma://), USB device attached, BROADCAST_ACTION\n- Responsibilities: Set up Compose UI, handle permissions, route based on onboarding state, manage navigation\n\n**ColumbaApplication:**\n- Location: `app/src/main/java/com/lxmf/messenger/ColumbaApplication.kt`\n- Triggers: App process startup (before any activity)\n- Responsibilities: Hilt DI initialization, start core managers (MessageCollector, AutoAnnounce, Migration), error reporting (Sentry)\n\n**ReticulumService:**\n- Location: `app/src/main/java/com/lxmf/messenger/service/ReticulumService.kt`\n- Triggers: MainActivity.startService() or system launch in background\n- Responsibilities: Foreground service lifecycle, initialize managers via ServiceModule, expose AIDL binder, monitor health\n\n**RNodeCompanionService:**\n- Location: `app/src/main/java/com/lxmf/messenger/service/RNodeCompanionService.kt`\n- Triggers: Companion Device Manager (Android 12+) when RNode in range\n- Responsibilities: Register Columba as companion app for RNode devices\n\n## Error Handling\n\n**Strategy:** Defensive programming with fallbacks, observable error states, crash reporting.\n\n**Patterns:**\n\n- **Result<T> Type:** Service and protocol methods return sealed Result<Success/Failure>\n- **StateFlow Error State:** Repositories expose error flows that ViewModels observe\n- **Try-Catch in Managers:** Broad exception handling in service managers with logging\n- **Timeout Protection:** Service IPC calls use `withTimeoutOrNull()` to prevent ANR\n- **Stale Heartbeat Detection:** HealthCheckManager monitors Python responsiveness, triggers restart if stale\n- **Generation Tracking:** Race condition prevention - generation counter prevents stale async jobs from overwriting state\n- **Crash Reporting:** Sentry integration via `CrashReportManager` for production issues\n\n## Cross-Cutting Concerns\n\n**Logging:**\n- Approach: Android Log with debug tag per class (e.g., \"ReticulumService\", \"ChatsViewModel\")\n- Level: DEBUG for normal flow, WARN/ERROR for issues\n- Location: Imports `android.util.Log` throughout codebase\n\n**Validation:**\n- Approach: Input validation in ViewModels before repository calls\n- Domain validation in repositories (e.g., identity hash format)\n- Location: `app/src/main/java/com/lxmf/messenger/util/validation/`\n\n**Authentication:**\n- Approach: Identity-based mesh protocol (LXMF/Reticulum), not traditional login\n- Identity files stored locally, exported/imported via QR codes or file sharing\n- Location: Identity management in `IdentityRepository`, `IdentityManager`\n\n**Permissions:**\n- Approach: Runtime permissions via ActivityResultContracts (Camera, Location, Bluetooth, Recording)\n- Manifest declared in `AndroidManifest.xml` with detailed rationale comments\n- Location: Permission handling in MainActivity intent filters and runtime checks\n\n---\n\n*Architecture analysis: 2026-01-23*"}],["entry_1770158342221_7pnw28",{"id":"entry_1770158342221_7pnw28","key":"columba-concerns","namespace":"codebase","content":"# Codebase Concerns\n\n**Analysis Date:** 2026-01-23\n\n## Tech Debt\n\n**Build system: x86_64 architecture support disabled:**\n- Issue: x86_64 ABIs are excluded from build due to pycodec2 wheel resolution issue\n- Files: `app/build.gradle.kts:122`, `reticulum/build.gradle.kts:20`\n- Impact: Cannot run app or tests on x86_64 emulators/devices; limits testing flexibility; only arm64-v8a is compiled\n- Fix approach: Resolve or create pre-built pycodec2 wheel for x86_64 architecture and update gradle files to include x86_64 in abiFilters\n\n**Metrics infrastructure not integrated:**\n- Issue: Production metrics for BLE dual-connection race detection are tracked internally but no integration exists for monitoring\n- Files: `reticulum/src/main/java/com/lxmf/messenger/reticulum/ble/bridge/KotlinBLEBridge.kt:226`\n- Impact: Cannot observe production metrics (dualConnectionRaceCount); no observability into how often race conditions occur in deployed app\n- Fix approach: Integrate with Firebase, Grafana, or custom metrics service once available\n\n**Per-peer statistics tracking incomplete:**\n- Issue: BLE peer connection statistics are aggregated globally but individual per-peer stats (bytesReceived/bytesSent) are not tracked\n- Files: `reticulum/src/main/java/com/lxmf/messenger/reticulum/ble/service/BleConnectionManager.kt:520-521`\n- Impact: Cannot diagnose peer-specific performance issues; UI peer details show zeros for per-peer byte counts\n- Fix approach: Add per-peer byte counters to PeerConnectionDetails; track in BleGattClient/BleGattServer\n\n**Legacy settings migration with deprecated APIs:**\n- Issue: Settings migration code uses @Suppress(\"DEPRECATION\") for MODE_MULTI_PROCESS to maintain backward compatibility, but this Android API is deprecated\n- Files: `app/src/main/java/com/lxmf/messenger/migration/LegacySettingsImporter.kt`, `repository/SettingsRepository.kt:141,1711`\n- Impact: Ongoing maintenance burden; will break if API is removed in future Android versions\n- Fix approach: Plan migration to DataStore across the entire codebase; phase out legacy SharedPreferences usage\n\n**File attachment parsing in message retry incomplete:**\n- Issue: When retrying failed messages, file attachments cannot be reconstructed from stored fieldsJson data\n- Files: `app/src/main/java/com/lxmf/messenger/viewmodel/MessagingViewModel.kt:1727`\n- Impact: Failed messages with file attachments will lose attachments on retry; only text and image content are preserved\n- Fix approach: Implement fieldsJson parsing for file attachments, similar to existing image parsing\n\n## Known Bugs\n\n**BLE dual-mode race condition in send() (TOCTOU - Time Of Check Time Of Use):**\n- Symptoms: During deduplication of dual connections (central + peripheral to same peer), a send() operation may use stale peer state\n- Files: `reticulum/src/test/java/com/lxmf/messenger/reticulum/ble/bridge/KotlinBLEBridgeSendRaceConditionTest.kt:27-54`\n- Trigger: Race between deduplicationState changes and send() state reads when one connection is closing\n- Current status: Documented in test but not yet fixed; test shows issue with testDelayAfterStateReadMs hook\n- Workaround: None; app is vulnerable to silently sending via closing connection paths\n- Fix approach: Add per-peer mutex to make state read + send operation atomic\n\n**Missing on_duplicate_identity_detected callback for Python layer:**\n- Symptoms: When same peer is detected via both central and peripheral connections, Python driver cannot be notified to handle deduplication\n- Files: `reticulum/src/test/java/com/lxmf/messenger/reticulum/ble/bridge/KotlinBLEBridgeDuplicateIdentityCallbackTest.kt:25-195`, `reticulum/src/main/java/com/lxmf/messenger/reticulum/ble/bridge/KotlinBLEBridge.kt`\n- Trigger: Detect same identityHash arriving via different BLE MAC addresses on both central and peripheral modes\n- Current status: Callback infrastructure missing (no onDuplicateIdentityDetected field, no setter); bridge handles deduplication internally but doesn't notify Python\n- Impact: Python layer cannot make intelligent decisions about which connection to keep; asymmetric behavior between dual-mode peers\n- Fix approach: Add onDuplicateIdentityDetected PyObject callback field and setters to KotlinBLEBridge; call from deduplication logic\n\n**BLE GATT Server keepalive job orphaned on disconnect:**\n- Symptoms: When central disconnects, keepalive job continues running if only removed from connectedCentrals map without cancelling\n- Files: `reticulum/src/test/java/com/lxmf/messenger/reticulum/ble/server/BleGattServerKeepaliveTest.kt:99-112`\n- Trigger: Disconnect path doesn't cancel associated keepalive coroutine\n- Current status: Pattern documented in test; vulnerable if implementation doesn't consistently cancel\n- Impact: Memory leak of orphaned coroutines; stale keepalive signals to disconnected peers\n- Fix approach: Always pair connection removal with keepaliveJobs[address]?.cancel(); ensure disconnect handler cancels before removing from map\n\n**Old RNode read thread race condition preventing restart:**\n- Symptoms: Stopping and restarting RNode interface can fail if previous read thread doesn't stop within timeout\n- Files: `python/rnode_interface.py:440`\n- Trigger: Read thread stuck in I/O or slow to notice shutdown signal; attempting to start while old thread still running\n- Current status: Explicit error handling in place (returns False), but failure message doesn't give actionable recovery path\n- Impact: RNode interface cannot be restarted without app restart; affects switching between USB and serial interfaces\n- Fix approach: Increase timeout, add forced thread termination after graceful attempt, or redesign thread lifecycle\n\n## Security Considerations\n\n**Generic exception catching in multiple layers:**\n- Risk: Swallowed exceptions hide failures and make debugging harder; potential for silent data loss\n- Files: `data/database/dao/InterfaceDao.kt:189`, `service/manager/ServiceNotificationManager.kt:114`, `service/persistence/ServicePersistenceManager.kt:320,363`, `ui/components/IconPickerDialog.kt:674`, `ui/components/ProfileIcon.kt:57,65`, `ui/model/MessageMapper.kt:91,115,152`\n- Current mitigation: Mostly marked with @Suppress(\"SwallowedException\") and logged; exceptions in UI/parsing are intentionally silent\n- Recommendations: Audit exception handling to distinguish between \"expected failures to ignore\" vs \"unexpected errors to report\"; add metrics for swallowed exceptions\n\n**SharedPreferences multi-process mode for cross-process settings access:**\n- Risk: MODE_MULTI_PROCESS has subtle consistency issues; settings updates from one process may not be visible immediately in another\n- Files: `repository/SettingsRepository.kt:141,1711`, `service/persistence/ServiceSettingsAccessor.kt:14`\n- Current mitigation: Documentation in code; no explicit syncing logic observed\n- Recommendations: Plan migration to Jetpack DataStore which has better multi-process semantics; add explicit reload points if staying with SharedPreferences\n\n**Kotlin/Java ArrayList to Python list conversion pattern:**\n- Risk: Passing raw Kotlin ArrayList to Python via Chaquopy will fail with \"'ArrayList' object is not iterable\"\n- Files: Noted in CLAUDE.md project instructions\n- Current mitigation: Code review awareness (documented in project guidelines)\n- Recommendations: Create helper function for ArrayList->Python list conversion; consider linter rule or Chaquopy plugin to catch this\n\n## Performance Bottlenecks\n\n**MaterialDesignIcons.kt large generated file:**\n- Problem: Icon definitions generate 7470-line source file with repetitive structure\n- Files: `app/src/main/java/com/lxmf/messenger/ui/theme/MaterialDesignIcons.kt:7470 lines`\n- Cause: All Material Design icons compiled into single Kotlin file; likely code generation artifact\n- Impact: Slow IDE performance when navigating file; increases app binary size; slow compilation\n- Improvement path: Consider icon library (Compose Material Icons) instead of generated file; or split into multiple files with lazy initialization\n\n**Large UI screen files with complex logic:**\n- Problem: Several UI screens exceed 2000 lines with nested conditions and state management\n- Files: `app/src/main/java/com/lxmf/messenger/ui/screens/MessagingScreen.kt:2355 lines`, `app/src/main/java/com/lxmf/messenger/ui/screens/ContactsScreen.kt:1678 lines`\n- Cause: Feature-rich screens with many sub-composables and states in single file\n- Impact: Harder to test; difficult to modify one feature without affecting others; IDE slowness\n- Improvement path: Break into smaller composable functions with clear responsibilities; extract state management to ViewModels\n\n**ViewModel size and complexity:**\n- Problem: MessagingViewModel (2116 lines), SettingsViewModel (1871 lines), RNodeWizardViewModel (3293 lines) are large and handle many concerns\n- Files: `app/src/main/java/com/lxmf/messenger/viewmodel/MessagingViewModel.kt:2116`, `SettingsViewModel.kt:1871`, `RNodeWizardViewModel.kt:3293`\n- Cause: Feature accumulation without refactoring into smaller ViewModels\n- Impact: Hard to test individual features; tight coupling of unrelated concerns; slow test execution\n- Improvement path: Extract sub-features into separate ViewModels; consider MVI or MVVM++ pattern; compose ViewModels with lower-level services\n\n**RNodeRegionalPreset switch complexity:**\n- Problem: getDefaultSlot() and calculateSlotFromFrequency() methods have high cyclomatic complexity with large when expressions\n- Files: `app/src/main/java/com/lxmf/messenger/data/model/RNodeRegionalPreset.kt:569,621`\n- Cause: Supporting many regional frequency configurations in single method\n- Impact: Hard to verify correctness; difficult to add new regions; potential for copy-paste errors\n- Improvement path: Extract region data to data-driven configuration; use lookup table instead of when statement\n\n**Database query without aggregation/pagination:**\n- Problem: No evidence of result pagination for large tables; potential for loading entire Contact/Message tables\n- Impact: Memory usage spikes on large datasets; potential ANR (Application Not Responding) on slow devices\n- Improvement path: Implement infinite scroll with Flow<PagingData>; use Room Paging library; add result limits\n\n## Fragile Areas\n\n**BLE connection deduplication state machine:**\n- Files: `reticulum/src/main/java/com/lxmf/messenger/reticulum/ble/bridge/KotlinBLEBridge.kt:193-203` (DeduplicationTracker, deduplicationInProgress)\n- Why fragile: Complex state with multiple concurrent maps (peers, connectedPeers, deduplicationInProgress, processedIdentityCallbacks, pendingCentralConnections); race conditions when peer simultaneously connects as central and peripheral\n- Safe modification: Always modify deduplication state under mutex; never check state then act later (atomic check-then-act); add comprehensive logging of state transitions\n- Test coverage: Covered by KotlinBLEBridgeSendRaceConditionTest, KotlinBLEBridgeDuplicateIdentityCallbackTest, KotlinBLEBridgeTest; gaps in signal ordering and callback timing\n\n**Message retry logic with partial field reconstruction:**\n- Files: `app/src/main/java/com/lxmf/messenger/viewmodel/MessagingViewModel.kt:1715-1740`\n- Why fragile: File attachments not reconstructed; only images and text supported; next developer may lose attachments silently\n- Safe modification: Complete fieldsJson parsing before retry implementation; add unit test with file attachments; verify round-trip through storage\n- Test coverage: MessagingViewModelTest (4690 lines) but check if retry with attachments is tested\n\n**Python-Kotlin bridge with Chaquopy PyObject callbacks:**\n- Files: `reticulum/src/main/java/com/lxmf/messenger/reticulum/ble/bridge/KotlinBLEBridge.kt:230-248` (onDeviceDiscovered, onConnected, onDisconnected, onDataReceived, onIdentityReceived, onMtuNegotiated)\n- Why fragile: Callbacks can be null; no validation that Python can actually handle callback signature; Chaquopy serialization quirks (ArrayList issue)\n- Safe modification: Add non-null asserts before calling; add try-catch around callback invocation; log callback errors explicitly\n- Test coverage: Tests for callbacks exist but should verify error cases\n\n**Migration/export-import logic:**\n- Files: `app/src/main/java/com/lxmf/messenger/migration/MigrationExporter.kt:34`, `MigrationImporter.kt:36`, `LegacySettingsImporter.kt`\n- Why fragile: Multiple data sources (database, SharedPreferences, DataStore); version-dependent field mappings; @Suppress(\"TooManyFunctions\") suggests unmaintainable\n- Safe modification: Write comprehensive migration tests with sample data from each version; add rollback capability; validate data after import\n- Test coverage: Not clear from grep; recommend adding MigrationTest\n\n**RNode interface lifecycle with thread management:**\n- Files: `python/rnode_interface.py:435-441` (read thread detection and restart)\n- Why fragile: Manual thread lifecycle management; timeout-based detection of stuck threads; no forced termination after timeout\n- Safe modification: Consider ThreadPoolExecutor for managed lifecycle; add health checks; implement thread state machine\n- Test coverage: Needs specific test for timeout and recovery scenarios\n\n## Scaling Limits\n\n**BLE connection pool capacity:**\n- Current capacity: BleConstants.MAX_CONNECTIONS (not visible but referenced in BleConnectionManager.kt:354-356)\n- Limit: Each connection consumes GATT resources and socket buffers; dual-mode operation means each peer potentially uses 2x capacity\n- Scaling path: Make MAX_CONNECTIONS configurable; implement connection prioritization/eviction; measure actual limits on different Android versions\n\n**Message/Contact database table growth:**\n- Current capacity: No explicit limits observed for message or contact retention\n- Limit: Device storage is limited; large Message/Contact tables slow down queries; no automatic cleanup\n- Scaling path: Implement message retention policies (age-based deletion); add message archiving; consider external storage for old messages\n\n**Python memory with BLE packet buffers:**\n- Current capacity: incomingPacketQueue in BleConnectionManager is unbounded ConcurrentLinkedQueue\n- Limit: No backpressure mechanism if Python can't consume packets as fast as BLE produces them\n- Scaling path: Implement bounded queue with backpressure; add metrics for queue depth; implement flow control\n\n## Dependencies at Risk\n\n**Pycodec2 wheel binary dependency:**\n- Risk: Pre-built wheel hosted on external GitHub releases; no fallback if release is deleted or becomes unavailable\n- Impact: Build will fail; cannot create new builds without wheel\n- Mitigation: None observed; single point of failure\n- Migration plan: Mirror wheel to organization repo; vendor wheel in git (large but reliable); build from source in CI; migrate to alternative codec if available\n\n**Chaquopy Python bridging (com.chaquo.python):**\n- Risk: External Gradle plugin and runtime; maintains compatibility between Python versions and Android NDK versions\n- Impact: Updates can break builds (version conflicts); complex to debug Kotlin/Python integration issues\n- Mitigation: Pinned to specific version in gradle files; good test coverage of bridge calls\n- Migration plan: Monitor for updates; keep minor version updated; document any version constraints\n\n**Room Database library (androidx.room:room-runtime):**\n- Risk: ORM abstraction may hide inefficient queries; generated code can be opaque\n- Impact: N+1 query problems; inefficient JOINs; hard to optimize without rebuilding entities\n- Mitigation: Room generates code; IDE inspection can help; Room annotations enforce compile-time safety\n- Migration plan: Monitor generated _Impl files; add query performance tests; consider raw SQL for complex queries\n\n**Reticulum Python library (core dependency):**\n- Risk: Large external dependency with deep integration throughout codebase; single point of failure for mesh networking\n- Impact: Bugs in Reticulum affect entire application; incompatible versions break interfaces\n- Mitigation: Vendored copy in python/patches/RNS/; custom extensions (Destination.py, __init__.py) documented\n- Migration plan: Keep patches directory current; add integration tests for Reticulum interface changes; consider contributing fixes upstream\n\n## Missing Critical Features\n\n**File attachment persistence and retry:**\n- Problem: Message retry doesn't reconstruct file attachments from storage\n- Blocks: Users cannot reliably retry messages with files; files are lost on failure\n- Impact: Reduces reliability of critical file transfers in mesh network\n\n**Network path request integration for pending contacts:**\n- Problem: When adding contact by hash only (no identity), app doesn't trigger network search to find identity\n- Files: `app/src/main/java/com/lxmf/messenger/viewmodel/ContactsViewModel.kt:465,498`\n- Blocks: Pending contacts may never be resolved without manual user action\n- Impact: Reduced discoverability of new contacts\n\n**Multiple identity management UI:**\n- Problem: UI for managing multiple Reticulum identities is stubbed out\n- Files: `app/src/main/java/com/lxmf/messenger/ui/screens/MyIdentityScreen.kt:192` (commented out IdentityManagementCard)\n- Blocks: Users cannot have multiple identities in same app\n- Impact: Limits use cases where different identities are needed for different purposes\n\n**Connected peer count display for TCP Server interfaces:**\n- Problem: Interface management screen doesn't show how many clients are connected to TCP Server interfaces\n- Files: `app/src/main/java/com/lxmf/messenger/ui/screens/InterfaceManagementScreen.kt:945`\n- Blocks: Users cannot monitor TCP Server status from UI\n- Impact: Harder to troubleshoot server-mode connectivity issues\n\n## Test Coverage Gaps\n\n**BLE deduplication edge cases:**\n- What's not tested: Race condition between deduplication trigger and send() call (documented but only test harness exists, not fix)\n- Files: `reticulum/src/test/java/com/lxmf/messenger/reticulum/ble/bridge/KotlinBLEBridgeSendRaceConditionTest.kt` (test exists but issue not fixed)\n- Risk: Silent data loss or corruption if message sent via closing connection\n- Priority: High\n\n**File attachment message retry:**\n- What's not tested: Retrying messages with file attachments; fieldsJson reconstruction\n- Files: `app/src/test/java/com/lxmf/messenger/viewmodel/MessagingViewModelTest.kt` (check if retry with attachments is covered)\n- Risk: File attachments silently lost on retry\n- Priority: High\n\n**Python-Kotlin bridge error cases:**\n- What's not tested: Chaquopy callback failures (Python exception in callback, missing callback method signature, ArrayList serialization)\n- Files: Various Kotlin/Python bridge classes lack error scenario tests\n- Risk: Silent callback failures with no logging; cryptic Chaquopy serialization errors\n- Priority: Medium\n\n**RNode interface restart after thread timeout:**\n- What's not tested: Specific scenario where read thread hangs and restart is attempted\n- Files: `python/rnode_interface.py` (no specific test for timeout recovery)\n- Risk: RNode interface permanently broken until app restart\n- Priority: Medium\n\n**Cross-process SharedPreferences consistency:**\n- What's not tested: Multi-process reads/writes to settings with MODE_MULTI_PROCESS; data freshness guarantees\n- Files: `repository/SettingsRepository.kt`, `service/persistence/ServiceSettingsAccessor.kt`\n- Risk: Service and UI process see stale settings; inconsistent state across processes\n- Priority: Medium\n\n**Message migration with partial data:**\n- What's not tested: Migrating messages with missing/corrupt fieldsJson; handling version format changes\n- Files: Migration code handles some deprecations but comprehensive round-trip migration test not visible\n- Risk: Data loss during version upgrades\n- Priority: Low\n\n---\n\n*Concerns audit: 2026-01-23*"}],["entry_1770158343127_r4pt97",{"id":"entry_1770158343127_r4pt97","key":"columba-conventions","namespace":"codebase","content":"# Coding Conventions\n\n**Analysis Date:** 2026-01-23\n\n## Naming Patterns\n\n**Files:**\n- `PascalCase` for class/interface files: `BleStatusRepository.kt`, `InterfaceDatabase.kt`, `MessageOrderingTest.kt`\n- Test files: `{ClassName}Test.kt` (unit tests) or `{ClassName}RaceConditionTest.kt` (specific scenario tests)\n- `camelCase` for Kotlin files with multiple internal functions (less common)\n\n**Functions:**\n- `camelCase` for all functions, both public and private: `getConnectedPeersFlow()`, `parseConnectionsJson()`, `stateToString()`\n- Test functions use backtick-quoted descriptive names: `` `messages are ordered by timestamp ascending`() ``, `` `findByParams finds SHORT_TURBO`() ``\n- Enforced by detekt rule `FunctionNaming` with pattern `[a-z][a-zA-Z0-9]*`, except for `@Composable` functions which are exempt\n\n**Variables:**\n- `camelCase` for all variables: `testPeerHash`, `adapterState`, `connectionType`\n- Private class variables with backing fields: `private val bleBridge`\n- Enforced by detekt rule `VariableNaming` with pattern `[a-z][A-Za-z0-9]*`\n\n**Types:**\n- `PascalCase` for data classes, enums, sealed classes: `BleConnectionInfo`, `ConnectionType`, `BleConnectionsState`\n- Top-level constants in `UPPER_SNAKE_CASE`: `TAG` constant (enforced by detekt rule `TopLevelPropertyNaming`)\n\n**Enums and Sealed Classes:**\n- Use descriptive enum members: `EXCELLENT`, `GOOD`, `FAIR`, `POOR` in `SignalQuality`\n- Sealed class variants use meaningful names: `BluetoothDisabled`, `Loading`, `Success`, `Error`\n\n## Code Style\n\n**Formatting:**\n- 4-space indentation (per `.editorconfig`)\n- 160-character max line length for Kotlin (enforced by detekt)\n- LF line endings, UTF-8 encoding\n- Insert final newline in all files\n- Trim trailing whitespace\n\n**Linting:**\n- Tool: `detekt` (1.23.8) with custom Columba rules\n- Tool: `ktlint` (1.0.1) in advisory mode (non-blocking)\n- Baseline: `detekt-baseline.xml` captures pre-existing issues; new code must pass checks\n- Run verification: `./gradlew detektCheck ktlintCheck`\n- Update baseline after intentional fixes: `./gradlew detektBaseline`\n\n**Quality Thresholds (detekt):**\n- Cyclomatic complexity: max 18 (ignores `@Composable`)\n- Function length: max 80 lines (ignores `@Composable`)\n- Class size: max 600 lines\n- Parameter list: 8 params (functions), 10 params (constructors) - ignored for `@Composable`\n- Nested block depth: max 5 levels\n- Functions per file: max 15 (classes), max 25 (interfaces)\n- Max line length: 200 characters (detekt override vs editorconfig's 160)\n- Return count: max 3 per function\n- Throw count: max 2 per function\n- No wildcard imports (except in test and androidTest)\n\n## Import Organization\n\n**Order:**\n1. Package declaration\n2. Blank line\n3. Standard library imports (e.g., `java.*`, `kotlin.*`)\n4. Third-party imports (Android framework, Dagger, kotlinx, etc.)\n5. Project-local imports (`com.lxmf.messenger.*`)\n6. Blank line\n7. Code\n\n**Pattern observed:** Imports grouped by origin with blank lines between groups.\n\nExample from `BleStatusRepository.kt`:\n```kotlin\npackage com.lxmf.messenger.data.repository\n\nimport android.bluetooth.BluetoothAdapter\nimport android.content.Context\nimport android.util.Log\nimport com.lxmf.messenger.data.model.BleConnectionInfo\nimport com.lxmf.messenger.data.model.BleConnectionsState\nimport com.lxmf.messenger.reticulum.protocol.ReticulumProtocol\nimport dagger.hilt.android.qualifiers.ApplicationContext\nimport kotlinx.coroutines.flow.Flow\nimport org.json.JSONArray\nimport javax.inject.Inject\nimport javax.inject.Singleton\n```\n\n**Path Aliases:**\n- Not used; fully qualified imports throughout\n\n**Wildcard Imports:**\n- Forbidden in production code (detekt enforces)\n- Allowed in test and androidTest only\n\n## Error Handling\n\n**Pattern - Try/Catch with Logging:**\n```kotlin\ntry {\n    // operation\n    return result\n} catch (e: Exception) {\n    Log.e(TAG, \"Error message describing what failed\", e)\n    // Return default/empty value (never throw up)\n    return emptyList()\n}\n```\n\n**Pattern - Explicit Exception Types:**\n- Prefer catching specific exceptions where possible\n- Detekt enforces: `TooGenericExceptionCaught` disallows `RuntimeException`, `Throwable`, `Exception` without justification\n- Allowed with regex pattern: `_|(ignore|expected).*` (e.g., `_e` or `ignoredException`)\n\n**Pattern - Graceful Degradation:**\n- Functions return safe defaults on error: `emptyList()`, `null`, `0`\n- Never crash or throw exceptions to caller\n- Log full exception with context for debugging\n\nExample from `BleStatusRepository.kt`:\n```kotlin\nprivate fun parseConnectionsJson(jsonString: String): List<BleConnectionInfo> {\n    return try {\n        // parse logic\n        connections\n    } catch (e: Exception) {\n        Log.e(TAG, \"Error parsing connections JSON\", e)\n        emptyList()  // Safe default\n    }\n}\n```\n\n## Logging\n\n**Framework:** Android `Log` class (no third-party logging framework)\n\n**Tag Pattern:**\n- Define as companion object constant: `private const val TAG = \"ClassName\"`\n- Must be present in all classes that use logging (detekt custom rule: `BleLoggingTag`)\n\n**Patterns:**\n- `Log.d(TAG, \"message\")` - Debug: informational messages, state transitions\n- `Log.w(TAG, \"message\")` - Warning: unexpected but recoverable conditions\n- `Log.e(TAG, \"message\", exception)` - Error: failures with full exception context\n- `Log.v(TAG, \"message\")` - Verbose: detailed diagnostic info (only when needed)\n\n**Logging in Repositories:**\n- Log state changes: `\"Bluetooth turning on - returning Loading state\"`\n- Log data received: `\"Event-driven: received ${connections.size} BLE connections\"`\n- Log errors with context: `Log.e(TAG, \"Error parsing connections JSON\", e)`\n\n## Comments\n\n**When to Comment:**\n- Non-obvious logic or business rules: Explain the \"why\" not the \"what\"\n- Complex parsing or configuration: Document data format expectations\n- TODOs for future work (sparingly)\n- Do NOT comment obvious code: `val name = obj.name // set name`\n\n**JSDoc/KDoc:**\n- Use KDoc format (/** */) for public classes, interfaces, and functions\n- Include `@param` and `@return` tags for public APIs\n- Document intent and expected behavior, not implementation details\n\nExample from `BleStatusRepository.kt`:\n```kotlin\n/**\n * Get a flow of BLE connection state that combines adapter state with connection data.\n * Uses event-driven updates from the service (< 100ms latency).\n *\n * @return Flow emitting BleConnectionsState\n */\nfun getConnectedPeersFlow(): Flow<BleConnectionsState>\n```\n\nExample from `BleConnectionInfo.kt`:\n```kotlin\n/**\n * Returns a shortened version of the identity hash (first 8 characters).\n */\nval shortIdentityHash: String\n    get() = identityHash.take(8)\n```\n\n## Function Design\n\n**Size Guidelines:**\n- Prefer functions under 80 lines (enforced by detekt)\n- Extract helper functions for repeated logic\n- One responsibility per function\n\n**Parameters:**\n- Max 8 parameters in regular functions, 10 in constructors (enforced by detekt)\n- Use data classes to bundle related parameters\n- Order: required params first, optional/default params last\n\n**Return Values:**\n- Prefer explicit return types on public functions\n- Max 3 return statements per function (enforced by detekt)\n- Use `sealed class` for complex return types with states: `BleConnectionsState`\n\nExample pattern from `BleConnectionInfo.kt`:\n```kotlin\nval signalQuality: SignalQuality\n    get() =\n        when {\n            rssi > -50 -> SignalQuality.EXCELLENT\n            rssi > -70 -> SignalQuality.GOOD\n            rssi > -85 -> SignalQuality.FAIR\n            else -> SignalQuality.POOR\n        }\n```\n\n## Module Design\n\n**Exports:**\n- All public classes in a module should serve a clear external API\n- Keep implementation details package-private (`internal` or default visibility)\n\n**Barrel Files:**\n- Not observed; each class in its own file\n\n**Package Organization:**\n- `data.repository`: high-level data access (repositories like `BleStatusRepository`)\n- `data.model`: data classes, enums, sealed classes representing domain concepts\n- `data.database`: Room entities, DAOs, migrations\n- `reticulum.protocol`: protocol communication abstractions\n- `di`: dependency injection (Dagger Hilt modules)\n- `service`: Android services and lifecycle management\n- `ui`: Compose screens and UI components\n\n---\n\n*Convention analysis: 2026-01-23*"}],["entry_1770158344149_ufzb0e",{"id":"entry_1770158344149_ufzb0e","key":"columba-integrations","namespace":"codebase","content":"# External Integrations\n\n**Analysis Date:** 2026-01-23\n\n## APIs & External Services\n\n**Reticulum Mesh Network:**\n- Service: Reticulum (RNS) - Decentralized wireless networking protocol\n- What it's used for: Low-bandwidth mesh networking backbone for LXMF messaging, location sharing, voice calls\n- SDK/Client: Fork at `github.com/torlando-tech/Reticulum@fix/socket-leak-1.1.3`\n- Integration: Python library embedded via Chaquopy, initialized by `ReticulumService`\n\n**LXMF Protocol:**\n- Service: Long-Range eXtensible Message Format - High-level messaging protocol built on Reticulum\n- What it's used for: Encrypted message delivery, announce/discovery, delivery receipts\n- SDK/Client: Fork at `github.com/torlando-tech/LXMF@feature/receiving-interface-capture`\n- Integration: Python library with external stamp generator for Android (bypasses multiprocessing), initialized in app startup\n\n**BLE (Bluetooth Low Energy) Reticulum Interface:**\n- Service: Reticulum BLE transports - Bluetooth mesh networking\n- What it's used for: Direct BLE communication between Android devices, no WiFi required\n- SDK/Client: Fork at `github.com/torlando-tech/ble-reticulum@main`\n- Auth: Device pairing via Bluetooth link negotiation\n- Integration: Python library + KotlinBLEBridge at `reticulum/src/main/java/com/lxmf/messenger/reticulum/ble/bridge/KotlinBLEBridge.kt`\n\n**LXST (Voice Calls):**\n- Service: Long-Range eXtensible Telephony - Voice communication over Reticulum\n- What it's used for: Low-bandwidth audio calls with codec2 compression\n- SDK/Client: Fork at `github.com/torlando-tech/LXST@chaquopy-compat`\n- Integration: Python library with Chaquopy-compatible patches\n- Auth: Uses Reticulum identity authentication\n\n**Location Services:**\n- Service: Google Play Services Location (FusedLocationProviderClient)\n- What it's used for: GPS location acquisition for location sharing feature and map centering\n- Client: `com.google.android.gms:play-services-location:21.2.0`\n- Request type: LocationRequest with configured priority and interval\n- Usage: `LocationSharingManager` (`app/src/main/java/com/lxmf/messenger/service/LocationSharingManager.kt`) and `TelemetryCollectorManager` manage requests\n\n**Maps:**\n- Service: MapLibre GL Android (OpenFreeMap tiles)\n- What it's used for: Offline-capable map display with peer locations, offline map regions downloadable\n- Client: `org.maplibre.gl:android-sdk:11.5.2`\n- Usage: `MapScreen` at `app/src/main/java/com/lxmf/messenger/ui/screens/MapScreen.kt`\n- HTTP Control: `MAP_SOURCE_HTTP_ENABLED` setting controls HTTP tile fetching (default: enabled)\n- Tiles: OpenFreeMap provides tiles over HTTP/HTTPS\n\n**QR Codes:**\n- Service: ZXing (Zebra Crossing) - QR code generation and scanning\n- What it's used for: Identity QR code generation for sharing, scanning shared identities\n- Client: `com.google.zxing:core:3.5.3`\n- Integration: CameraX pipeline for real-time scanning\n\n## Data Storage\n\n**Databases:**\n- Provider: Room (SQLite on Android)\n- Location: App-private database files (encrypted by Android)\n- Client: `androidx.room:room-runtime:2.8.4`\n- Compiler: KSP-based code generation\n\n**Primary Database Entities:**\n- `InterfaceDatabase` at `app/src/main/java/com/lxmf/messenger/data/database/InterfaceDatabase.kt` - Reticulum interface configs\n- Core entities in `data/src/main/java/com/lxmf/messenger/data/db/entity/`:\n  - `ContactEntity` - Peer contacts\n  - `ConversationEntity` - Message threads\n  - `MessageEntity` - Individual messages\n  - `LocalIdentityEntity` - User identities\n  - `PeerIdentityEntity` - Peer identities\n  - `PeerIconEntity` - Peer avatar icons (dedicated table for reliable persistence)\n  - `AnnounceEntity` - Network announcements\n  - `ReceivedLocationEntity` - Shared peer locations\n  - `OfflineMapRegionEntity` - Downloaded offline map regions\n  - `RmspServerEntity` - RMSP relay server configurations\n  - `CustomThemeEntity` - User theme customizations\n\n**File Storage:**\n- Approach: Local filesystem only\n- Android internal storage (private app data)\n- Offline map tiles cached in app-private directories\n- Backup: DataStore for encrypted settings, Room handles identity/message backup via Android Backup Service\n\n**Settings Storage:**\n- Provider: DataStore (encrypted preferences)\n- Location: App-private encrypted file\n- Client: `androidx.datastore:datastore-preferences:1.1.1`\n- Key Settings:\n  - `MAP_SOURCE_HTTP_ENABLED` - Controls HTTP tile source (true by default)\n  - `HTTP_ENABLED_FOR_DOWNLOAD` - Allows HTTP for offline map downloads\n  - `LOCATION_SHARING_ENABLED` - User location sharing master toggle\n  - `LOCATION_PRECISION_RADIUS` - Obfuscation radius in meters\n\n**Caching:**\n- Approach: In-memory (Kotlin Flow, coroutine state)\n- Image caching: Coil with GIF animation support\n- Map tiles: MapLibre handles caching\n\n## Authentication & Identity\n\n**Auth Provider:**\n- Approach: Custom Reticulum-based identity system\n- Implementation: Each user creates or imports an LXMF identity (256-bit key material)\n- Identity sharing: Deep link `lxma://` URIs for identity exchange\n- No centralized auth - identities are self-sovereign and verified via Reticulum signature validation\n\n**Credentials:**\n- Storage: Encrypted in Room database (LocalIdentityEntity)\n- Transfer: Encrypted identity files can be exported/imported via migration system\n- Signature verification: LXMF protocol validates identity signatures on messages\n\n## Monitoring & Observability\n\n**Error Tracking:**\n- Service: Sentry (GlitchTip compatible)\n- Client: `io.sentry:sentry-android:7.3.0` (both app and reticulum modules)\n- Configuration: Manual initialization in Application class (auto-init disabled in `AndroidManifest.xml`)\n- DSN: Configured via Sentry initialization (not checked into repo)\n- Usage: Crash reporting, exception tracking, KotlinBLEBridge metrics\n\n**Logs:**\n- Approach: Android Log (logcat) with contextual logging\n- Files:\n  - GW2 Debug Log: App logs to standard Android system\n  - No persistent file logging in production (logs available via adb logcat)\n- Log levels: Controlled by tag filters\n\n**Analytics:**\n- Approach: None - No telemetry collection (privacy-focused)\n- Note: TODO comment in `KotlinBLEBridge.kt` indicates future metrics infrastructure possibility (Firebase/Grafana/custom)\n\n## CI/CD & Deployment\n\n**Hosting:**\n- Platform: GitHub (source)\n- Distribution: GitHub Releases (APK artifacts)\n- Installation: Direct APK installation on Android devices\n\n**CI Pipeline:**\n- Service: GitHub Actions (`.github/workflows/`)\n- Jobs defined in `ci.yml`:\n  1. **validate-wrapper** - Gradle wrapper validation\n  2. **lint** - ktlint + detekt + CPD quality checks (runs `./gradlew ktlintCheck detektCheck cpdCheck`)\n  3. **threading-audit** - Custom dispatcher architecture audit (`audit-dispatchers.sh`)\n  4. **build** - Compile release and debug APKs\n  5. **coverage** - JaCoCo test coverage report\n  6. Upload artifacts (lint reports, APKs)\n\n**Workflows:**\n- `ci.yml` - Main CI on push/PR to main or `v*.*.x` branches\n- `build-prerelease-apk.yml` - Manual prerelease builds\n- `release.yml` - Release workflow (triggered by tags)\n\n**Signing:**\n- Method: Environment variables (CI/CD only)\n- Keystore: Base64-encoded in `KEYSTORE_FILE` secret\n- Config: `app/build.gradle.kts` decodes and configures signing\n- Release builds: Minified with ProGuard rules at `app/proguard-rules.pro`\n\n## Environment Configuration\n\n**Required env vars for builds:**\n- `ANDROID_HOME` - SDK path (e.g., `$HOME/Android/Sdk`)\n- `JAVA_HOME` - Java 17 JDK (e.g., `/usr/lib/jvm/java-17-openjdk`)\n- `PYTHON_VERSION` - Python 3.11 (Chaquopy compatibility)\n\n**Required env vars for release:**\n- `KEYSTORE_FILE` - Base64-encoded .jks file\n- `KEYSTORE_PASSWORD` - Keystore password\n- `KEY_ALIAS` - Release signing key alias\n- `KEY_PASSWORD` - Key password\n\n**Gradle configuration:**\n- `gradle.properties` sets heap size, parallel builds, worker limits\n\n**Secrets location:**\n- GitHub Actions Secrets (for CI/CD)\n- Local development: `~/.gradle/gradle.properties` or environment exports\n- Template: `.envrc.example` for direnv-based setup\n\n## Webhooks & Callbacks\n\n**Incoming Webhooks:**\n- Approach: None - App is client-only, no webhook endpoints\n\n**Outgoing Callbacks:**\n- Reticulum: Callbacks for packet/announce/link events handled by `ServiceReticulumProtocol`\n- LXMF: Delivery callbacks and message receive notifications\n- Lifecycle: Android lifecycle callbacks integrated via coroutines and Flow\n\n**USB Device Callbacks:**\n- Handler: `MainActivity` receives `UsbManager.ACTION_USB_DEVICE_ATTACHED` and `ACTION_USB_DEVICE_DETACHED` intents\n- Filter: `usb_device_filter` XML defines RNode and compatible serial device VIDs/PIDs\n- Permission: Requested via `UsbManager.requestPermission()` at runtime\n\n**BLE Callbacks:**\n- Handler: `KotlinBLEBridge` manages BLE advertisement scanning and connection callbacks\n- Metrics: Sentry integration for observability\n\n## Network Configuration\n\n**Network Permissions:**\n- INTERNET - General network access\n- ACCESS_NETWORK_STATE - Network status monitoring\n- ACCESS_WIFI_STATE - WiFi status\n- CHANGE_WIFI_STATE - WiFi enable/disable (if needed)\n- CHANGE_WIFI_MULTICAST_STATE - Multicast for mesh discovery\n\n**Foreground Services:**\n- `ReticulumService` runs as foreground service with notification\n- Permissions: `FOREGROUND_SERVICE`, `FOREGROUND_SERVICE_DATA_SYNC`, `FOREGROUND_SERVICE_CONNECTED_DEVICE`, `FOREGROUND_SERVICE_MICROPHONE`\n\n**Special Requirements:**\n- Battery Optimization Exemption: `REQUEST_IGNORE_BATTERY_OPTIMIZATIONS` for background mesh networking\n- Companion Device Manager: RNode device association (Android 12+)\n\n---\n\n*Integration audit: 2026-01-23*"}],["entry_1770158345084_43qe7",{"id":"entry_1770158345084_43qe7","key":"columba-stack","namespace":"codebase","content":"# Technology Stack\n\n**Analysis Date:** 2026-01-23\n\n## Languages\n\n**Primary:**\n- Kotlin 2.2.21 - Main application language (Android app, data layer, reticulum module)\n- Java 17 - Compilation target and compatibility\n- Python 3.11 - Reticulum networking, LXST voice calls, codec2 audio processing\n\n**Secondary:**\n- XML - Android manifest, layout resources, configuration files\n- YAML - Gradle configuration, Detekt rules, GitHub Actions workflows\n\n## Runtime\n\n**Environment:**\n- Android Runtime (targets API 35, minimum API 24)\n- Chaquopy 16.0.0 - Python interpreter embedded in Android app\n\n**Package Manager:**\n- Gradle 8.7.3 (wrapper at `./gradlew`)\n- Lockfile: `gradle/wrapper/gradle-wrapper.properties`\n- pip (for Python dependencies installed via Chaquopy)\n- NPM/npm - Not used\n\n## Frameworks\n\n**Core Android:**\n- Android SDK 35 (compileSdk)\n- AndroidX 1.0+\n- Jetpack Compose 1.7.5 - UI framework (338+ Composable functions)\n\n**Architecture & Dependency Injection:**\n- Hilt 2.57.2 - Dependency injection framework\n- KSP (Kotlin Symbol Processing) 2.2.20-2.0.4 - Code generation for Hilt\n\n**State Management & Data:**\n- Room 2.8.4 - SQLite database ORM\n- DataStore 1.1.1 - Preferences and settings (encrypted)\n- Paging 3.3.6 - List pagination\n- Coroutines 1.10.2 - Async/concurrent operations\n- Lifecycle 2.8.7 - Lifecycle-aware components\n\n**Navigation:**\n- Jetpack Navigation 2.8.4 - Compose navigation\n\n**Testing:**\n- JUnit 4.13.2 - Unit test framework\n- JUnit Jupiter 5.11.4 - Parameterized test support\n- Robolectric 4.16 - Android unit test runtime\n- Mockk 1.14.7 - Kotlin mocking library\n- Turbine 1.2.1 - Flow testing utilities\n- Espresso 3.6.1 - Instrumented UI testing\n- JaCoCo 0.8.14 - Code coverage\n\n**Build & Quality:**\n- ktlint 1.0.1 - Kotlin code linting\n- Detekt 1.23.8 - Static analysis (custom Columba rules in `detekt-rules/`)\n- CPD 7.7.0 - Copy-paste detection\n- detekt-rules module - Custom Kotlin analysis rules\n\n## Key Dependencies\n\n**Critical:**\n- Chaquopy 16.0.0 - Bridges Kotlin and Python for Reticulum mesh networking\n- Android Python Wheels - Pre-built arm64 Python packages (pycodec2 4.1.1)\n- usb-serial-for-android 3.7.0 - Serial USB support (FTDI, CP210x, PL2303, CH340, CDC-ACM protocols)\n- sentry-android 7.3.0 - Crash reporting and observability (GlitchTip compatible)\n\n**Messaging & Networking:**\n- Reticulum (RNS 1.1.3) - Fork at `torlando-tech/Reticulum@fix/socket-leak-1.1.3` with socket leak fix and shared instance RPC error handling\n- LXMF - Fork at `torlando-tech/LXMF@feature/receiving-interface-capture` with external stamp generator and receiving interface capture\n- LXST - Fork at `torlando-tech/LXST@chaquopy-compat` with Chaquopy compatibility patches\n- ble-reticulum - Git fork at `torlando-tech/ble-reticulum@main`\n- u-msgpack-python - MessagePack serialization for Sideband-compatible telemetry\n- MessagePack 0.9.10 (JVM) and msgpack-core 0.9.8 (for LXMF stamp generation)\n\n**Hardware & Sensors:**\n- CameraX 1.5.2 (core, camera2, lifecycle, view) - Camera API abstraction\n- Google Play Services Location 21.2.0 - FusedLocationProviderClient for location sharing and map features\n- MapLibre 11.5.2 - Offline-capable maps\n- ZXing 3.5.3 - QR code encoding/decoding\n- Lucide Icons 1.1.0 - Icon library\n\n**Media & UI:**\n- Coil 2.6.0 - Image loading with GIF animation support\n- Material Icons Extended - Additional Material Design icons\n- Compose Material3 - Material Design 3 components\n\n**Serialization:**\n- kotlinx-serialization-json 1.9.0 - Kotlin JSON serialization (migration export/import)\n- org.json 20231013/20240303 - Real JSON for unit tests\n\n**Python Dependencies (installed via Chaquopy):**\n- numpy - Audio processing dependency for LXST\n- cryptography >=42.0.0 - Encryption for Reticulum\n- pycodec2 4.1.1 - Pre-built wheel for audio codec (pure Python ctypes wrapper)\n- audioop - Built-in on Python 3.11 (codec audio processing)\n\n## Configuration\n\n**Environment:**\n- `.envrc.example` - Template for direnv-based configuration\n- Environment variables required for CI/CD:\n  - `ANDROID_HOME` - Android SDK location\n  - `JAVA_HOME` - Java 17 JDK path\n  - `KEYSTORE_FILE` - Base64-encoded keystore for release signing\n  - `KEYSTORE_PASSWORD` - Keystore password\n  - `KEY_ALIAS` - Release key alias\n  - `KEY_PASSWORD` - Key password\n\n**Build:**\n- `build.gradle.kts` - Root project configuration with JaCoCo, ktlint, detekt, CPD\n- `app/build.gradle.kts` - App module with Compose, Chaquopy, Hilt, testing config\n- `data/build.gradle.kts` - Data layer with Room, Hilt, coroutines\n- `reticulum/build.gradle.kts` - Reticulum integration with Python, USB serial, BLE\n- `gradle/libs.versions.toml` - Centralized dependency versions\n- `gradle.properties` - JVM args, parallel builds, Kotlin code style\n- `detekt-config.yml` - Static analysis rules (`detekt-baseline.xml` captures pre-existing issues)\n\n**Kotlin Compiler:**\n- Target: JVM 17\n- Kotlin code style: official\n- Compose compiler extension: 1.7.5\n\n**Android Configuration:**\n- Namespace: `com.lxmf.messenger`\n- Application ID: `com.lxmf.messenger`\n- Supported ABIs: arm64-v8a (64-bit only, x86_64 disabled due to pycodec2 wheel resolution)\n- Features: Compose enabled, AIDL enabled, BuildConfig enabled\n- Resources: R class namespacing enabled, AndroidX enabled\n\n## Platform Requirements\n\n**Development:**\n- Android SDK 35 or later\n- Java 17 JDK (OpenJDK or compatible)\n- Python 3.8-3.11 (build-time, for Chaquopy compatibility detection)\n- Gradle 8.7.3\n- Git 2.x+ (for version detection via tags)\n\n**Production (Runtime):**\n- Android 6.0+ (API 24 minimum)\n- Android 15 (API 35 target)\n- ARM64 CPU (v8a)\n- 100+ MB storage for app and offline maps\n- Network: WiFi or mobile data for Reticulum mesh networking\n\n---\n\n*Stack analysis: 2026-01-23*"}],["entry_1770158345981_93dwcd",{"id":"entry_1770158345981_93dwcd","key":"columba-structure","namespace":"codebase","content":"# Codebase Structure\n\n**Analysis Date:** 2026-01-23\n\n## Directory Layout\n\n```\ncolumba/\n├── app/                              # Main UI application module (Android app)\n│   ├── src/\n│   │   ├── main/\n│   │   │   ├── java/com/lxmf/messenger/\n│   │   │   │   ├── ui/                       # Compose screens, components, themes\n│   │   │   │   ├── viewmodel/                # MVVM state holders\n│   │   │   │   ├── service/                  # Background service & managers\n│   │   │   │   ├── repository/               # Data access patterns\n│   │   │   │   ├── data/                     # Local models and config\n│   │   │   │   ├── reticulum/                # Protocol implementation & BLE\n│   │   │   │   ├── util/                     # Utilities (validation, crypto, etc.)\n│   │   │   │   ├── migration/                # Data migration logic\n│   │   │   │   ├── startup/                  # Initialization managers\n│   │   │   │   ├── notifications/            # Notification & call handling\n│   │   │   │   ├── crypto/                   # Cryptographic utilities\n│   │   │   │   ├── map/                      # Map feature logic\n│   │   │   │   ├── MainActivity.kt           # Main entry point\n│   │   │   │   └── ColumbaApplication.kt     # Application initialization\n│   │   │   ├── res/                          # Resources (drawables, strings, XML)\n│   │   │   ├── aidl/                         # AIDL service interface definitions\n│   │   │   └── AndroidManifest.xml           # App manifest\n│   │   ├── test/                             # Unit tests (local, in-process)\n│   │   └── androidTest/                      # Instrumented tests (device/emulator)\n│   └── build.gradle.kts                      # App module build config\n│\n├── data/                             # Data layer library module\n│   ├── src/\n│   │   ├── main/\n│   │   │   ├── java/com/lxmf/messenger/data/\n│   │   │   │   ├── db/                       # Room database schema\n│   │   │   │   │   ├── ColumbaDatabase.kt\n│   │   │   │   │   ├── dao/                  # Data Access Objects\n│   │   │   │   │   └── entity/               # Room entity definitions\n│   │   │   │   ├── repository/               # Data repository implementations\n│   │   │   │   ├── model/                    # Data models\n│   │   │   │   ├── storage/                  # Shared preferences & DataStore\n│   │   │   │   └── di/                       # Data layer DI (DatabaseModule)\n│   │   └── test/                             # Data layer unit tests\n│   └── build.gradle.kts                      # Data module build config\n│\n├── reticulum/                        # Reticulum library module (networking)\n│   ├── src/\n│   │   ├── main/\n│   │   │   ├── java/com/lxmf/messenger/reticulum/\n│   │   │   │   ├── protocol/                 # Protocol abstraction & implementations\n│   │   │   │   ├── model/                    # Domain models (Identity, Destination, etc.)\n│   │   │   │   ├── ble/                      # Bluetooth Low Energy bridge\n│   │   │   │   ├── rnode/                    # RNode radio device support\n│   │   │   │   ├── usb/                      # USB serial communication\n│   │   │   │   ├── bridge/                   # Python bridge layer\n│   │   │   │   ├── audio/                    # Voice call audio handling\n│   │   │   │   ├── call/                     # LXST telephony (voice calls)\n│   │   │   │   └── util/                     # Protocol utilities\n│   │   └── test/                             # Reticulum module tests\n│   └── build.gradle.kts                      # Reticulum module build config\n│\n├── domain/                           # Domain module (empty structure, reserved)\n│   └── build.gradle.kts              # Domain module placeholder\n│\n├── detekt-rules/                     # Custom Detekt linting rules\n│   ├── src/\n│   │   └── main/kotlin/\n│   │       └── com/lxmf/messenger/detekt/\n│   └── build.gradle.kts\n│\n├── gradle/                           # Gradle wrapper scripts\n├── build.gradle.kts                  # Root build config (Kotlin DSL)\n├── settings.gradle.kts               # Gradle settings (module definitions)\n├── gradle.properties                 # Gradle properties (versions, flags)\n├── .editorconfig                     # IDE formatter settings\n├── detekt-config.yml                 # Detekt static analysis config\n├── .codecov.yml                      # Code coverage config\n└── CLAUDE.md                         # Project-specific instructions\n```\n\n## Directory Purposes\n\n**app/**\n- Purpose: Main application UI and orchestration\n- Contains: Kotlin Android code (Activities, ViewModels, Composables), Resources, Manifests\n- Key files: `MainActivity.kt`, `ColumbaApplication.kt`, `AndroidManifest.xml`\n\n**data/**\n- Purpose: Data layer abstraction and persistence\n- Contains: Room database, DAOs, repositories, data models, configuration storage\n- Key files: `ColumbaDatabase.kt`, entity classes, repository implementations\n\n**reticulum/**\n- Purpose: Network protocol implementation and radio device integration\n- Contains: Reticulum protocol contract, BLE/RNode/USB bridges, networking models\n- Key files: `ReticulumProtocol.kt`, `ServiceReticulumProtocol.kt`, device-specific bridges\n\n**detekt-rules/**\n- Purpose: Custom static analysis rules (pure JVM, not Android)\n- Contains: Detekt rule implementations for project-specific linting\n- Key files: Custom rule classes in Kotlin\n\n## Key File Locations\n\n**Entry Points:**\n- `app/src/main/java/com/lxmf/messenger/MainActivity.kt`: Main activity launcher\n- `app/src/main/java/com/lxmf/messenger/ColumbaApplication.kt`: Application initialization\n- `app/src/main/java/com/lxmf/messenger/service/ReticulumService.kt`: Background service\n\n**Configuration:**\n- `app/src/main/AndroidManifest.xml`: Permissions, intent filters, service definitions\n- `build.gradle.kts`: Root build script (plugin versions, detekt config)\n- `gradle.properties`: Version constants, project flags\n- `detekt-config.yml`: Code quality rules (advisory, not enforced)\n\n**Core Logic:**\n- `data/src/main/java/com/lxmf/messenger/data/db/ColumbaDatabase.kt`: Database schema\n- `app/src/main/java/com/lxmf/messenger/repository/`: Repository layer (conversations, identities, settings)\n- `app/src/main/java/com/lxmf/messenger/service/manager/`: Service managers (messaging, health, BLE)\n- `reticulum/src/main/java/com/lxmf/messenger/reticulum/protocol/ReticulumProtocol.kt`: Protocol contract\n\n**Testing:**\n- `app/src/test/`: Unit tests (JVM, mocked Android, no device needed)\n- `app/src/androidTest/`: Instrumented tests (require device/emulator)\n- `app/src/test/java/com/lxmf/messenger/test/`: Test fixtures and helpers\n- Test fixture location: `app/src/test/java/com/lxmf/messenger/test/` (e.g., `BleTestFixtures.kt`)\n\n## Naming Conventions\n\n**Files:**\n- Activities: `*Activity.kt` (e.g., `MainActivity.kt`)\n- ViewModels: `*ViewModel.kt` (e.g., `ChatsViewModel.kt`)\n- Repositories: `*Repository.kt` (e.g., `ConversationRepository.kt`)\n- Services: `*Service.kt` (e.g., `ReticulumService.kt`)\n- Managers: `*Manager.kt` (e.g., `HealthCheckManager.kt`, `PythonWrapperManager.kt`)\n- DAOs: `*Dao.kt` (e.g., `MessageDao.kt`, `ConversationDao.kt`)\n- Entities: `*Entity.kt` (e.g., `MessageEntity.kt`, `ConversationEntity.kt`)\n- Models: `*.kt` with domain name (e.g., `Identity.kt`, `Destination.kt`)\n- Screens/Composables: `*Screen.kt` or `*Composable.kt` (e.g., `ChatsScreen.kt`, `IdentityCard.kt`)\n- Tests: `*Test.kt` for unit tests (e.g., `BleConnectionInfoTest.kt`)\n- Test fixtures: `*TestFixtures.kt` or `*Fixtures.kt` (e.g., `BleTestFixtures.kt`)\n\n**Directories:**\n- Package structure mirrors domain: `com.lxmf.messenger.[feature]`\n- Feature-specific packages group related code (e.g., `ui.screens.rnode`, `service.manager`)\n- Test directories mirror source structure: `app/src/test/java/com/lxmf/messenger/[mirror-of-main]`\n\n## Where to Add New Code\n\n**New Feature (UI + Logic):**\n- Primary code: `app/src/main/java/com/lxmf/messenger/ui/screens/[feature]/` for screens\n- ViewModel: `app/src/main/java/com/lxmf/messenger/viewmodel/[Feature]ViewModel.kt`\n- Repository: `data/src/main/java/com/lxmf/messenger/data/repository/[Feature]Repository.kt`\n- Tests: Mirror structure under `app/src/test/java/` and `app/src/androidTest/java/`\n\n**New Network Protocol Feature:**\n- Implementation: `reticulum/src/main/java/com/lxmf/messenger/reticulum/[feature]/`\n- Models: `reticulum/src/main/java/com/lxmf/messenger/reticulum/model/[Model].kt`\n- Tests: `reticulum/src/test/java/com/lxmf/messenger/reticulum/[feature]/`\n\n**New Component/Composable:**\n- Implementation: `app/src/main/java/com/lxmf/messenger/ui/components/[ComponentName].kt`\n- Models: `app/src/main/java/com/lxmf/messenger/ui/model/[ComponentModel].kt`\n\n**Utilities:**\n- Shared helpers: `app/src/main/java/com/lxmf/messenger/util/`\n- Validation logic: `app/src/main/java/com/lxmf/messenger/util/validation/`\n- Reticulum utilities: `reticulum/src/main/java/com/lxmf/messenger/reticulum/util/`\n\n**Database Changes:**\n- Entity: Add to `data/src/main/java/com/lxmf/messenger/data/db/entity/[EntityName].kt`\n- DAO: Add to `data/src/main/java/com/lxmf/messenger/data/db/dao/[EntityName]Dao.kt`\n- Migration: Add `MIGRATION_X_Y` in `data/src/main/java/com/lxmf/messenger/data/di/DatabaseModule.kt`\n- Update: `ColumbaDatabase.version++`, add new entity to @Database annotation\n\n**Service Managers (Background Process):**\n- Manager: `app/src/main/java/com/lxmf/messenger/service/manager/[Feature]Manager.kt`\n- Register: Add to `ServiceModule.createManagers()` in `app/src/main/java/com/lxmf/messenger/service/di/ServiceModule.kt`\n\n## Special Directories\n\n**res/ Directory:**\n- Purpose: Android resources (strings, drawables, layouts, colors, fonts)\n- Generated: No, all committed\n- Committed: Yes\n\n**build/ Directory:**\n- Purpose: Build output and intermediate files\n- Generated: Yes, created by Gradle\n- Committed: No (in .gitignore)\n\n**src/test/resources/**\n- Purpose: Test-specific resource files\n- Generated: No, manually created for tests\n- Committed: Yes\n\n**src/androidTest/**\n- Purpose: Instrumented tests requiring device/emulator\n- Contents: Integration tests, UI tests, database tests\n- Example: `ServiceProcessInitializationTest.kt`, `PythonThreadSafetyTest.kt`\n\n---\n\n*Structure analysis: 2026-01-23*"}],["entry_1770158346841_ps5zjo",{"id":"entry_1770158346841_ps5zjo","key":"columba-testing","namespace":"codebase","content":"# Testing Patterns\n\n**Analysis Date:** 2026-01-23\n\n## Test Framework\n\n**Runner:**\n- JUnit 4 with Robolectric for unit tests\n- AndroidJUnit4 (AndroidX Test) for instrumentation tests\n- Config: `app/build.gradle.kts` specifies `AndroidJUnitRunner`\n\n**Assertion Library:**\n- `org.junit.Assert.*` for all assertions\n- Common: `assertEquals()`, `assertTrue()`, `assertFalse()`, `assertNull()`, `assertNotNull()`\n\n**Async/Coroutine Testing:**\n- `kotlinx.coroutines.test.runTest` for coroutine-based tests\n- `@OptIn(ExperimentalCoroutinesApi::class)` annotation required\n- `InstantTaskExecutorRule` for LiveData/Flow testing: `@get:Rule val instantExecutorRule = InstantTaskExecutorRule()`\n- Test dispatcher setup: `val testDispatcher = StandardTestDispatcher()`\n\n**Run Commands:**\n```bash\n./gradlew testDebugUnitTest              # Run all unit tests\n./gradlew testDebugUnitTest --watch      # Watch mode (if supported)\n./gradlew jacocoTestReport               # Generate unified coverage report\n./gradlew :app:testDebugUnitTest         # Run tests for app module only\n./gradlew connectedAndroidTest           # Run instrumentation tests on device\n```\n\n## Test File Organization\n\n**Location:**\n- **Unit tests**: `app/src/test/java/com/lxmf/messenger/{feature}/` (co-located by feature)\n- **Instrumentation tests**: `app/src/androidTest/java/com/lxmf/messenger/{feature}/`\n- Tests live in same package structure as production code\n\n**Naming:**\n- `{ClassName}Test.kt` for standard unit tests\n- `{ClassName}{Scenario}Test.kt` for scenario-specific tests (e.g., `InterfaceDatabaseRaceConditionTest.kt`)\n- Test classes: `class {Name}Test { ... }`\n\n**Structure:**\n```\napp/src/\n├── test/java/com/lxmf/messenger/            # Unit tests\n│   ├── data/\n│   │   ├── MessageOrderingTest.kt\n│   │   ├── model/\n│   │   │   └── ModemPresetTest.kt\n│   │   └── repository/\n│   │       └── ConversationRepositoryTest.kt\n│   ├── service/\n│   ├── util/\n│   └── viewmodel/\n├── androidTest/java/com/lxmf/messenger/     # Integration/instrumentation tests\n│   ├── data/database/\n│   │   └── InterfaceDatabaseRaceConditionTest.kt\n│   ├── initialization/\n│   └── ui/\n└── main/\n```\n\n## Test Structure\n\n**Suite Organization:**\n```kotlin\n@OptIn(ExperimentalCoroutinesApi::class)\nclass MessageOrderingTest {\n    @get:Rule\n    val instantExecutorRule = InstantTaskExecutorRule()\n\n    private lateinit var conversationRepository: ConversationRepository\n    private val testPeerHash = \"abcd1234\"\n    private val testPeerName = \"Test Peer\"\n\n    @Before\n    fun setup() {\n        conversationRepository = mockk(relaxed = true)\n    }\n\n    @After\n    fun tearDown() {\n        clearAllMocks()\n    }\n\n    @Test\n    fun `test description in backticks`() = runTest {\n        // Arrange\n        val expected = listOf(/* data */)\n\n        // Act\n        val result = conversationRepository.getMessages(testPeerHash).first()\n\n        // Assert\n        assertEquals(expected, result)\n    }\n}\n```\n\n**Patterns:**\n- `@Before` setup: Initialize mocks and test fixtures\n- `@After` teardown: Clear mocks with `clearAllMocks()`, reset dispatchers with `Dispatchers.resetMain()`\n- Backtick test names: `` `describe behavior in natural language`() ``\n- Comments in test names: Avoid; use descriptive names instead\n- Comments in setup: Explain non-obvious test data creation\n\n**Test Organization within Files:**\n- Group related tests with section comments: `// ========== Scenario Name Tests ==========`\n- Arrange-Act-Assert pattern (AAA):\n  - Arrange: Setup test data and mocks\n  - Act: Call the code being tested\n  - Assert: Verify results with assertions and explanatory messages\n\n## Mocking\n\n**Framework:** `io.mockk.mockk` (MockK)\n\n**Patterns:**\n```kotlin\n// Create relaxed mock (no need to specify every call)\nval mockRepository: ConversationRepository = mockk(relaxed = true)\n\n// Specify return value for function\nevery { mockRepository.getMessages(testPeerHash) } returns flowOf(messages)\n\n// Verify function was called\ncoVerify { mockRepository.saveMessage(message) }\n\n// Clear all mocks after test\nclearAllMocks()\n```\n\n**What to Mock:**\n- External dependencies: repositories, services, DAOs, network clients\n- Complex objects with many dependencies\n- Android system services passed as parameters\n- Any class marked with `@Inject` (dependencies)\n\n**What NOT to Mock:**\n- Pure data classes: `BleConnectionInfo`, `Message`, `ModemPreset`\n- Simple enums and sealed classes used as return types\n- Model objects created in test (use real instances)\n- Value objects representing test data\n\n**Mocking Async Code:**\n```kotlin\n// For suspend functions\ncoEvery { mockDao.messageExists(id, hash) } returns false\n\n// For Flow-returning functions\nevery { mockRepository.getMessages(hash) } returns flowOf(messages)\n\n// For LiveData (rarely used)\nevery { mockLiveData.value } returns expectedValue\n```\n\n**Mock Verification:**\n```kotlin\n// Verify was called with specific args\ncoVerify { mockDao.insert(message) }\n\n// Verify was called N times\ncoVerify(exactly = 1) { mockDao.saveMessage(any()) }\n\n// Verify was NOT called\ncoVerify(inverse = true) { mockDao.delete(any()) }\n```\n\n## Fixtures and Factories\n\n**Test Data:**\n```kotlin\n// In-test data creation - simple cases\nprivate val testPeerHash = \"abcd1234\"\nprivate val testPeerName = \"Test Peer\"\n\nprivate val testIdentity = LocalIdentityEntity(\n    identityHash = testIdentityHash,\n    displayName = \"Test Identity\",\n    destinationHash = \"dest_hash\",\n    filePath = \"/path/to/identity\",\n    createdTimestamp = 1000L,\n    lastUsedTimestamp = 2000L,\n    isActive = true,\n)\n\n// Inline list creation in test\nval messages = listOf(\n    DataMessage(\n        id = \"msg1\",\n        destinationHash = testPeerHash,\n        content = \"First message\",\n        timestamp = 1000L,\n        isFromMe = false,\n        status = \"delivered\",\n    ),\n    DataMessage(\n        id = \"msg2\",\n        destinationHash = testPeerHash,\n        content = \"Second message\",\n        timestamp = 2000L,\n        isFromMe = true,\n        status = \"sent\",\n    ),\n)\n```\n\n**Location:**\n- Test fixtures defined in `@Before` setup method or as class properties\n- Simple constants as private class properties: `private val testPeerHash = \"abcd1234\"`\n- Complex fixtures created in individual test methods when only used once\n\n**Factory Pattern (implicit):**\n- No dedicated factory classes found\n- Test data constructed inline in tests\n- Benefit: Test data is self-documenting; readers see exact structure being tested\n\n## Coverage\n\n**Requirements:** No minimum coverage enforced (advisory mode)\n\n**View Coverage:**\n```bash\n./gradlew jacocoTestReport\n# HTML report: app/build/reports/jacoco/jacocoTestReport/html/index.html\n```\n\n**Exclusions from Coverage** (in `build.gradle.kts`):\n- Generated classes: `R.class`, `BuildConfig.*`, `Manifest*.*`\n- Hilt-generated: `Hilt_*.*`, `*_Factory.*`, `*_MembersInjector.*`\n- Test classes: `**/*Test*.*`\n- Only debug unit tests included (Robolectric issues with release builds)\n\n## Test Types\n\n**Unit Tests:**\n- Scope: Single class or function in isolation with mocked dependencies\n- Location: `app/src/test/java/`\n- Examples:\n  - `MessageOrderingTest.kt` - Tests message ordering logic with mocked repository\n  - `ModemPresetTest.kt` - Tests enum matching and validation\n  - `ConversationRepositoryTest.kt` - Tests repository with mocked DAOs\n\n**Integration Tests:**\n- Scope: Multiple components working together; can use real database/objects\n- Location: `app/src/androidTest/java/`\n- Examples:\n  - `InterfaceDatabaseRaceConditionTest.kt` - Tests Room database with real schema\n  - `BlePermissionRestartTest.kt` - Tests BLE permission handling across app lifecycle\n  - `ServiceProcessInitializationTest.kt` - Tests service startup sequence\n\n**E2E Tests:**\n- Not observed in current codebase\n- Would test full app flows from UI through all layers\n\n## Common Patterns\n\n**Async Testing:**\n```kotlin\n@Test\nfun `async operation completes`() = runTest {\n    // runTest provides TestScope with test dispatcher\n\n    // Act: Call suspend function\n    val result = repository.getMessages(hash).first()\n\n    // Assert\n    assertEquals(expected, result)\n}\n```\n\n**Error Testing:**\n```kotlin\n@Test\nfun `invalid preset parameters return null`() {\n    val preset = ModemPreset.findByParams(\n        spreadingFactor = 12,\n        bandwidth = 500_000,  // Invalid combination\n        codingRate = 5,\n    )\n    assertNull(preset)\n}\n\n@Test\nfun `error parsing JSON returns empty list`() = runTest {\n    every { mockRepository.getMessages(any()) } throws Exception(\"Invalid JSON\")\n\n    val result = repository.parseConnectionsJson(invalidJson)\n\n    assertEquals(emptyList(), result)\n}\n```\n\n**State Machine / Flow Testing:**\n```kotlin\n@Test\nfun `state transitions correctly`() = runTest {\n    val state = BleConnectionsState.Loading\n\n    // Act: Trigger state change\n    val nextState = when (state) {\n        BleConnectionsState.BluetoothDisabled -> BleConnectionsState.Loading\n        BleConnectionsState.Loading -> BleConnectionsState.Success(emptyList())\n        else -> state\n    }\n\n    // Assert\n    assertTrue(nextState is BleConnectionsState.Success)\n}\n```\n\n**Collection Validation:**\n```kotlin\n@Test\nfun `rapid message exchange maintains correct order`() = runTest {\n    val result = repository.getMessages(hash).first()\n\n    // Verify size\n    assertEquals(5, result.size)\n\n    // Verify ordering\n    for (i in 0 until result.size - 1) {\n        assertTrue(\n            \"Message $i should come before ${i + 1}\",\n            result[i].timestamp < result[i + 1].timestamp,\n        )\n    }\n}\n```\n\n**Scenario-Based Test with Narrative:**\n```kotlin\n@Test\nfun `received messages use local reception time not sender time`() = runTest {\n    // This test verifies the fix for clock skew issues\n    // Scenario:\n    // - User A sends message at 10:00:00 (their time)\n    // - User B's clock is 30 seconds behind\n    // - User B receives message at 09:59:40 (their time, if using sender's timestamp)\n    // - User B replies at 09:59:50 (their time)\n    //\n    // BUG (before fix): Reply appears ABOVE the original message (09:59:50 > 09:59:40)\n    // FIX (after fix): Reply appears BELOW using local reception time\n\n    val currentTime = System.currentTimeMillis()\n\n    val receivedMessage = DataMessage(\n        id = \"msg1\",\n        destinationHash = testPeerHash,\n        content = \"Message from A\",\n        timestamp = currentTime - 100,\n        isFromMe = false,\n        status = \"delivered\",\n    )\n\n    val sentMessage = DataMessage(\n        id = \"msg2\",\n        destinationHash = testPeerHash,\n        content = \"Reply from B\",\n        timestamp = currentTime,\n        isFromMe = true,\n        status = \"sent\",\n    )\n\n    every { mockRepository.getMessages(testPeerHash) } returns flowOf(listOf(receivedMessage, sentMessage))\n\n    val result = mockRepository.getMessages(testPeerHash).first()\n\n    assertEquals(2, result.size)\n    assertTrue(\"Received message should come first\", result[0].timestamp < result[1].timestamp)\n    assertFalse(\"First message is from peer\", result[0].isFromMe)\n    assertTrue(\"Second message is from me\", result[1].isFromMe)\n}\n```\n\n## Test Discipline\n\n**Golden Rules:**\n- Tests MUST execute production code - no mocking the entire system being tested\n- Tests fail if production code breaks, not due to test setup fragility\n- Clear test names that read like requirements: `` `messages ordered by timestamp`() ``\n- Comprehensive assertions with meaningful failure messages\n\n**Ignored Tests:**\n- `@Ignore(\"Reason\")` used for flaky timing-sensitive tests\n- Example: `InterfaceDatabaseRaceConditionTest.kt` marks timing test as ignored (flaky on CI with resource constraints)\n\n---\n\n*Testing analysis: 2026-01-23*"}],["entry_1770158347708_m7zgv",{"id":"entry_1770158347708_m7zgv","key":"columba-project","namespace":"codebase","content":"# Columba\n\n## What This Is\n\nColumba is an Android LXMF messenger built on the Reticulum mesh networking stack. It bridges Python (Reticulum/LXMF) with Kotlin via Chaquopy, supporting BLE, USB, and TCP interfaces for off-grid and resilient communication.\n\n## Core Value\n\nReliable off-grid messaging with a polished, responsive user experience.\n\n## Requirements\n\n### Validated\n\n- ✓ Multi-process architecture (UI + service) — existing\n- ✓ LXMF messaging over Reticulum — existing\n- ✓ BLE, USB (RNode), TCP interface support — existing\n- ✓ Interface Discovery feature — v0.7.2\n- ✓ Auto-relay selection — existing\n- ✓ **PERF-01**: App maintains responsive UI regardless of background operations — v0.7.3\n- ✓ **PERF-02**: No progressive performance degradation over app runtime — v0.7.3\n- ✓ **PERF-03**: Interface Discovery screen scrolls smoothly — v0.7.3\n- ✓ **RELAY-01**: Relay auto-selection does not loop (add/remove/add cycle) — v0.7.3\n- ✓ **RELAY-02**: Root cause of automatic relay unset identified and fixed — v0.7.3\n- ✓ **ANNOUNCE-01**: Clear All Announces preserves contacts in My Contacts — v0.7.3\n- ✓ **OFFLINE-MAP-01**: Offline maps render correctly after extended offline periods — v0.7.3\n- ✓ **UX-LOADING-01**: Show loading indicators instead of flashing empty states — v0.7.3\n\n### Active\n\n- [ ] **NOTF-01**: No duplicate notifications after service restart for already-read messages (#338)\n- [ ] **PERM-01**: Location permission dialog stays dismissed until app restart (#342)\n- [ ] Native memory growth investigation (~1.4 MB/min in Python layer)\n\n### Out of Scope\n\n- iOS version — Android-first approach\n- Desktop version — mobile focus\n\n## Context\n\n**Current State (v0.7.3):**\n- ~205K lines of Kotlin\n- Tech stack: Kotlin, Compose, Hilt, Room, Chaquopy (Python bridge)\n- Sentry performance monitoring integrated (10% transactions, 5% profiling)\n- 137 commits, 107 files changed since v0.7.2-beta\n\n**Known Issues:**\n- Native memory growth (~1.4 MB/min) in Python/Reticulum layer — needs tracemalloc investigation\n- PropagationNodeManager is large class — could extract RelaySelectionStateMachine\n\n## Constraints\n\n- **Platform**: Android 6.0+ (API 24), ARM64 only\n- **Architecture**: Must not break multi-process service model\n- **Testing**: Changes should be testable without requiring physical hardware where possible\n\n## Key Decisions\n\n| Decision | Rationale | Outcome |\n|----------|-----------|---------|\n| Focus on #340 and #343 first | Highest user impact, both high severity | ✓ Fixed in v0.7.3 |\n| Defer #338 and #342 | Lower severity, can address in next milestone | — Active for v0.7.4 |\n| State machine for relay selection | Explicit states prevent re-entrancy bugs | ✓ Loop eliminated |\n| 1s debounce + 30s cooldown | Prevents rapid Room invalidation triggers | ✓ No cascading |\n| Exponential backoff on loop detection | Graceful degradation if edge cases occur | ✓ Good |\n| @Stable annotations for Compose | Reduces unnecessary recompositions | ✓ Smooth scrolling |\n| SQL subquery for contact-aware delete | More efficient than app-side filtering | ✓ Good |\n| Cache MapLibre style JSON locally | Enables indefinite offline map rendering | ✓ Good |\n| Boolean isLoading flag pattern | Consistent with existing MapViewModel | ✓ Good |\n\n---\n*Last updated: 2026-01-28 after v0.7.3 milestone*"}],["entry_1770158427251_d1d41",{"id":"entry_1770158427251_d1d41","key":"columba-ble-architecture","namespace":"codebase","content":"# Columba BLE Architecture Documentation\n\nThis document describes the complete Bluetooth Low Energy (BLE) architecture for Reticulum networking on Android, covering all layers from Python protocol handling through native Android BLE operations.\n\n## Architecture Overview\n\nThe BLE implementation follows a layered architecture with clear separation of concerns:\n\n```mermaid\nflowchart TB\n    subgraph Python[\"Python Layer (ble-reticulum)\"]\n        BLEInterface[\"BLEInterface<br/>Protocol handler, fragmentation,<br/>peer lifecycle\"]\n        BLEPeerInterface[\"BLEPeerInterface<br/>Per-peer Reticulum interface\"]\n        AndroidDriver[\"AndroidBLEDriver<br/>Chaquopy bridge to Kotlin\"]\n    end\n\n    subgraph Kotlin[\"Kotlin Native Layer\"]\n        Bridge[\"KotlinBLEBridge<br/>Main entry point,<br/>PeerInfo tracking,<br/>deduplication\"]\n        Scanner[\"BleScanner<br/>Adaptive intervals,<br/>service filtering\"]\n        Advertiser[\"BleAdvertiser<br/>Identity naming,<br/>proactive refresh\"]\n        GattClient[\"BleGattClient<br/>Central mode,<br/>4-step handshake\"]\n        GattServer[\"BleGattServer<br/>Peripheral mode,<br/>GATT service\"]\n        OpQueue[\"BleOperationQueue<br/>Serialized GATT ops\"]\n    end\n\n    subgraph Android[\"Android BLE Stack\"]\n        BluetoothAdapter[\"BluetoothAdapter\"]\n        BluetoothLeScanner[\"BluetoothLeScanner\"]\n        BluetoothLeAdvertiser[\"BluetoothLeAdvertiser\"]\n        BluetoothGatt[\"BluetoothGatt\"]\n        BluetoothGattServer[\"BluetoothGattServer\"]\n    end\n\n    BLEInterface --> BLEPeerInterface\n    BLEInterface --> AndroidDriver\n    AndroidDriver -->|Chaquopy| Bridge\n    Bridge --> Scanner\n    Bridge --> Advertiser\n    Bridge --> GattClient\n    Bridge --> GattServer\n    GattClient --> OpQueue\n    Scanner --> BluetoothLeScanner\n    Advertiser --> BluetoothLeAdvertiser\n    GattClient --> BluetoothGatt\n    GattServer --> BluetoothGattServer\n```\n\n### Layer Responsibilities\n\n| Layer | Component | Responsibility |\n|-------|-----------|----------------|\n| Python | `BLEInterface` | Reticulum interface, packet fragmentation/reassembly, peer lifecycle |\n| Python | `BLEPeerInterface` | Per-peer Reticulum routing interface |\n| Python | `AndroidBLEDriver` | Bridge to Kotlin, callback routing |\n| Kotlin | `KotlinBLEBridge` | Entry point for Python, connection tracking, deduplication |\n| Kotlin | `BleScanner` | Device discovery with adaptive intervals |\n| Kotlin | `BleAdvertiser` | Peripheral advertising with identity |\n| Kotlin | `BleGattClient` | Central mode GATT operations |\n| Kotlin | `BleGattServer` | Peripheral mode GATT service |\n| Kotlin | `BleOperationQueue` | Serialized GATT operations (Android limitation) |\n\n---\n\n## GATT Service Structure\n\nThe Reticulum BLE service follows Protocol v2.2 specification:\n\n```mermaid\nclassDiagram\n    class ReticulumService {\n        UUID: 37145b00-442d-4a94-917f-8f42c5da28e3\n        Type: PRIMARY\n    }\n\n    class RXCharacteristic {\n        UUID: 37145b00-442d-4a94-917f-8f42c5da28e5\n        Properties: WRITE, WRITE_NO_RESPONSE\n        Permissions: WRITE\n        Purpose: Centrals write data here\n    }\n\n    class TXCharacteristic {\n        UUID: 37145b00-442d-4a94-917f-8f42c5da28e4\n        Properties: READ, NOTIFY, INDICATE\n        Permissions: READ\n        Purpose: Peripherals notify data here\n    }\n\n    class IdentityCharacteristic {\n        UUID: 37145b00-442d-4a94-917f-8f42c5da28e6\n        Properties: READ\n        Permissions: READ\n        Purpose: 16-byte transport identity\n    }\n\n    class CCCDDescriptor {\n        UUID: 00002902-0000-1000-8000-00805f9b34fb\n        Purpose: Enable/disable notifications\n    }\n\n    ReticulumService --> RXCharacteristic\n    ReticulumService --> TXCharacteristic\n    ReticulumService --> IdentityCharacteristic\n    TXCharacteristic --> CCCDDescriptor\n```\n\n### Characteristic Details\n\n| Characteristic | UUID Suffix | Direction | Purpose |\n|----------------|-------------|-----------|---------|\n| RX | `...28e5` | Central → Peripheral | Data and identity handshake writes |\n| TX | `...28e4` | Peripheral → Central | Notifications for outbound data |\n| Identity | `...28e6` | Read-only | Provides 16-byte transport identity hash |\n\n---\n\n## Connection Flows\n\n### Central Mode Connection Sequence\n\nWhen this device discovers and connects to a peripheral:\n\n```mermaid\nsequenceDiagram\n    participant Scan as BleScanner\n    participant Bridge as KotlinBLEBridge\n    participant Client as BleGattClient\n    participant Peer as Remote Peripheral\n    participant Python as AndroidBLEDriver\n\n    Scan->>Bridge: onDeviceDiscovered(address, rssi)\n    Bridge->>Bridge: shouldConnect(address)?\n    Note over Bridge: MAC comparison:<br/>our MAC < peer MAC = connect\n    Bridge->>Client: connect(address)\n\n    rect rgb(230, 245, 255)\n        Note over Client,Peer: 4-Step GATT Handshake\n        Client->>Peer: 1. connectGatt()\n        Peer-->>Client: onConnectionStateChange(CONNECTED)\n        Client->>Peer: 2. discoverServices()\n        Peer-->>Client: onServicesDiscovered()\n\n        Client->>Peer: Read Identity Characteristic\n        Peer-->>Client: 16-byte identity hash\n        Client->>Bridge: onIdentityReceived(address, hash)\n\n        Client->>Peer: 3. requestMtu(517)\n        Peer-->>Client: onMtuChanged(negotiated_mtu)\n\n        Client->>Peer: 4. Enable CCCD notifications\n        Peer-->>Client: onDescriptorWrite(success)\n\n        Client->>Peer: Write our identity to RX\n        Peer-->>Client: onCharacteristicWrite(success)\n    end\n\n    Client->>Bridge: onConnected(address, mtu, identity)\n    Bridge->>Python: onConnected callback\n    Python->>Python: Spawn BLEPeerInterface\n```\n\n### Peripheral Mode Connection Sequence\n\nWhen a remote central connects to us:\n\n```mermaid\nsequenceDiagram\n    participant Central as Remote Central\n    participant Server as BleGattServer\n    participant Bridge as KotlinBLEBridge\n    participant Python as AndroidBLEDriver\n\n    Central->>Server: connectGatt()\n    Server->>Server: onConnectionStateChange(CONNECTED)\n    Server->>Bridge: onCentralConnected(address, MIN_MTU)\n    Note over Bridge: Track as pending connection<br/>(identity not yet received)\n\n    Central->>Server: discoverServices()\n    Central->>Server: Read Identity Characteristic\n    Server-->>Central: Our 16-byte identity\n\n    Central->>Server: requestMtu()\n    Server->>Server: onMtuChanged()\n    Server->>Bridge: onMtuChanged(address, mtu)\n\n    Central->>Server: Enable CCCD notifications\n\n    rect rgb(255, 245, 230)\n        Note over Central,Server: Identity Handshake\n        Central->>Server: Write 16 bytes to RX\n        Server->>Server: Detect: len=16, no existing identity\n        Server->>Bridge: onIdentityReceived(address, hash)\n        Server->>Bridge: onDataReceived(address, identity_bytes)\n    end\n\n    Bridge->>Bridge: Complete connection with identity\n    Bridge->>Python: onConnected(address, mtu, \"peripheral\", identity)\n    Bridge->>Python: onIdentityReceived(address, hash)\n    Python->>Python: Spawn BLEPeerInterface\n```\n\n### Defensive Recovery for Missed onConnectionStateChange\n\nAndroid's `onConnectionStateChange` callback is unreliable and sometimes doesn't fire, even when a BLE connection is established. When this happens, the connection would be \"orphaned\" - data arrives but can't be sent back because the address isn't registered.\n\nThe fix: When `handleCharacteristicWriteRequest` receives data from an address not in `connectedCentrals`, it retroactively registers the connection:\n\n```mermaid\nsequenceDiagram\n    participant Central as Remote Central\n    participant Server as BleGattServer\n    participant Bridge as KotlinBLEBridge\n    participant Python as AndroidBLEDriver\n\n    Central->>Server: connectGatt()\n    Note over Server: ⚠️ onConnectionStateChange NOT called<br/>(Android BLE bug)\n    Note over Server: connectedCentrals is empty\n\n    Central->>Server: Write data to RX characteristic\n    Server->>Server: handleCharacteristicWriteRequest\n    Server->>Server: Check: address in connectedCentrals?\n\n    rect rgb(255, 230, 230)\n        Note over Server: DEFENSIVE RECOVERY\n        Server->>Server: Address NOT found!<br/>Log warning\n        Server->>Server: Add to connectedCentrals\n        Server->>Server: Set MTU = MIN_MTU\n        Server->>Bridge: onCentralConnected(address, mtu)\n        Bridge->>Bridge: Add to connectedPeers\n    end\n\n    Server->>Bridge: onDataReceived(address, data)\n    Note over Server,Python: Connection now properly tracked\n```\n\n**Key log message**: `\"DEFENSIVE RECOVERY: Data received from {address} but onConnectionStateChange was never called!\"`\n\n---\n\n## Identity Protocol (v2.2)\n\n### Purpose\n\nAndroid randomizes MAC addresses for privacy. The identity protocol provides stable peer identification across MAC rotations.\n\n### Handshake Sequence (Central → Peripheral)\n\n```mermaid\nsequenceDiagram\n    participant C as Central\n    participant P as Peripheral\n\n    Note over C: Connect as GATT client\n    C->>P: Read Identity Characteristic\n    P-->>C: Peripheral's 16-byte identity\n    Note over C: Store: address → identity\n\n    C->>P: Write 16 bytes to RX Characteristic\n    Note over P: Detect identity handshake:<br/>exactly 16 bytes, no existing identity\n    Note over P: Store: address → identity\n\n    Note over C,P: Both sides now have<br/>identity ↔ address mapping\n```\n\n### Identity Tracking Data Structures\n\n```mermaid\nflowchart LR\n    subgraph Python[\"Python (BLEInterface)\"]\n        P_A2I[\"address_to_identity<br/>MAC → 16-byte identity\"]\n        P_I2A[\"identity_to_address<br/>hash → MAC\"]\n        P_SI[\"spawned_interfaces<br/>hash → BLEPeerInterface\"]\n        P_Cache[\"_identity_cache<br/>MAC → (identity, timestamp)<br/>TTL: 60s\"]\n    end\n\n    subgraph Kotlin[\"Kotlin (KotlinBLEBridge)\"]\n        K_A2I[\"addressToIdentity<br/>MAC → 32-char hex\"]\n        K_I2A[\"identityToAddress<br/>hex → MAC\"]\n        K_Peers[\"connectedPeers<br/>MAC → PeerConnection\"]\n        K_Pending[\"pendingConnections<br/>MAC → PendingConnection\"]\n    end\n\n    P_A2I -.->|sync| K_A2I\n    P_I2A -.->|sync| K_I2A\n```\n\n### MAC Rotation Handling\n\nWhen a peer reconnects with a new MAC address, the handling differs by connection mode:\n\n#### Overview\n\n```mermaid\nflowchart TD\n    A[New connection from MAC_NEW] --> B{Identity received?}\n    B -->|Yes| C[Compute identity_hash]\n    C --> D{identity_hash in identityToAddress?}\n    D -->|Yes, points to MAC_OLD| E[MAC Rotation Detected]\n    E --> F{Is MAC_OLD still connected?}\n    F -->|No| G[Clean up stale mappings]\n    G --> H[Update: identity → MAC_NEW]\n    F -->|Yes| I[Dual connection - deduplicate]\n    D -->|No| J[New identity - normal flow]\n    B -->|No, peripheral| K[Wait for handshake]\n```\n\n#### Central Mode Flow (We Connect to Them)\n\nIdentity is received via GATT read of Identity Characteristic, then processed in Kotlin's `handleIdentityReceived`:\n\n```mermaid\nflowchart TD\n    A[We connect to MAC_NEW<br/>Read Identity Characteristic] --> B[Kotlin: handleIdentityReceived<br/>Gets 16-byte identity from GATT read]\n    B --> C{Kotlin: onDuplicateIdentityDetected?<br/>Calls Python callback if set}\n    C -->|Callback returns True<br/>identity already at different MAC| D[Reject: disconnect MAC_NEW<br/>Log: Duplicate identity rejected]\n    C -->|Callback returns False<br/>new identity or same MAC| E[Allow connection to proceed]\n    C -->|No callback set| E\n\n    E --> F[Kotlin: Store addressToIdentity‹MAC_NEW›]\n    F --> G{Kotlin: identityToAddress‹hash› exists?}\n    G -->|\"No (new identity)\"| H[Store identityToAddress‹hash› = MAC_NEW<br/>Notify Python: onConnected]\n    G -->|\"Yes, = MAC_OLD\"| I[Keep MAC_OLD as primary in identityToAddress<br/>Still store addressToIdentity‹MAC_NEW›<br/>Notify Python: onConnected]\n```\n\n**Key code reference**: `KotlinBLEBridge.handleIdentityReceived()` (duplicate identity check requires `onDuplicateIdentityDetected` callback)\n\n#### Peripheral Mode Flow (They Connect to Us)\n\nIdentity is received via 16-byte write to RX characteristic, detected in Python's `_handle_identity_handshake`:\n\n```mermaid\nflowchart TD\n    A[MAC_NEW connects to us<br/>Writes 16-byte identity to RX] --> B{Python: _handle_identity_handshake<br/>Entry check: len=16 AND<br/>no address_to_identity‹MAC_NEW›}\n    B -->|Check fails| Z[Not a handshake, pass to data handler]\n    B -->|Check passes| C{Python: _check_duplicate_identity<br/>Returns: True if duplicate, False otherwise}\n\n    C -->|\"Returns True<br/>(identity_to_address‹hash› = MAC_OLD<br/>AND MAC_OLD ≠ MAC_NEW)\"| D[Reject: driver.disconnect‹MAC_NEW›<br/>Log: duplicate identity rejected<br/>Return True: handshake consumed]\n    C -->|\"Returns False<br/>(new identity OR same MAC)\"| E[Allow: continue processing]\n\n    E --> F[Store address_to_identity‹MAC_NEW› = identity<br/>Store identity_to_address‹hash› = MAC_NEW]\n    F --> G{spawned_interfaces‹hash› exists?}\n    G -->|No| H[Create new BLEPeerInterface<br/>Store in spawned_interfaces‹hash›]\n    G -->|Yes| I{existing.peer_address ≠ MAC_NEW?}\n    I -->|Yes| J[Update existing interface:<br/>peer_address = MAC_NEW<br/>address_to_interface‹MAC_NEW› = interface]\n    I -->|No| K[No update needed, same address]\n```\n\n**Key code reference**: `BLEInterface._handle_identity_handshake()` at lines 1108-1200\n\n#### Return Value Clarification\n\nThe `_check_duplicate_identity` function returns a **boolean**, not a MAC address:\n\n| Condition | Return Value | Meaning |\n|-----------|--------------|---------|\n| `identity_to_address[hash]` not found | `False` | New identity, allow |\n| `identity_to_address[hash]` = MAC_NEW | `False` | Same MAC, allow |\n| `identity_to_address[hash]` = MAC_OLD (≠ MAC_NEW) | `True` | Duplicate, reject |\n\n---\n\n## Deduplication State Machine\n\nWhen the same identity is connected via both central and peripheral paths:\n\n```mermaid\nstateDiagram-v2\n    [*] --> NONE: Initial state\n\n    NONE --> DualDetected: Same identity on both paths\n\n    DualDetected --> DecisionPoint: Determine which to keep\n\n    DecisionPoint --> CLOSING_CENTRAL: Keep peripheral<br/>(our MAC > peer MAC)\n    DecisionPoint --> CLOSING_PERIPHERAL: Keep central<br/>(our MAC < peer MAC)\n\n    CLOSING_CENTRAL --> NONE: Central disconnected\n    CLOSING_PERIPHERAL --> NONE: Peripheral disconnected\n\n    note right of DecisionPoint\n        Decision based on MAC comparison:\n        - Lower MAC = central role\n        - Higher MAC = peripheral role\n    end note\n```\n\n### DeduplicationState Enum\n\n```kotlin\nenum class DeduplicationState {\n    NONE,              // Normal - use actual isCentral/isPeripheral\n    CLOSING_CENTRAL,   // Keeping peripheral, central disconnect pending\n    CLOSING_PERIPHERAL // Keeping central, peripheral disconnect pending\n}\n```\n\n### Deduplication Flow\n\n```mermaid\nsequenceDiagram\n    participant Bridge as KotlinBLEBridge\n    participant Client as BleGattClient\n    participant Server as BleGattServer\n    participant Python as AndroidBLEDriver\n\n    Note over Bridge: Dual connection detected<br/>Same identity on both paths\n\n    Bridge->>Bridge: Compare MAC addresses\n    alt Our MAC < Peer MAC (we should be central)\n        Bridge->>Bridge: Set state = CLOSING_PERIPHERAL\n        Bridge->>Server: disconnectCentral(address)\n        Bridge->>Python: onAddressChanged(peripheral_addr, central_addr, identity)\n    else Our MAC > Peer MAC (we should be peripheral)\n        Bridge->>Bridge: Set state = CLOSING_CENTRAL\n        Bridge->>Client: disconnect(address)\n        Bridge->>Python: onAddressChanged(central_addr, peripheral_addr, identity)\n    end\n\n    Note over Python: Update address mappings<br/>Migrate fragmenter keys\n\n    Bridge->>Bridge: Set state = NONE\n```\n\n---\n\n## Data Flow\n\n### Sending Data (Python → BLE)\n\n```mermaid\nflowchart TB\n    subgraph Python[\"Python Layer\"]\n        A[BLEPeerInterface.process_outgoing] --> B[Get fragmenter by identity_key]\n        B --> C[BLEFragmenter.fragment]\n        C --> D[\"Fragments with header:<br/>type(1) + seq(2) + total(2)\"]\n        D --> E[AndroidBLEDriver.send]\n    end\n\n    subgraph Kotlin[\"Kotlin Layer\"]\n        E --> F[KotlinBLEBridge.sendAsync]\n        F --> G{Check deduplicationState}\n        G -->|NONE| H{isCentral?}\n        G -->|CLOSING_*| I[Block send - in transition]\n        H -->|Yes| J[GattClient.sendData]\n        H -->|No| K[GattServer.notifyCentrals]\n        J --> L[Write to RX characteristic]\n        K --> M[Notify via TX characteristic]\n    end\n\n    L --> N[Remote peripheral receives]\n    M --> O[Remote central receives]\n```\n\n### Receiving Data (BLE → Python)\n\n```mermaid\nflowchart TB\n    subgraph BLE[\"BLE Stack\"]\n        A[Notification/Write received]\n    end\n\n    subgraph Kotlin[\"Kotlin Layer\"]\n        A --> B{Is central or peripheral?}\n        B -->|Central| C[onCharacteristicChanged]\n        B -->|Peripheral| D[onCharacteristicWriteRequest]\n        C --> E[Bridge.handleDataReceived]\n        D --> E\n        E --> F{First 16 bytes, no identity?}\n        F -->|Yes| G[Identity handshake - store]\n        F -->|No| H[Forward to Python]\n    end\n\n    subgraph Python[\"Python Layer\"]\n        H --> I[AndroidBLEDriver._handle_data_received]\n        I --> J{Check identity handshake}\n        J -->|Yes, 16 bytes| K[_handle_identity_handshake]\n        J -->|No| L[_handle_ble_data]\n        L --> M[Get reassembler by identity_key]\n        M --> N[BLEReassembler.add_fragment]\n        N --> O{Complete packet?}\n        O -->|Yes| P[BLEPeerInterface.process_incoming]\n        O -->|No| Q[Wait for more fragments]\n    end\n```\n\n---\n\n## Keepalive Mechanism\n\nAndroid BLE connections timeout after 20-30 seconds of inactivity. Both layers implement keepalives:\n\n```mermaid\nsequenceDiagram\n    participant Client as BleGattClient\n    participant Timer as Keepalive Timer<br/>(15s interval)\n    participant Peer as Remote Peripheral\n\n    Note over Client: Connection established\n    Client->>Timer: Start keepalive job\n\n    loop Every 15 seconds\n        Timer->>Client: Send keepalive\n        Client->>Peer: Write 0x00 to RX\n        alt Success\n            Peer-->>Client: Write confirmed\n            Client->>Timer: Reset failure counter\n        else Failure\n            Client->>Timer: Increment failures\n            alt failures >= 3\n                Timer->>Client: Connection dead\n                Client->>Client: disconnect()\n            end\n        end\n    end\n```\n\n### Keepalive Configuration\n\n| Parameter | Value | Source |\n|-----------|-------|--------|\n| Interval | 15 seconds | `BleConstants.CONNECTION_KEEPALIVE_INTERVAL_MS` |\n| Max failures | 3 | `BleConstants.MAX_CONNECTION_FAILURES` |\n| Packet | `0x00` (1 byte) | Minimal overhead |\n\nBoth `BleGattClient` (central) and `BleGattServer` (peripheral) maintain independent keepalive mechanisms.\n\n---\n\n## Scanning and Advertising\n\n### Adaptive Scanning\n\n```mermaid\nstateDiagram-v2\n    [*] --> Active: Start scanning\n\n    Active --> Active: New device discovered\n    Active --> Idle: 3 scans without new devices\n\n    Idle --> Active: New device discovered\n    Idle --> Idle: No new devices\n\n    note right of Active\n        Interval: 5s\n        Mode: BALANCED or LOW_LATENCY\n    end note\n\n    note right of Idle\n        Interval: 30s\n        Mode: LOW_POWER\n    end note\n```\n\n### Scan Configuration\n\n| Parameter | Active | Idle |\n|-----------|--------|------|\n| Interval | 5 seconds | 30 seconds |\n| Duration | 10 seconds | 10 seconds |\n| Mode | `SCAN_MODE_BALANCED` | `SCAN_MODE_LOW_POWER` |\n| Threshold | 3 devices | 3 empty scans |\n\n### Advertising with Proactive Refresh\n\n```mermaid\nsequenceDiagram\n    participant Adv as BleAdvertiser\n    participant Timer as Refresh Timer<br/>(60s interval)\n    participant Android as Android BLE\n\n    Adv->>Android: startAdvertising()\n    Android-->>Adv: onStartSuccess()\n    Adv->>Timer: Start refresh job\n\n    loop Every 60 seconds\n        Timer->>Adv: Proactive refresh\n        Adv->>Android: stopAdvertising()\n        Adv->>Android: startAdvertising()\n        Note over Adv: Ensures advertising persists<br/>after screen off/background\n    end\n```\n\n### Advertisement Data Structure\n\n```\nAdvertising Data (31 bytes max):\n├── Flags (3 bytes)\n└── Service UUID (19 bytes for 128-bit UUID)\n\nScan Response (31 bytes separate budget):\n└── Device Name: \"RNS-{truncated_identity_hex}\"\n```\n\n---\n\n## Address/Identity Mapping Summary\n\n### Python Layer (`BLEInterface`)\n\n| Dictionary | Key | Value | Purpose |\n|------------|-----|-------|---------|\n| `address_to_identity` | MAC address | 16-byte identity | MAC → identity lookup |\n| `identity_to_address` | 16-char hash | MAC address | Identity → current MAC |\n| `spawned_interfaces` | 16-char hash | BLEPeerInterface | Identity → interface |\n| `address_to_interface` | MAC address | BLEPeerInterface | Fallback cleanup |\n| `_identity_cache` | MAC address | (identity, timestamp) | Reconnection cache (60s TTL) |\n| `_pending_identity_connections` | MAC address | timestamp | Timeout tracking |\n| `_pending_detach` | 16-char hash | timestamp | Grace period detach |\n| `pending_mtu` | MAC address | MTU value | MTU/identity race handling |\n| `fragmenters` | identity_key | BLEFragmenter | Per-identity fragmentation |\n| `reassemblers` | identity_key | BLEReassembler | Per-identity reassembly |\n\n### Kotlin Layer (`KotlinBLEBridge`)\n\n| Map | Key | Value | Purpose |\n|-----|-----|-------|---------|\n| `addressToIdentity` | MAC address | 32-char hex | MAC → identity |\n| `identityToAddress` | 32-char hex | MAC address | Identity → MAC |\n| `connectedPeers` | MAC address | PeerConnection | Active connections |\n| `pendingConnections` | MAC address | PendingConnection | Awaiting identity |\n| `pendingCentralConnections` | Set<MAC> | - | In-progress central connects |\n| `recentlyDeduplicatedIdentities` | 32-char hex | timestamp | Dedup cooldown (60s) |\n| `processedIdentityCallbacks` | Set<key> | - | Prevent duplicate notifications |\n\n---\n\n## Potential Issues & Recommendations\n\n### 1. GATT Operation Timeout (5s default)\n\n**Issue**: The default 5-second timeout in `BleOperationQueue` may be too short for slow or congested BLE environments.\n\n**Impact**: GATT operations may fail prematurely on:\n- Older devices with slower BLE stacks\n- Environments with high 2.4GHz interference\n- During rapid connection/disconnection cycles\n\n**Recommendation**: Consider adaptive timeouts based on operation type and historical success rates.\n\n### 2. Advertising Refresh Interval (60s)\n\n**Issue**: The 60-second advertising refresh may miss discovery windows.\n\n**Impact**: If Android silently stops advertising immediately after screen-off, devices may be undiscoverable for up to 60 seconds.\n\n**Recommendation**:\n- Reduce to 30 seconds when battery is not a concern\n- Add `BroadcastReceiver` for `ACTION_SCREEN_OFF` to trigger immediate refresh\n\n### 3. Identity Cache Coherence\n\n**Issue**: The 60-second identity cache in Python may become stale if not properly synchronized with Kotlin state.\n\n**Impact**: Race conditions during rapid reconnection cycles could cause identity mismatches.\n\n**Recommendation**: Add explicit cache invalidation when Kotlin detects MAC rotation or deduplication.\n\n### 4. Fragmenter Key Complexity\n\n**Issue**: Fragmenter keys use `_get_fragmenter_key(identity, address)` but the address parameter is unused.\n\n**Current code**:\n```python\ndef _get_fragmenter_key(self, peer_identity, address):\n    # Address unused - key is identity-based for MAC rotation immunity\n    return self._compute_identity_hash(peer_identity)\n```\n\n**Recommendation**: Remove unused `address` parameter to avoid confusion.\n\n### 5. Double Identity Callback Processing\n\n**Issue**: Both Kotlin (`onIdentityReceived`) and Python (`_handle_identity_handshake`) detect and process identity handshakes.\n\n**Impact**: Additional complexity and potential for desynchronization.\n\n**Recommendation**: Single point of identity detection (Kotlin) with Python purely as a consumer.\n\n### 6. Grace Period Timing\n\n**Issue**: The 2-second detach grace period (`_pending_detach_grace_period`) is hardcoded.\n\n**Impact**: May not be sufficient for slow network conditions or concurrent reconnection attempts.\n\n**Recommendation**: Make configurable via interface parameters, with a suggested default of 3-5 seconds.\n\n---\n\n## Key Constants Reference\n\n### UUIDs (BleConstants.kt)\n\n| Constant | Value |\n|----------|-------|\n| `SERVICE_UUID` | `37145b00-442d-4a94-917f-8f42c5da28e3` |\n| `CHARACTERISTIC_RX_UUID` | `37145b00-442d-4a94-917f-8f42c5da28e5` |\n| `CHARACTERISTIC_TX_UUID` | `37145b00-442d-4a94-917f-8f42c5da28e4` |\n| `CHARACTERISTIC_IDENTITY_UUID` | `37145b00-442d-4a94-917f-8f42c5da28e6` |\n| `CCCD_UUID` | `00002902-0000-1000-8000-00805f9b34fb` |\n\n### Timing Constants\n\n| Constant | Value | Location |\n|----------|-------|----------|\n| `CONNECTION_TIMEOUT_MS` | 30,000 ms | BleConstants |\n| `CONNECTION_KEEPALIVE_INTERVAL_MS` | 15,000 ms | BleConstants |\n| `DISCOVERY_INTERVAL_MS` | 5,000 ms | BleConstants |\n| `DISCOVERY_INTERVAL_IDLE_MS` | 30,000 ms | BleConstants |\n| `SCAN_DURATION_MS` | 10,000 ms | BleConstants |\n| `ADVERTISING_REFRESH_INTERVAL_MS` | 60,000 ms | BleAdvertiser |\n| `_identity_cache_ttl` | 60 s | BLEInterface |\n| `_pending_detach_grace_period` | 2.0 s | BLEInterface |\n| `deduplicationCooldownMs` | 60,000 ms | KotlinBLEBridge |\n\n### MTU Constants\n\n| Constant | Value | Meaning |\n|----------|-------|---------|\n| `MIN_MTU` | 23 | BLE 4.0 minimum |\n| `DEFAULT_MTU` | 185 | Reasonable default |\n| `MAX_MTU` | 517 | BLE 5.0 maximum |\n| `HW_MTU` | 500 | Reticulum standard |\n\n---\n\n## File Locations\n\n| Component | Path |\n|-----------|------|\n| BLEInterface.py | `app/build/python/pip/release/common/ble_reticulum/BLEInterface.py` |\n| AndroidBLEDriver | `python/ble_modules/android_ble_driver.py` |\n| KotlinBLEBridge | `reticulum/src/main/java/com/lxmf/messenger/reticulum/ble/bridge/KotlinBLEBridge.kt` |\n| BleGattClient | `reticulum/src/main/java/com/lxmf/messenger/reticulum/ble/client/BleGattClient.kt` |\n| BleGattServer | `reticulum/src/main/java/com/lxmf/messenger/reticulum/ble/server/BleGattServer.kt` |\n| BleScanner | `reticulum/src/main/java/com/lxmf/messenger/reticulum/ble/client/BleScanner.kt` |\n| BleAdvertiser | `reticulum/src/main/java/com/lxmf/messenger/reticulum/ble/server/BleAdvertiser.kt` |\n| BleOperationQueue | `reticulum/src/main/java/com/lxmf/messenger/reticulum/ble/util/BleOperationQueue.kt` |\n| BleConstants | `reticulum/src/main/java/com/lxmf/messenger/reticulum/ble/model/BleConstants.kt` |"}],["entry_1770158456706_dedjk",{"id":"entry_1770158456706_dedjk","key":"columba-userguide","namespace":"codebase","content":"# Columba Use Manual\n\n**Simple Installation & Setup Guide**\n\n## What is Columba?\n\nColumba is a secure, peer-to-peer messaging application designed to work **with or without the Internet**.\nIt can operate over bluetooth, Wi-Fi, mobile data, and even radio, using a technology called **Reticulum**.\n\nColumba is especially useful when:\n\n* Internet access is unreliable or unavailable\n* Privacy and encryption matter\n* You want resilient, off-grid communication\n\nOfficial project repository:\n[https://github.com/torlando-tech/columba](https://github.com/torlando-tech/columba)\n\n---\n\n## What You Need Before You Start\n\n* An **Android phone** (Android 12 or newer recommended)\n* About **100 MB of free storage**\n\nYou **do not** need:\n\n* A phone number\n* An email address\n* A central server account\n\n---\n\n## Step 1 – Install Columba on Android\n\n### Option A – Install from APK\n\n1. Open the Columba GitHub page:\n   [https://github.com/torlando-tech/columba](https://github.com/torlando-tech/columba)\n2. Go to **Releases**\n3. Download the latest **Columba Android APK**\n4. On your phone:\n\n   * Open **Settings → Security**\n   * Enable **Install unknown apps**\n5. Tap the downloaded APK to install\n\n> Android may warn you about installing from outside the Play Store. This is normal.\n\n---\n\n## Step 2 – First Launch\n\nWhen you open Columba for the first time:\n\n* The app **creates a secure identity automatically**\n* No registration is required\n* No personal data is requested\n\nWhat happens behind the scenes:\n\n* A cryptographic identity is generated\n* This identity replaces usernames, phone numbers, or email addresses\n\n\n## Step 3 – Basic Configuration\n\nOpen **Settings** in Columba.\n\n### Network\n\nLeave defaults unless you know what you are doing. The default settings allow Columba to:\n\n* Find peers automatically\n* Switch between Internet, Local Wi-Fi, or bluetooth\n\n### Identity\n\n* Already created automatically\n* You should set a display name using the wizard. If you skipped that step, you can set your display name in the settings\n\n## Step 4 – Sending Your First Message\n\n### Using Announces\n1. Open **Announces**\n2. Tap on the name of a contact\n3. Tap **Start Chat**\n\n### Using Chat\n1. Open **Chats**\n2. Choose **New Conversation**\n3. Add a contact by:\n\n   * Scanning a QR code\n   * Pasting a destination string\n4. Type a message\n5. Press **Send**\n\nIn both cases if the recipient is reachable:\n\n* Message is delivered immediately\n\nIf not:\n\n* Message is **stored securely**\n* Delivered automatically when the recipient becomes available\n\n---\n\n## Step 5 – Offline and Mesh Usage\n\nColumba also works even when:\n\n* Internet is down\n* Cellular service is unavailable\n\nExamples:\n\n* Phones connected through bluetooth\n* Two phones on the same Wi-Fi network\n* Devices linked via LoRa radio (RNodes)\n\nYou do not need to change anything:\n\n* Columba and Reticulum select the best available way!!!\n  \n\n## Basic Troubleshooting\n\n**Messages not delivered immediately**\n\n* This is normal in delay-tolerant networks\n* Messages will arrive once a path exists\n\n**No peers found**\n\n* Ensure both devices have Columba running\n* Ensure Wi-Fi or another shared medium is available\n* Restart Columba\n\n**App seems idle**\n\n* Reticulum is event-driven; silence often means no traffic, not failure\n* Restart Columba\n\n---\n\n# Understanding Reticulum\n\n## What Is Reticulum?\n\nReticulum is the privacy focus networking system that Columba uses.\n\nThink of it as:\n\n> “A private, secure alternative to the Internet that works anywhere.”\n\nIt does **not** rely on:\n\n* Internet providers, Central servers, IP addresses, Phone numbers\n\n\n## How Reticulum Is Different \n\n### Traditional Internet\n\n* Needs central infrastructure\n* Depends on ISPs\n* Unencrypted by default\n* Breaks easily during outages\n\n### Reticulum\n\n* Decentralized\n* Peer-to-peer\n* Always encrypted\n* Keeps working during disruptions\n\nReticulum was designed for:\n\n* Security and sovereignty \n* Unreliable links\n* Off-grid operation\n\n\n## Why Columba + Reticulum Matters\n\nTogether they provide:\n\n* Censorship-free, private messaging\n* Communication without infrastructure\n* Resilience during outages\n* Independence from telecom providers\n\nThis is increasingly relevant for:\n\n* Emergency communication\n* Remote communities\n* Privacy-conscious users"}],["entry_1770158458153_31efv7j",{"id":"entry_1770158458153_31efv7j","key":"columba-rpc-auth","namespace":"codebase","content":"# RPC Authentication Error in Shared Instance Mode\n\n## Overview\n\nWhen Columba connects to a shared Reticulum instance (e.g., Sideband), message delivery fails with RPC authentication errors. This document explains the root cause and provides solutions.\n\n## Key Finding: RPC is NOT Required for Message Delivery\n\n**Core packet routing uses LocalClientInterface socket connections directly - NOT RPC.**\n\nThe RPC subsystem is only used for:\n- Statistics queries (RSSI, SNR, link quality)\n- Path table queries\n- Management operations (drop paths, clear queues)\n\nHowever, a bug in RNS causes message delivery to crash when RPC authentication fails.\n\n---\n\n## LXMF Delivery Methods\n\n| Method | Description | Max Size | RPC Required? |\n|--------|-------------|----------|---------------|\n| **OPPORTUNISTIC** | Single encrypted packet, no link | ~295 bytes | No |\n| **DIRECT** | Link-based, reliable delivery | Unlimited | No |\n| **PROPAGATED** | Store-and-forward via propagation node | Unlimited | No |\n| **PAPER** | QR code/URI for manual transfer | ~1760 bytes | No |\n\nAll methods deliver through `LXMRouter.lxmf_delivery()` → delivery callback. None require RPC.\n\n---\n\n## The Bug: RPC Auth Error Crashes Message Delivery\n\n### Evidence from Logcat\n\n```\n12-07 23:45:11.910 I python.stdout: [2025-12-07 23:45:11] [Error]    Traceback (most recent call last):\n12-07 23:45:11.910 I python.stdout:   File \".../RNS/Interfaces/LocalInterface.py\", line 193, in process_incoming\n12-07 23:45:11.910 I python.stdout:   File \".../RNS/Transport.py\", line 1889, in inbound\n12-07 23:45:11.910 I python.stdout:   File \".../RNS/Link.py\", line 995, in receive\n12-07 23:45:11.910 I python.stdout:   File \".../RNS/Link.py\", line 837, in __update_phy_stats\n12-07 23:45:11.910 I python.stdout:   File \".../RNS/Reticulum.py\", line 1280, in get_packet_rssi\n12-07 23:45:11.910 I python.stdout:   File \".../RNS/Reticulum.py\", line 969, in get_rpc_client\n12-07 23:45:11.911 I python.stdout: multiprocessing.context.AuthenticationError: digest sent was rejected\n\n12-07 23:45:13.279 I sidebandservice: [Error] An error ocurred while handling RPC call from local client: digest received was wrong\n```\n\n### Exact Call Chain\n\n```\n1. Packet arrives at LocalClientInterface (connected to Sideband's shared instance)\n       ↓\n2. LocalInterface.process_incoming() [LocalInterface.py:193]\n   - Receives raw packet bytes from shared instance socket\n       ↓\n3. Transport.inbound() [Transport.py:1889]\n   - Routes packet to appropriate handler\n   - For link-related packets, calls link.receive()\n       ↓\n4. Link.receive() [Link.py:995]\n   - Processes the link packet (DATA, LINKIDENTIFY, REQUEST, etc.)\n   - Calls __update_phy_stats() to record signal quality\n       ↓\n5. Link.__update_phy_stats() [Link.py:837]\n   - Called with force_update=True at 17 different sites in receive()\n   - Tries to get RSSI/SNR/Q from the packet\n   - If connected to shared instance, makes RPC call\n       ↓\n6. Reticulum.get_packet_rssi() [Reticulum.py:1280]\n   - Makes RPC call to shared instance to query cached RSSI value\n       ↓\n7. Reticulum.get_rpc_client() [Reticulum.py:969]\n   - Creates RPC connection with authkey\n   - AuthenticationError: Columba's authkey doesn't match Sideband's\n```\n\n### Root Cause\n\n**Columba and Sideband have different RPC keys** because:\n- Each app has its own config directory (Android sandboxing)\n- RPC keys are derived from app-specific identity private keys\n- Without explicit key sharing, authentication fails\n\n### Why This Crashes Message Delivery\n\nThe `__update_phy_stats()` method does NOT have exception handling:\n\n```python\n# Link.py lines 833-850 (simplified)\ndef __update_phy_stats(self, packet, force_update=False):\n    if self.__track_phy_stats or force_update:\n        if RNS.Reticulum.get_instance().is_connected_to_shared_instance:\n            # NO TRY-CATCH HERE!\n            self.rssi = RNS.Reticulum.get_instance().get_packet_rssi(packet.packet_hash)\n            self.snr = RNS.Reticulum.get_instance().get_packet_snr(packet.packet_hash)\n            self.q = RNS.Reticulum.get_instance().get_packet_q(packet.packet_hash)\n```\n\nWhen `get_packet_rssi()` raises `AuthenticationError`, it propagates up through:\n- `__update_phy_stats()` → `receive()` → `Transport.inbound()` → `process_incoming()`\n\nThis crashes the entire packet processing chain.\n\n### Why `force_update=True` Is Used\n\nEven though `__track_phy_stats` defaults to `False`, certain call sites in `Link.receive()` use `force_update=True`:\n\n- **Line 218**: Incoming link request acceptance\n- **Lines 995, 1031, 1040, 1053, 1060, 1064, 1069**: Various DATA packet types\n- **Lines 1107, 1129, 1138, 1147, 1167, 1176, 1185**: RESOURCE_ADV, LINKCLOSE, etc.\n\nThis is automatic RNS behavior - **Columba does not explicitly request signal stats**.\n\n---\n\n## Can RPC Key Enable Interface Configuration?\n\n**NO** - Even with valid RPC key, shared instance clients cannot configure interfaces:\n\n```python\n# From Reticulum.py _add_interface()\nif not self.is_connected_to_shared_instance:\n    # Process interface configuration\n```\n\nInterface configuration is blocked for connected clients. This is by design - the shared instance owns the interfaces.\n\n---\n\n## Solutions\n\n### Option 1: Patch RNS in Columba's Bundled Copy\n\nAdd exception handling in `Link.__update_phy_stats()`:\n\n```python\ndef __update_phy_stats(self, packet, force_update=False):\n    if self.__track_phy_stats or force_update:\n        try:\n            if RNS.Reticulum.get_instance().is_connected_to_shared_instance:\n                self.rssi = RNS.Reticulum.get_instance().get_packet_rssi(packet.packet_hash)\n                self.snr = RNS.Reticulum.get_instance().get_packet_snr(packet.packet_hash)\n                self.q = RNS.Reticulum.get_instance().get_packet_q(packet.packet_hash)\n            else:\n                # ... existing local cache lookup\n        except Exception as e:\n            RNS.log(f\"Could not update physical layer stats: {e}\", RNS.LOG_DEBUG)\n            # Stats remain None, but packet processing continues\n```\n\n**Pros**: Immediate fix, no user action required\n**Cons**: Diverges from upstream RNS\n\n### Option 2: Configure RPC Key\n\nAllow users to paste the RPC key from Sideband (Settings → Connectivity → \"Share Instance Access\").\n\n**Pros**: Enables full stats functionality\n**Cons**: Requires user action, key management\n\n### Option 3: Both Approaches\n\nPatch for resilience + allow RPC key for full functionality.\n\n**Pros**: Best of both worlds\n**Cons**: More implementation work\n\n### Option 4: Upstream PR\n\nSubmit fix to Reticulum repository.\n\n**Pros**: Fixes for everyone\n**Cons**: Dependent on upstream acceptance timeline\n\n---\n\n## Sideband RPC Key Export\n\nLocation in Sideband: **Settings → Connectivity → \"Share Instance Access\"**\n\nThe exported config includes:\n```\nshared_instance_type = tcp\nrpc_key = <hex_key>\n```\n\n---\n\n---\n\n## Why Other RNS Clients Don't Have This Problem\n\n### NomadNet & MeshChat Approach\n\nBoth NomadNet and reticulum-meshchat use a simple initialization pattern:\n\n```python\n# NomadNet (nomadnet/NomadNetworkApp.py:95)\nself.rns = RNS.Reticulum(configdir=rnsconfigdir)\n\n# MeshChat (meshchat.py:113-115)\nself.reticulum = RNS.Reticulum(reticulum_config_dir)\n```\n\n**Why they work:** These are typically run on Linux/desktop systems where:\n- All apps can share the same `~/.reticulum` config directory\n- The RPC key is derived from the same identity file\n- RPC authentication succeeds because both sides use the same key\n\n### Sideband's Android Solution\n\nSideband explicitly handles the Android sandboxing problem:\n\n**File: `/home/tyler/repos/Sideband/sbapp/sideband/core.py:607-608`**\n```python\nself.identity = RNS.Identity.from_file(self.identity_path)\nself.rpc_key = RNS.Identity.full_hash(self.identity.get_private_key())\n```\n\n**File: `/home/tyler/repos/Sideband/sbapp/main.py:3914-3925`** - Export feature:\n```python\nrpc_string = \"shared_instance_type = tcp\\n\"\nrpc_string += \"rpc_key = \" + RNS.hexrep(self.sideband.reticulum.rpc_key, delimit=False)\n```\n\nSideband provides a UI to export this configuration, which other apps can paste into their Reticulum config.\n\n### The Columba Problem\n\nColumba is unique because:\n\n1. **Android sandbox**: Columba has its own app directory, can't read Sideband's config\n2. **Bundled Python**: Uses Chaquopy with its own RNS installation\n3. **Own identity**: Columba creates its own identity file (different from Sideband's)\n4. **Derived RPC key**: RNS derives RPC key from identity: `Identity.full_hash(private_key)`\n\nWhen Columba connects to Sideband's shared instance:\n- **Data routing works** (LocalClientInterface uses raw sockets)\n- **RPC fails** (Columba's derived key != Sideband's derived key)\n\n### RPC Key Configuration in RNS\n\n**File: `/home/tyler/repos/Reticulum/RNS/Reticulum.py:472-478`**\n```python\nif option == \"rpc_key\":\n    try:\n        value = bytes.fromhex(self.config[\"reticulum\"][option])\n        self.rpc_key = value\n    except Exception as e:\n        RNS.log(\"Invalid shared instance RPC key specified, falling back to default key\", RNS.LOG_ERROR)\n        self.rpc_key = None\n```\n\nRNS supports explicit RPC key configuration for exactly this scenario - when apps can't share config directories.\n\n---\n\n## Summary\n\n| Aspect | Status |\n|--------|--------|\n| Message delivery without RPC | Should work (bug prevents it) |\n| Root cause | Missing exception handling in `__update_phy_stats()` |\n| Why other clients work | They share config directories or explicitly configure RPC key |\n| Columba's issue | Android sandbox prevents config sharing, RPC key mismatch |\n| Interface configuration | Always disabled for shared instance clients |\n| Recommended fix | Patch RNS + support RPC key configuration in UI |"}],["entry_1770158460130_d8ks5k",{"id":"entry_1770158460130_d8ks5k","key":"columba-sideband-import","namespace":"codebase","content":"# Feature: Import Contacts from Destination Hash (Sideband Interoperability)\n\n## Overview\n\nEnable importing contacts using just a destination hash (32 hex characters) from Sideband's \"Copy Address\" feature, in addition to the existing full `lxma://` URL format. This enables seamless contact sharing between Sideband and Columba users.\n\n## Problem Statement\n\nSideband's \"Copy Address\" feature only copies the LXMF destination hash (32 hex characters), but Columba currently requires the full `lxma://hash:pubkey` format (~165 characters) which includes both the destination hash and the 128-character public key. This makes it difficult for users to import contacts from Sideband.\n\n### Technical Background\n\nThe relationship between identity components in Reticulum:\n\n```\nPublic Key (64 bytes / 128 hex chars)\n    ↓ SHA-256 + truncate\nIdentity Hash (16 bytes / 32 hex chars)\n    ↓ + destination name hash (\"lxmf.delivery\")\nDestination Hash (16 bytes / 32 hex chars)\n```\n\n**Key insight**: The destination hash cannot be reversed to obtain the public key (hashes are one-way functions). However, the public key can be retrieved from the network if the identity has announced itself.\n\n### How Sideband Shares Contacts\n\nFrom `sbapp/ui/conversations.py`:\n```python\ndef gen_copy_addr(item):\n    def x():\n        Clipboard.copy(RNS.hexrep(self.conversation_dropdown.context_dest, delimit=False))\n    return x\n```\n\nThis copies only the 32-character destination hash.\n\n## Solution\n\nDetect input format in the Add Contact Manually dialog and handle accordingly:\n\n| Input Format | Action |\n|-------------|--------|\n| Full `lxma://` URL | Add contact immediately (existing behavior) |\n| 32-char destination hash | Create \"pending\" contact, resolve public key via network |\n\n---\n\n## Detailed Implementation Plan\n\n### 1. Data Model Changes\n\n**File:** `data/src/main/java/com/lxmf/messenger/data/db/entity/ContactEntity.kt`\n\n#### Add ContactStatus Enum\n\n```kotlin\n/**\n * Represents the resolution status of a contact's identity.\n */\nenum class ContactStatus {\n    /**\n     * Full identity is known (destination hash + public key).\n     * Contact can send and receive messages.\n     */\n    ACTIVE,\n\n    /**\n     * Only destination hash is known, awaiting public key from network.\n     * Contact cannot send messages until identity is resolved.\n     */\n    PENDING_IDENTITY,\n\n    /**\n     * Network search timed out without finding the identity.\n     * User can manually retry the search.\n     */\n    UNRESOLVED\n}\n```\n\n#### Update ContactEntity\n\n```kotlin\n@Entity(tableName = \"contacts\")\ndata class ContactEntity(\n    @PrimaryKey\n    val destinationHash: String,\n    val identityHash: String,\n    val publicKey: ByteArray?,  // Now nullable for pending contacts\n    val customNickname: String? = null,\n    val notes: String? = null,\n    val tags: String? = null,\n    val addedTimestamp: Long,\n    val addedVia: String,\n    val lastInteractionTimestamp: Long = 0,\n    val isPinned: Boolean = false,\n    val status: ContactStatus = ContactStatus.ACTIVE  // NEW FIELD\n) {\n    // ... existing equals/hashCode\n}\n```\n\n#### Database Migration\n\n```kotlin\nval MIGRATION_X_Y = object : Migration(X, Y) {\n    override fun migrate(database: SupportSQLiteDatabase) {\n        database.execSQL(\n            \"ALTER TABLE contacts ADD COLUMN status TEXT NOT NULL DEFAULT 'ACTIVE'\"\n        )\n    }\n}\n```\n\n---\n\n### 2. Validation Changes\n\n**File:** `app/src/main/java/com/lxmf/messenger/util/validation/InputValidator.kt`\n\n#### Add IdentityInput Sealed Class\n\n```kotlin\n/**\n * Represents parsed identity input from user.\n * Can be either a full identity (hash + pubkey) or just a destination hash.\n */\nsealed class IdentityInput {\n    /**\n     * Full identity with both destination hash and public key.\n     * Can be added as an active contact immediately.\n     */\n    data class FullIdentity(\n        val destinationHash: String,\n        val publicKey: ByteArray\n    ) : IdentityInput()\n\n    /**\n     * Only destination hash available.\n     * Must resolve public key from network before messaging.\n     */\n    data class DestinationHashOnly(\n        val destinationHash: String\n    ) : IdentityInput()\n}\n```\n\n#### Add parseIdentityInput Function\n\n```kotlin\n/**\n * Parses user input and determines the identity format.\n *\n * Supports two formats:\n * 1. Full lxma:// URL: \"lxma://<32-char-hash>:<128-char-pubkey>\"\n * 2. Destination hash only: 32 hexadecimal characters\n *\n * @param input Raw user input string\n * @return ValidationResult containing parsed IdentityInput or error message\n */\nfun parseIdentityInput(input: String): ValidationResult<IdentityInput> {\n    val trimmed = input.trim().lowercase()\n\n    // Check for empty input\n    if (trimmed.isEmpty()) {\n        return ValidationResult.Error(\"Please enter an identity string or destination hash\")\n    }\n\n    // Try full lxma:// format first\n    if (trimmed.startsWith(LXMF_IDENTITY_PREFIX)) {\n        return when (val result = validateIdentityString(trimmed)) {\n            is ValidationResult.Success -> {\n                val parts = trimmed.removePrefix(LXMF_IDENTITY_PREFIX).split(\":\")\n                val destHash = parts[0]\n                val pubKeyHex = parts[1]\n                val pubKeyBytes = pubKeyHex.chunked(2)\n                    .map { it.toInt(16).toByte() }\n                    .toByteArray()\n                ValidationResult.Success(IdentityInput.FullIdentity(destHash, pubKeyBytes))\n            }\n            is ValidationResult.Error -> result\n        }\n    }\n\n    // Try destination hash only (32 hex chars)\n    if (trimmed.length == DESTINATION_HASH_LENGTH * 2) {\n        // Validate it's valid hex\n        if (!HEX_REGEX.matches(trimmed)) {\n            return ValidationResult.Error(\n                \"Invalid destination hash: must contain only hexadecimal characters (0-9, a-f)\"\n            )\n        }\n        return ValidationResult.Success(IdentityInput.DestinationHashOnly(trimmed))\n    }\n\n    // Neither format matches\n    return ValidationResult.Error(\n        \"Invalid format. Enter either:\\n\" +\n        \"• Full identity: lxma://hash:pubkey\\n\" +\n        \"• Destination hash: 32 hexadecimal characters\"\n    )\n}\n```\n\n---\n\n### 3. Repository Changes\n\n**File:** `data/src/main/java/com/lxmf/messenger/data/repository/ContactRepository.kt`\n\n#### Add New Methods\n\n```kotlin\n/**\n * Adds a contact with only a destination hash (pending identity resolution).\n *\n * The contact will be created with PENDING_IDENTITY status and a null public key.\n * Background workers will attempt to resolve the identity from the network.\n *\n * @param destinationHash The 32-character hex destination hash\n * @param nickname Optional display name for the contact\n * @return Result indicating success or failure\n */\nsuspend fun addPendingContact(\n    destinationHash: String,\n    nickname: String? = null\n): Result<Unit> = withContext(Dispatchers.IO) {\n    try {\n        val activeIdentityHash = identityManager.getActiveIdentityHash()\n            ?: return@withContext Result.failure(IllegalStateException(\"No active identity\"))\n\n        val contact = ContactEntity(\n            destinationHash = destinationHash,\n            identityHash = activeIdentityHash,\n            publicKey = null,  // Will be filled when identity is resolved\n            customNickname = nickname,\n            addedTimestamp = System.currentTimeMillis(),\n            addedVia = \"MANUAL_PENDING\",\n            status = ContactStatus.PENDING_IDENTITY\n        )\n\n        contactDao.insertContact(contact)\n        Result.success(Unit)\n    } catch (e: Exception) {\n        Log.e(TAG, \"Failed to add pending contact\", e)\n        Result.failure(e)\n    }\n}\n\n/**\n * Updates a pending contact with resolved identity information.\n *\n * Called when the network returns the public key for a pending contact.\n * Changes status from PENDING_IDENTITY to ACTIVE.\n *\n * @param destinationHash The contact's destination hash\n * @param publicKey The resolved 64-byte public key\n * @return Result indicating success or failure\n */\nsuspend fun updateContactWithIdentity(\n    destinationHash: String,\n    publicKey: ByteArray\n): Result<Unit> = withContext(Dispatchers.IO) {\n    try {\n        contactDao.updateContactIdentity(\n            destinationHash = destinationHash,\n            publicKey = publicKey,\n            status = ContactStatus.ACTIVE\n        )\n        Result.success(Unit)\n    } catch (e: Exception) {\n        Log.e(TAG, \"Failed to update contact identity\", e)\n        Result.failure(e)\n    }\n}\n\n/**\n * Updates a contact's status (e.g., to UNRESOLVED after timeout).\n */\nsuspend fun updateContactStatus(\n    destinationHash: String,\n    status: ContactStatus\n): Result<Unit> = withContext(Dispatchers.IO) {\n    try {\n        contactDao.updateContactStatus(destinationHash, status)\n        Result.success(Unit)\n    } catch (e: Exception) {\n        Result.failure(e)\n    }\n}\n\n/**\n * Gets all contacts with specified statuses.\n */\nsuspend fun getContactsByStatus(\n    statuses: List<ContactStatus>\n): List<ContactEntity> = withContext(Dispatchers.IO) {\n    contactDao.getContactsByStatus(statuses.map { it.name })\n}\n```\n\n#### Add DAO Methods\n\n```kotlin\n@Dao\ninterface ContactDao {\n    // ... existing methods\n\n    @Query(\"\"\"\n        UPDATE contacts\n        SET publicKey = :publicKey, status = :status\n        WHERE destinationHash = :destinationHash\n    \"\"\")\n    suspend fun updateContactIdentity(\n        destinationHash: String,\n        publicKey: ByteArray,\n        status: ContactStatus\n    )\n\n    @Query(\"UPDATE contacts SET status = :status WHERE destinationHash = :destinationHash\")\n    suspend fun updateContactStatus(destinationHash: String, status: ContactStatus)\n\n    @Query(\"SELECT * FROM contacts WHERE status IN (:statuses)\")\n    suspend fun getContactsByStatus(statuses: List<String>): List<ContactEntity>\n}\n```\n\n---\n\n### 4. ViewModel Changes\n\n**File:** `app/src/main/java/com/lxmf/messenger/viewmodel/ContactsViewModel.kt`\n\n#### Add Result Sealed Class\n\n```kotlin\n/**\n * Result of attempting to add a contact.\n */\nsealed class AddContactResult {\n    /**\n     * Contact added successfully with full identity.\n     * Can message immediately.\n     */\n    object Success : AddContactResult()\n\n    /**\n     * Contact added with pending identity.\n     * Waiting for network to resolve public key.\n     */\n    object PendingIdentity : AddContactResult()\n\n    /**\n     * Failed to add contact.\n     */\n    data class Error(val message: String) : AddContactResult()\n}\n```\n\n#### Add Contact Addition Method\n\n```kotlin\n/**\n * Adds a contact from user input, handling both full identity and hash-only formats.\n *\n * Flow:\n * 1. Parse and validate input format\n * 2. For full identity: add immediately as ACTIVE\n * 3. For hash-only:\n *    a. Check local cache for identity (Identity.recall)\n *    b. If found: add as ACTIVE\n *    c. If not found: add as PENDING_IDENTITY, request from network\n *\n * @param input User input (lxma:// URL or destination hash)\n * @param nickname Optional display name\n * @return AddContactResult indicating outcome\n */\nsuspend fun addContact(input: String, nickname: String?): AddContactResult {\n    // Parse input\n    val parsed = InputValidator.parseIdentityInput(input)\n    if (parsed is ValidationResult.Error) {\n        return AddContactResult.Error(parsed.message)\n    }\n\n    val identityInput = (parsed as ValidationResult.Success).value\n\n    return when (identityInput) {\n        is IdentityInput.FullIdentity -> {\n            // Full identity provided - add immediately\n            val result = contactRepository.addContactFromQrCode(\n                destinationHash = identityInput.destinationHash,\n                publicKey = identityInput.publicKey,\n                nickname = nickname\n            )\n            if (result.isSuccess) {\n                AddContactResult.Success\n            } else {\n                AddContactResult.Error(result.exceptionOrNull()?.message ?: \"Unknown error\")\n            }\n        }\n\n        is IdentityInput.DestinationHashOnly -> {\n            // Only hash - try to resolve identity\n            val destHashBytes = identityInput.destinationHash\n                .chunked(2)\n                .map { it.toInt(16).toByte() }\n                .toByteArray()\n\n            // Try local cache first\n            val cachedIdentity = reticulumService.recallIdentity(destHashBytes)\n\n            if (cachedIdentity != null) {\n                // Found in cache - add with full identity\n                val result = contactRepository.addContactFromQrCode(\n                    destinationHash = identityInput.destinationHash,\n                    publicKey = cachedIdentity.publicKey,\n                    nickname = nickname\n                )\n                if (result.isSuccess) {\n                    AddContactResult.Success\n                } else {\n                    AddContactResult.Error(result.exceptionOrNull()?.message ?: \"Unknown error\")\n                }\n            } else {\n                // Not in cache - create pending contact\n                val result = contactRepository.addPendingContact(\n                    destinationHash = identityInput.destinationHash,\n                    nickname = nickname\n                )\n\n                if (result.isSuccess) {\n                    // Request identity from network\n                    reticulumService.requestPath(destHashBytes)\n                    AddContactResult.PendingIdentity\n                } else {\n                    AddContactResult.Error(result.exceptionOrNull()?.message ?: \"Unknown error\")\n                }\n            }\n        }\n    }\n}\n\n/**\n * Retries identity resolution for an unresolved contact.\n */\nsuspend fun retryIdentityResolution(destinationHash: String) {\n    // Reset status to pending\n    contactRepository.updateContactStatus(destinationHash, ContactStatus.PENDING_IDENTITY)\n\n    // Request from network again\n    val destHashBytes = destinationHash\n        .chunked(2)\n        .map { it.toInt(16).toByte() }\n        .toByteArray()\n    reticulumService.requestPath(destHashBytes)\n}\n```\n\n---\n\n### 5. Reticulum Service Integration\n\n**File:** `reticulum/src/main/java/com/lxmf/messenger/reticulum/ReticulumService.kt`\n\n#### Add Identity Resolution Methods\n\n```kotlin\n/**\n * Attempts to recall an identity from local cache.\n *\n * This checks Reticulum's known_destinations cache for a previously\n * seen identity matching the destination hash.\n *\n * @param destinationHash The 16-byte destination hash\n * @return Identity if found in cache, null otherwise\n */\nsuspend fun recallIdentity(destinationHash: ByteArray): Identity? {\n    return withContext(Dispatchers.IO) {\n        try {\n            // Call Python: RNS.Identity.recall(destination_hash)\n            val result = pythonBridge.call(\n                \"recall_identity\",\n                mapOf(\"destination_hash\" to destinationHash.toHexString())\n            )\n\n            if (result != null && result.containsKey(\"public_key\")) {\n                Identity(\n                    publicKey = (result[\"public_key\"] as String).hexToByteArray(),\n                    hash = destinationHash\n                )\n            } else {\n                null\n            }\n        } catch (e: Exception) {\n            Log.w(TAG, \"Failed to recall identity: ${e.message}\")\n            null\n        }\n    }\n}\n\n/**\n * Requests a path to a destination from the network.\n *\n * Broadcasts a path request - if any peer knows the destination,\n * they will respond with an announce containing the public key.\n *\n * @param destinationHash The 16-byte destination hash to find\n */\nsuspend fun requestPath(destinationHash: ByteArray) {\n    withContext(Dispatchers.IO) {\n        try {\n            // Call Python: RNS.Transport.request_path(destination_hash)\n            pythonBridge.call(\n                \"request_path\",\n                mapOf(\"destination_hash\" to destinationHash.toHexString())\n            )\n            Log.d(TAG, \"Requested path for ${destinationHash.toHexString()}\")\n        } catch (e: Exception) {\n            Log.e(TAG, \"Failed to request path: ${e.message}\")\n        }\n    }\n}\n\n/**\n * Data class representing a Reticulum identity.\n */\ndata class Identity(\n    val publicKey: ByteArray,\n    val hash: ByteArray\n)\n```\n\n---\n\n### 6. UI Changes\n\n**File:** `app/src/main/java/com/lxmf/messenger/ui/screens/ContactsScreen.kt`\n\n#### 6.1 Update ManualEntryDialog\n\n```kotlin\n@Composable\nfun ManualEntryDialog(\n    onDismiss: () -> Unit,\n    onConfirm: (String, String?) -> Unit,\n    viewModel: ContactsViewModel = hiltViewModel()\n) {\n    var identityString by remember { mutableStateOf(\"\") }\n    var nickname by remember { mutableStateOf(\"\") }\n    var errorMessage by remember { mutableStateOf<String?>(null) }\n    var isLoading by remember { mutableStateOf(false) }\n    var showPendingInfo by remember { mutableStateOf(false) }\n\n    // Handle pending info dialog\n    if (showPendingInfo) {\n        PendingContactInfoDialog(\n            onDismiss = {\n                showPendingInfo = false\n                onDismiss()\n            }\n        )\n        return\n    }\n\n    AlertDialog(\n        onDismissRequest = onDismiss,\n        title = { Text(\"Add Contact Manually\") },\n        text = {\n            Column {\n                OutlinedTextField(\n                    value = identityString,\n                    onValueChange = {\n                        identityString = it.trim()\n                        errorMessage = null\n                    },\n                    label = { Text(\"Identity\") },\n                    placeholder = { Text(\"lxma://... or 32-char hash\") },\n                    supportingText = {\n                        if (errorMessage != null) {\n                            Text(errorMessage!!, color = MaterialTheme.colorScheme.error)\n                        } else {\n                            Text(\"Paste full lxma:// URL or destination hash from Sideband\")\n                        }\n                    },\n                    isError = errorMessage != null,\n                    maxLines = 4,\n                    modifier = Modifier.fillMaxWidth()\n                )\n\n                Spacer(modifier = Modifier.height(8.dp))\n\n                OutlinedTextField(\n                    value = nickname,\n                    onValueChange = {\n                        if (it.length <= ValidationConstants.MAX_NICKNAME_LENGTH) {\n                            nickname = it\n                        }\n                    },\n                    label = { Text(\"Nickname (optional)\") },\n                    supportingText = {\n                        Text(\"${nickname.length}/${ValidationConstants.MAX_NICKNAME_LENGTH}\")\n                    },\n                    singleLine = true,\n                    modifier = Modifier.fillMaxWidth()\n                )\n            }\n        },\n        confirmButton = {\n            Button(\n                onClick = {\n                    isLoading = true\n                    viewModel.viewModelScope.launch {\n                        when (val result = viewModel.addContact(identityString, nickname.ifBlank { null })) {\n                            is AddContactResult.Success -> {\n                                onDismiss()\n                            }\n                            is AddContactResult.PendingIdentity -> {\n                                showPendingInfo = true\n                            }\n                            is AddContactResult.Error -> {\n                                errorMessage = result.message\n                                isLoading = false\n                            }\n                        }\n                    }\n                },\n                enabled = identityString.isNotBlank() && !isLoading\n            ) {\n                if (isLoading) {\n                    CircularProgressIndicator(\n                        modifier = Modifier.size(16.dp),\n                        strokeWidth = 2.dp\n                    )\n                } else {\n                    Text(\"Add\")\n                }\n            }\n        },\n        dismissButton = {\n            TextButton(onClick = onDismiss) {\n                Text(\"Cancel\")\n            }\n        }\n    )\n}\n```\n\n#### 6.2 Pending Contact Info Dialog\n\n```kotlin\n/**\n * Informational dialog shown after adding a contact with only a destination hash.\n * Explains that the app is searching for the contact's identity on the network.\n */\n@Composable\nfun PendingContactInfoDialog(onDismiss: () -> Unit) {\n    AlertDialog(\n        onDismissRequest = onDismiss,\n        icon = {\n            Icon(\n                Icons.Outlined.Info,\n                contentDescription = null,\n                tint = MaterialTheme.colorScheme.primary\n            )\n        },\n        title = { Text(\"Contact Added\") },\n        text = {\n            Column {\n                Text(\n                    \"This contact was added with just a destination hash.\",\n                    style = MaterialTheme.typography.bodyMedium\n                )\n                Spacer(modifier = Modifier.height(8.dp))\n                Text(\n                    \"Columba is now searching the network for their public key. \" +\n                    \"You'll be able to message them once their identity is found.\",\n                    style = MaterialTheme.typography.bodyMedium,\n                    color = MaterialTheme.colorScheme.onSurfaceVariant\n                )\n                Spacer(modifier = Modifier.height(8.dp))\n                Text(\n                    \"This may take a few minutes if they're online, or longer if they're offline.\",\n                    style = MaterialTheme.typography.bodySmall,\n                    color = MaterialTheme.colorScheme.onSurfaceVariant\n                )\n            }\n        },\n        confirmButton = {\n            TextButton(onClick = onDismiss) {\n                Text(\"Got it\")\n            }\n        }\n    )\n}\n```\n\n#### 6.3 Contact List Item with Status Indicators\n\n```kotlin\n/**\n * Contact list item with visual indicators for pending/unresolved status.\n */\n@Composable\nfun ContactListItem(\n    contact: EnrichedContact,\n    onClick: () -> Unit,\n    onPendingClick: () -> Unit,  // Opens bottom sheet for pending contacts\n    modifier: Modifier = Modifier\n) {\n    val isPending = contact.status == ContactStatus.PENDING_IDENTITY\n    val isUnresolved = contact.status == ContactStatus.UNRESOLVED\n\n    ListItem(\n        modifier = modifier.clickable {\n            if (isPending || isUnresolved) {\n                onPendingClick()\n            } else {\n                onClick()\n            }\n        },\n        headlineContent = {\n            Text(\n                text = contact.displayName,\n                color = if (isPending || isUnresolved) {\n                    MaterialTheme.colorScheme.onSurfaceVariant\n                } else {\n                    MaterialTheme.colorScheme.onSurface\n                }\n            )\n        },\n        supportingContent = {\n            when (contact.status) {\n                ContactStatus.PENDING_IDENTITY -> {\n                    Row(\n                        verticalAlignment = Alignment.CenterVertically,\n                        horizontalArrangement = Arrangement.spacedBy(4.dp)\n                    ) {\n                        CircularProgressIndicator(\n                            modifier = Modifier.size(12.dp),\n                            strokeWidth = 2.dp,\n                            color = MaterialTheme.colorScheme.primary\n                        )\n                        Text(\n                            text = \"Searching for identity...\",\n                            style = MaterialTheme.typography.bodySmall,\n                            color = MaterialTheme.colorScheme.onSurfaceVariant\n                        )\n                    }\n                }\n                ContactStatus.UNRESOLVED -> {\n                    Row(\n                        verticalAlignment = Alignment.CenterVertically,\n                        horizontalArrangement = Arrangement.spacedBy(4.dp)\n                    ) {\n                        Icon(\n                            imageVector = Icons.Outlined.ErrorOutline,\n                            contentDescription = null,\n                            modifier = Modifier.size(12.dp),\n                            tint = MaterialTheme.colorScheme.error\n                        )\n                        Text(\n                            text = \"Identity not found - tap to retry\",\n                            style = MaterialTheme.typography.bodySmall,\n                            color = MaterialTheme.colorScheme.error\n                        )\n                    }\n                }\n                else -> {\n                    // Normal online/offline status\n                    if (contact.isOnline) {\n                        Text(\n                            text = \"Online\",\n                            style = MaterialTheme.typography.bodySmall,\n                            color = MaterialTheme.colorScheme.primary\n                        )\n                    }\n                }\n            }\n        },\n        leadingContent = {\n            // Avatar with status overlay\n            Box {\n                ContactAvatar(contact = contact)\n                if (isPending || isUnresolved) {\n                    Box(\n                        modifier = Modifier\n                            .align(Alignment.BottomEnd)\n                            .size(12.dp)\n                            .background(\n                                if (isUnresolved) MaterialTheme.colorScheme.error\n                                else MaterialTheme.colorScheme.primary,\n                                CircleShape\n                            )\n                    ) {\n                        Icon(\n                            imageVector = if (isUnresolved)\n                                Icons.Outlined.QuestionMark\n                            else\n                                Icons.Outlined.HourglassEmpty,\n                            contentDescription = null,\n                            modifier = Modifier.size(8.dp),\n                            tint = MaterialTheme.colorScheme.onPrimary\n                        )\n                    }\n                }\n            }\n        }\n    )\n}\n```\n\n#### 6.4 Pending Contact Bottom Sheet\n\n```kotlin\n/**\n * Bottom sheet shown when tapping a pending or unresolved contact.\n * Provides information about the status and actions to retry or delete.\n */\n@OptIn(ExperimentalMaterial3Api::class)\n@Composable\nfun PendingContactBottomSheet(\n    contact: EnrichedContact,\n    onDismiss: () -> Unit,\n    onRetrySearch: () -> Unit,\n    onDelete: () -> Unit\n) {\n    val isUnresolved = contact.status == ContactStatus.UNRESOLVED\n\n    ModalBottomSheet(\n        onDismissRequest = onDismiss,\n        containerColor = MaterialTheme.colorScheme.surface\n    ) {\n        Column(\n            modifier = Modifier\n                .fillMaxWidth()\n                .padding(24.dp),\n            horizontalAlignment = Alignment.CenterHorizontally\n        ) {\n            // Status icon\n            Icon(\n                imageVector = if (isUnresolved)\n                    Icons.Outlined.ErrorOutline\n                else\n                    Icons.Outlined.HourglassEmpty,\n                contentDescription = null,\n                modifier = Modifier.size(48.dp),\n                tint = if (isUnresolved)\n                    MaterialTheme.colorScheme.error\n                else\n                    MaterialTheme.colorScheme.primary\n            )\n\n            Spacer(modifier = Modifier.height(16.dp))\n\n            // Title\n            Text(\n                text = if (isUnresolved)\n                    \"Identity Not Found\"\n                else\n                    \"Searching for Identity\",\n                style = MaterialTheme.typography.titleLarge,\n                textAlign = TextAlign.Center\n            )\n\n            Spacer(modifier = Modifier.height(8.dp))\n\n            // Contact name\n            Text(\n                text = contact.displayName,\n                style = MaterialTheme.typography.titleMedium,\n                color = MaterialTheme.colorScheme.onSurfaceVariant\n            )\n\n            Spacer(modifier = Modifier.height(16.dp))\n\n            // Explanation\n            Text(\n                text = if (isUnresolved)\n                    \"Columba couldn't find this contact's public key on the network. \" +\n                    \"They may need to come online and announce their presence, or the \" +\n                    \"destination hash may be incorrect.\"\n                else\n                    \"Columba is searching the Reticulum network for this contact's \" +\n                    \"public key. You'll be able to message them once their identity \" +\n                    \"is found. This typically happens when they come online.\",\n                style = MaterialTheme.typography.bodyMedium,\n                textAlign = TextAlign.Center,\n                color = MaterialTheme.colorScheme.onSurfaceVariant\n            )\n\n            Spacer(modifier = Modifier.height(8.dp))\n\n            // Destination hash (for verification)\n            Text(\n                text = \"Destination: ${contact.destinationHash.take(8)}...${contact.destinationHash.takeLast(8)}\",\n                style = MaterialTheme.typography.bodySmall,\n                fontFamily = FontFamily.Monospace,\n                color = MaterialTheme.colorScheme.onSurfaceVariant\n            )\n\n            Spacer(modifier = Modifier.height(24.dp))\n\n            // Retry button\n            Button(\n                onClick = {\n                    onRetrySearch()\n                    onDismiss()\n                },\n                modifier = Modifier.fillMaxWidth()\n            ) {\n                Icon(\n                    imageVector = Icons.Default.Refresh,\n                    contentDescription = null,\n                    modifier = Modifier.size(18.dp)\n                )\n                Spacer(modifier = Modifier.width(8.dp))\n                Text(\"Search Network Again\")\n            }\n\n            Spacer(modifier = Modifier.height(8.dp))\n\n            // Delete button\n            TextButton(\n                onClick = {\n                    onDelete()\n                    onDismiss()\n                },\n                modifier = Modifier.fillMaxWidth()\n            ) {\n                Text(\n                    text = \"Remove Contact\",\n                    color = MaterialTheme.colorScheme.error\n                )\n            }\n\n            // Bottom padding for navigation bar\n            Spacer(modifier = Modifier.height(16.dp))\n        }\n    }\n}\n```\n\n---\n\n### 7. Background Identity Resolution\n\n**File:** `app/src/main/java/com/lxmf/messenger/service/IdentityResolutionWorker.kt` (new file)\n\n```kotlin\npackage com.lxmf.messenger.service\n\nimport android.content.Context\nimport android.util.Log\nimport androidx.hilt.work.HiltWorker\nimport androidx.work.*\nimport dagger.assisted.Assisted\nimport dagger.assisted.AssistedInject\nimport com.lxmf.messenger.data.db.entity.ContactStatus\nimport com.lxmf.messenger.data.repository.ContactRepository\nimport com.lxmf.messenger.reticulum.ReticulumService\nimport java.util.concurrent.TimeUnit\n\n/**\n * Background worker that periodically checks for resolved identities.\n *\n * This worker:\n * 1. Queries all contacts with PENDING_IDENTITY status\n * 2. For each, checks if identity is now in local cache (from network announce)\n * 3. If found, updates contact to ACTIVE with the public key\n * 4. If not found and timeout exceeded, marks as UNRESOLVED\n *\n * Runs every 15 minutes while the app has pending contacts.\n */\n@HiltWorker\nclass IdentityResolutionWorker @AssistedInject constructor(\n    @Assisted context: Context,\n    @Assisted workerParams: WorkerParameters,\n    private val contactRepository: ContactRepository,\n    private val reticulumService: ReticulumService\n) : CoroutineWorker(context, workerParams) {\n\n    override suspend fun doWork(): Result {\n        Log.d(TAG, \"Starting identity resolution check\")\n\n        try {\n            val pendingContacts = contactRepository.getContactsByStatus(\n                listOf(ContactStatus.PENDING_IDENTITY)\n            )\n\n            if (pendingContacts.isEmpty()) {\n                Log.d(TAG, \"No pending contacts to resolve\")\n                return Result.success()\n            }\n\n            Log.d(TAG, \"Checking ${pendingContacts.size} pending contacts\")\n\n            for (contact in pendingContacts) {\n                checkContact(contact)\n            }\n\n            return Result.success()\n        } catch (e: Exception) {\n            Log.e(TAG, \"Identity resolution failed\", e)\n            return Result.retry()\n        }\n    }\n\n    private suspend fun checkContact(contact: ContactEntity) {\n        val destHashBytes = contact.destinationHash\n            .chunked(2)\n            .map { it.toInt(16).toByte() }\n            .toByteArray()\n\n        // Check if identity now available in cache\n        val identity = reticulumService.recallIdentity(destHashBytes)\n\n        if (identity != null) {\n            // Found! Update to ACTIVE\n            Log.i(TAG, \"Resolved identity for ${contact.destinationHash}\")\n            contactRepository.updateContactWithIdentity(\n                contact.destinationHash,\n                identity.publicKey\n            )\n        } else {\n            // Check timeout\n            val elapsed = System.currentTimeMillis() - contact.addedTimestamp\n            if (elapsed > RESOLUTION_TIMEOUT_MS) {\n                Log.w(TAG, \"Identity resolution timed out for ${contact.destinationHash}\")\n                contactRepository.updateContactStatus(\n                    contact.destinationHash,\n                    ContactStatus.UNRESOLVED\n                )\n            } else {\n                // Still within timeout, re-request path\n                Log.d(TAG, \"Re-requesting path for ${contact.destinationHash}\")\n                reticulumService.requestPath(destHashBytes)\n            }\n        }\n    }\n\n    companion object {\n        private const val TAG = \"IdentityResolutionWorker\"\n        private const val WORK_NAME = \"identity_resolution\"\n\n        /**\n         * Timeout before marking contact as UNRESOLVED (48 hours)\n         */\n        const val RESOLUTION_TIMEOUT_MS = 48 * 60 * 60 * 1000L\n\n        /**\n         * Schedules periodic identity resolution checks.\n         */\n        fun schedule(context: Context) {\n            val constraints = Constraints.Builder()\n                .setRequiredNetworkType(NetworkType.CONNECTED)\n                .build()\n\n            val workRequest = PeriodicWorkRequestBuilder<IdentityResolutionWorker>(\n                15, TimeUnit.MINUTES\n            )\n                .setConstraints(constraints)\n                .setBackoffCriteria(\n                    BackoffPolicy.EXPONENTIAL,\n                    1, TimeUnit.MINUTES\n                )\n                .build()\n\n            WorkManager.getInstance(context)\n                .enqueueUniquePeriodicWork(\n                    WORK_NAME,\n                    ExistingPeriodicWorkPolicy.KEEP,\n                    workRequest\n                )\n        }\n\n        /**\n         * Triggers an immediate identity resolution check.\n         */\n        fun runNow(context: Context) {\n            val workRequest = OneTimeWorkRequestBuilder<IdentityResolutionWorker>()\n                .build()\n\n            WorkManager.getInstance(context)\n                .enqueue(workRequest)\n        }\n    }\n}\n```\n\n---\n\n### 8. Application Initialization\n\n**File:** `app/src/main/java/com/lxmf/messenger/ColumbaApplication.kt`\n\nAdd worker scheduling in `onCreate()`:\n\n```kotlin\noverride fun onCreate() {\n    super.onCreate()\n    // ... existing initialization\n\n    // Schedule identity resolution worker\n    IdentityResolutionWorker.schedule(this)\n}\n```\n\n---\n\n## Material Design Compliance\n\n### Visual Elements\n\n| Element | Usage | Specification |\n|---------|-------|---------------|\n| `CircularProgressIndicator` | Inline pending state | Size: 12.dp, strokeWidth: 2.dp |\n| `Icons.Outlined.HourglassEmpty` | Pending status | Size: 12.dp (inline), 48.dp (sheet) |\n| `Icons.Outlined.ErrorOutline` | Unresolved status | Error color tint |\n| `Icons.Outlined.Info` | Info dialog icon | Primary color tint |\n| `Icons.Default.Refresh` | Retry button | In Button with text |\n| `ModalBottomSheet` | Contact info sheet | Material 3 pattern |\n| `AlertDialog` | Confirmations/info | Standard M3 dialogs |\n\n### Color Usage\n\n| State | Color | Token |\n|-------|-------|-------|\n| Pending text | Muted | `onSurfaceVariant` |\n| Pending icon | Primary | `primary` |\n| Unresolved text | Error | `error` |\n| Unresolved icon | Error | `error` |\n| Delete button | Error | `error` |\n\n### Interaction Patterns\n\n1. **Dialog closes on successful add** (both full and pending)\n2. **Info dialog appears** after pending add to explain state\n3. **Tapping pending/unresolved contact** opens info bottom sheet\n4. **Bottom sheet actions**: \"Search Network Again\" (primary) and \"Remove Contact\" (destructive)\n5. **Contact list items** remain tappable but route to info sheet instead of conversation\n\n---\n\n## Files Summary\n\n### Files to Modify\n\n| File | Changes |\n|------|---------|\n| `ContactEntity.kt` | Add `status` enum field, make `publicKey` nullable |\n| `ContactDao.kt` | Add update methods for status and identity |\n| `ContactRepository.kt` | Add `addPendingContact()`, `updateContactWithIdentity()`, `updateContactStatus()` |\n| `InputValidator.kt` | Add `IdentityInput` sealed class, `parseIdentityInput()` function |\n| `ContactsViewModel.kt` | Add `AddContactResult`, `addContact()`, `retryIdentityResolution()` |\n| `ContactsScreen.kt` | Update dialog, add pending indicators, add bottom sheet |\n| `ReticulumService.kt` | Add `recallIdentity()`, `requestPath()` |\n| `ColumbaApplication.kt` | Schedule identity resolution worker |\n| Database migration | Add `status` column with default `ACTIVE` |\n\n### New Files\n\n| File | Purpose |\n|------|---------|\n| `IdentityResolutionWorker.kt` | Background polling for identity resolution |\n\n---\n\n## Testing Scenarios\n\n| # | Scenario | Expected Behavior |\n|---|----------|-------------------|\n| 1 | Full lxma:// URL input | Contact added immediately as ACTIVE |\n| 2 | Valid 32-char hex input | Contact added as PENDING_IDENTITY, info dialog shown |\n| 3 | Hash with cached identity | Contact added immediately as ACTIVE (cache hit) |\n| 4 | Network resolution | PENDING_IDENTITY becomes ACTIVE when announce received |\n| 5 | Invalid input | Error message shown, dialog stays open |\n| 6 | Timeout (48h) | PENDING_IDENTITY marked as UNRESOLVED |\n| 7 | Retry search | UNRESOLVED reset to PENDING_IDENTITY, path requested |\n| 8 | Tap pending contact | Bottom sheet opens with correct state and actions |\n| 9 | Delete pending contact | Contact removed from database |\n\n---\n\n## Future Considerations\n\n- **Notification**: Alert user when pending contact becomes active\n- **Bulk import**: Import multiple contacts from file\n- **QR code fallback**: Prompt to scan QR if hash resolution fails\n- **Manual path request**: Button to force immediate network query\n- **Timeout configuration**: User-configurable resolution timeout"}],["entry_1770158678665_f5jzrw",{"id":"entry_1770158678665_f5jzrw","key":"reticulum-overview","namespace":"protocols","content":"Reticulum is a cryptography-based networking stack for building local and wide-area networks with readily available hardware. It operates even with very high latency (multi-second satellite links) and extremely low bandwidth (as low as 5 bits per second). DESIGN GOALS: (1) Coordination-less globally unique addressing - no central authority needed for address allocation, (2) Fully self-configuring multi-hop routing over heterogeneous carriers, (3) Initiator anonymity - no source addresses on packets, (4) Encryption by default using X25519/Ed25519/AES-256, (5) Forward secrecy for all communication types, (6) Hardware agnostic - runs on any medium supporting half-duplex with 5bps+ and 500 byte MTU, (7) No kernel modules needed - runs in userland Python 3. VISION: Allow anyone to be their own network operator. Create thousands of independent, inter-connectable networks without kill-switches, surveillance, censorship or central control. Reticulum is NOT one network - it is a TOOL for building networks. The reference implementation is Python, licensed under Reticulum License. Protocol dedicated to Public Domain in 2016. Performance envelope: 150 bps to 500 Mbps currently supported."}],["entry_1770158687682_etcp2j",{"id":"entry_1770158687682_etcp2j","key":"reticulum-transport","namespace":"protocols","content":"Reticulum Transport enables multi-hop packet delivery without any single node knowing the complete path. KEY CONCEPTS: (1) NODE TYPES - Reticulum Instances (all nodes) and Transport Nodes (explicitly enabled to forward traffic). Transport Nodes maintain path tables, propagate announces, and serve as distributed cryptographic keystores. (2) PATH DISCOVERY - Uses announce mechanism. When destination announces, Transport Nodes record it with hop count and retransmit (up to 128 hops max). Announces use randomized delay and bandwidth-limited queuing (2% default cap). (3) PACKET ROUTING - Each Transport Node knows only the next hop toward destination, not complete path. Packets addressed to destination hash are forwarded hop-by-hop. (4) ANNOUNCE PROPAGATION RULES - Ignored if already seen, recorded with hop count, forwarded with randomized delay, prioritized by hop count (local nodes first), retried if no higher-hop retransmission heard. (5) LINK ESTABLISHMENT - 3 packets totalling 297 bytes to establish encrypted verified link. Uses ECDH on Curve25519 for ephemeral keys. Link keepalive cost: 0.44 bits/second. (6) CONVERGENCE - Complex networks up to 128 hops converge to full connectivity in about 1 minute given sufficient bandwidth. Slow networks can still reach any destination via recursive path resolution from faster segments."}],["entry_1770158695127_k8wibd",{"id":"entry_1770158695127_k8wibd","key":"reticulum-identity","namespace":"protocols","content":"Reticulum Identity represents any verifiable entity - person, machine, sensor, program, or any agent that can act/be acted upon. CRYPTOGRAPHIC FOUNDATION: (1) 512-bit Elliptic Curve keyset consisting of 256-bit Ed25519 key for signatures and 256-bit X25519 key for ECDH key exchanges. (2) Identity Keys are the foundation for all cryptographic operations. USAGE: (1) Single destinations always have an Identity tied to them - if not provided at creation, one is auto-generated. (2) Multiple destinations can be created from single Identity. (3) Identity proves authenticity and enables encrypted channels. SECURITY: Private keys must be stored securely - access to Identity keys means access to all destinations created by that Identity. NETWORK IDENTITY: Special use of standard Identity to represent logical groups of nodes or community infrastructure. Functions as shared credential federating multiple Transport Instances under single verifiable administrative domain. Used for: (1) Interface discovery signing/verification, (2) Trust boundaries - accept only interfaces from specific Network Identities, (3) Encryption of discovery announces. Future uses: distributed name resolution, service publishing, inter-network federation, distributed blackhole management."}],["entry_1770158697917_a8q8z9",{"id":"entry_1770158697917_a8q8z9","key":"reticulum-src-reticulum","namespace":"protocols","content":"# Reticulum.py Analysis\n\n## Main Class: Reticulum\nSingleton class that initializes the entire RNS stack. Must be instantiated before any RNS operations.\n\n## Key Constants\n- MTU = 500 bytes (network maximum)\n- TRUNCATED_HASHLENGTH = 128 bits\n- HEADER_MINSIZE = 2+1+16 = 19 bytes\n- HEADER_MAXSIZE = 2+1+32 = 35 bytes\n- MDU = MTU - HEADER_MAXSIZE - IFAC_MIN_SIZE\n- ANNOUNCE_CAP = 2% of interface bandwidth for announces\n- DEFAULT_PER_HOP_TIMEOUT = 6 seconds\n- MINIMUM_BITRATE = 5 bps\n\n## Initialization Flow\n1. Load/create config from ~/.reticulum/config\n2. Create storage directories (cache, resources, identities)\n3. Load known destinations from storage\n4. Start Transport layer\n5. Set up RPC listener for shared instance communication\n6. Register exit handlers\n\n## Shared Instance Architecture\n- First RNS program becomes shared instance (server)\n- Other programs connect as clients via LocalInterface\n- RPC over multiprocessing.connection for control\n- Uses AF_UNIX on supported platforms, TCP otherwise\n\n## Key Configuration Options\n- enable_transport: Allow routing traffic for others\n- share_instance: Enable shared instance mode\n- remote_management_enabled: Allow remote management\n- discover_interfaces: Auto-discover network interfaces\n- link_mtu_discovery: Enable MTU optimization\n\n## Interface Modes\n- MODE_FULL: Standard bidirectional\n- MODE_ACCESS_POINT: Accept links, no forwarding\n- MODE_POINT_TO_POINT: Direct peer connection\n- MODE_ROAMING: Mobile/transient connections\n- MODE_BOUNDARY: Network edge\n- MODE_GATEWAY: Route between networks\n\n## Key Methods\n- __apply_config(): Parse and apply configuration\n- _synthesize_interface(): Create interface from config\n- get_path_table(): Return routing table\n- get_interface_stats(): Return interface statistics\n- rpc_loop(): Handle RPC calls from clients"}],["entry_1770158705668_920hu",{"id":"entry_1770158705668_920hu","key":"reticulum-destinations","namespace":"protocols","content":"Reticulum Destinations replace IP addresses+ports with single concept. All destinations represented as 16-byte (128-bit) truncated SHA-256 hash displayed as hex: <13425ec15b621c1d928589718000d814>. DESTINATION TYPES: (1) SINGLE - Most common, always tied to unique public key. Encrypted with ephemeral ECDH-derived keys. Only private key holder can decrypt. Supports multi-hop transport. (2) PLAIN - Unencrypted, for broadcast/public info. NOT transported over multiple hops (routing verification requires encryption). (3) GROUP - Symmetrically encrypted with preshared AES-256 key. Readable by anyone with key. Currently local only, planned upgrade for global reachability. (4) LINK - Abstract encrypted channel to Single destination. Offers reliability, efficient encryption, forward secrecy, initiator anonymity, request/response API. NAMING: Dotted aspect notation e.g. 'environmentlogger.remotesensor.temperature'. For Single destinations, public key auto-appended before hashing - ensures uniqueness even with same aspect names. PORTABILITY: Destinations are completely portable across entire network topology. Can even move between different Reticulum networks. Just send announce on new network segment to become reachable. PUBLIC KEY DISTRIBUTION: Via announce mechanism or path request from network's distributed ledger of public keys."}],["entry_1770158706118_rd91r9",{"id":"entry_1770158706118_rd91r9","key":"lxmf-overview","namespace":"protocols","content":"LXMF (Lightweight Extensible Message Format) is a simple and flexible messaging format and delivery protocol built on Reticulum. Key features: 1) Zero-conf message routing with end-to-end encryption and Forward Secrecy. 2) Extremely bandwidth-efficient (can work over LoRa/packet radio). 3) Messages can be encoded as QR codes or URIs for paper message transport. 4) Total overhead is only 111 bytes per message. Wire format: 16 bytes destination hash, 16 bytes source hash, 64 bytes Ed25519 signature, msgpack payload. Message ID is SHA-256 hash of destination+source+payload (never transmitted, always derived). Design goals: minimal infrastructure, works offline, store-and-forward via Propagation Nodes, supports human messaging and machine control."}],["entry_1770158707572_ud20co",{"id":"entry_1770158707572_ud20co","key":"reticulum-src-identity","namespace":"protocols","content":"# Identity.py Analysis\n\n## Main Class: Identity\nManages cryptographic identity with Curve25519 keys for encryption and Ed25519 for signatures.\n\n## Key Constants\n- CURVE = 'Curve25519' (X25519 for ECDH)\n- KEYSIZE = 512 bits (256 encrypt + 256 sign)\n- RATCHETSIZE = 256 bits\n- RATCHET_EXPIRY = 30 days\n- HASHLENGTH = 256 bits (SHA-256)\n- SIGLENGTH = 512 bits (Ed25519)\n- NAME_HASH_LENGTH = 80 bits\n- TRUNCATED_HASHLENGTH = 128 bits\n\n## Key Storage\n- prv_bytes: Private X25519 key (32 bytes)\n- sig_prv_bytes: Private Ed25519 key (32 bytes)\n- pub_bytes: Public X25519 key (32 bytes)\n- sig_pub_bytes: Public Ed25519 key (32 bytes)\n- hash: Truncated hash of public key\n\n## Ratchet System (Forward Secrecy)\n- _generate_ratchet(): Create new ephemeral key\n- _remember_ratchet(): Store received ratchet\n- get_ratchet(): Retrieve ratchet for destination\n- Ratchets rotated with announces\n- Stored in storage/ratchets/\n\n## Static Methods\n- full_hash(data): SHA-256\n- truncated_hash(data): First 128 bits of SHA-256\n- remember(packet_hash, dest_hash, pub_key, app_data): Store destination\n- recall(target_hash): Retrieve identity for destination\n- validate_announce(packet): Verify announce signature\n\n## Core Methods\n- create_keys(): Generate new keypair\n- encrypt(plaintext, ratchet=None): Ephemeral ECDH + Token encryption\n- decrypt(ciphertext, ratchets=None): Decrypt with identity or ratchets\n- sign(message): Ed25519 signature\n- validate(signature, message): Verify Ed25519 signature\n\n## Encryption Flow\n1. Generate ephemeral X25519 keypair\n2. ECDH with recipient public key (or ratchet)\n3. HKDF derive 64-byte key\n4. Token encrypt (AES-256)\n5. Return ephemeral_pub + ciphertext"}],["entry_1770158713648_ug016",{"id":"entry_1770158713648_ug016","key":"reticulum-links","namespace":"protocols","content":"Reticulum Links are abstract encrypted channels spanning arbitrary hops between two endpoints. ESTABLISHMENT PROCESS: (1) Initiator generates X25519 keypair, creates link_request packet with public key LKi, broadcasts to destination hash. (2) Forwarding nodes store link_id (hash of link_request) in link_table with hop count. (3) Destination receives request, generates own X25519 keypair, performs ECDH to derive symmetric key. (4) Destination creates link_proof: contains public key LKr + Ed25519 signature of link_id+LKr using original signing key. (5) Forwarding nodes verify proof, mark link as active. (6) Initiator receives proof, performs own ECDH, derives same symmetric key. PROPERTIES: (1) Forward Secrecy via ephemeral keys per link. (2) Initiator Anonymity maintained throughout. (3) Verified connectivity - proof demonstrates authentic destination. (4) Bi-directional communication via link_id addressing. (5) Automatic message receipt verification. (6) Optional authentication - initiator can reveal identity inside encrypted link. COSTS: Setup = 3 packets, 297 bytes total. Keepalive = 0.44 bits/second. 100 concurrent links on 1200bps channel leaves 96% capacity for data. USAGE: Preferred for exchanges of tens of packets or more, long sessions, or when using advanced API features like Resources."}],["entry_1770158713760_0oadm",{"id":"entry_1770158713760_0oadm","key":"lxst-overview","namespace":"protocols","content":"LXST (pronounced 'Elixir Streaming') is a Python audio streaming library designed for real-time voice communication over the Reticulum network stack. It provides a complete audio pipeline architecture for capturing, processing, encoding, transmitting, and playing back audio in VoIP-like applications.\n\nKEY COMPONENTS:\n1. Sources - Audio input capture (LineSource for microphones, OpusFileSource for file playback, ToneSource for generated tones)\n2. Sinks - Audio output playback (LineSink for speakers, OpusFileSink for recording to file)\n3. Filters - Audio processing (HighPass, LowPass, BandPass filters + AGC for automatic gain control)\n4. Codecs - Audio encoding/decoding (Opus, Codec2, Raw)\n5. Mixer - Combines multiple audio sources with gain control and muting\n6. Network - Packetizer/LinkSource for sending/receiving audio over Reticulum links\n7. Pipeline - Orchestrates source -> codec -> sink flow\n8. Telephony - High-level telephone abstraction with call state machine\n\nPLATFORM SUPPORT:\n- Linux (via ALSA/PulseAudio through soundcard library)\n- Android (via JNI to AudioTrack/AudioRecord APIs)\n- Darwin/macOS (via CoreAudio)\n- Windows (via WASAPI)\n\nDEFAULT SAMPLE RATE: 48000 Hz\nDEFAULT BIT DEPTH: 32-bit float internally, 16-bit for encoding\nFRAME-BASED PROCESSING: Audio processed in configurable frame sizes (e.g., 60-400ms)"}],["entry_1770158717196_i3gei2k",{"id":"entry_1770158717196_i3gei2k","key":"lxmf-message-format","namespace":"protocols","content":"LXMessage structure: STATES: GENERATING(0x00), OUTBOUND(0x01), SENDING(0x02), SENT(0x04), DELIVERED(0x08), REJECTED(0xFD), CANCELLED(0xFE), FAILED(0xFF). DELIVERY METHODS: OPPORTUNISTIC(0x01)=single packet best-effort, DIRECT(0x02)=link-based with delivery confirmation, PROPAGATED(0x03)=via propagation nodes, PAPER(0x05)=QR/URI encoded. REPRESENTATIONS: PACKET(0x01)=fits in single packet, RESOURCE(0x02)=requires link transfer. Wire format: destination_hash(16B) + source_hash(16B) + ed25519_signature(64B) + msgpack_payload. Payload is [timestamp, title, content, fields, optional_stamp]. Message ID = SHA256(dest_hash + src_hash + payload). Transient ID = SHA256(lxmf_data) used for encrypted messages on propagation nodes. Size limits: ENCRYPTED_PACKET_MAX_CONTENT=295B, LINK_PACKET_MAX_CONTENT=319B, PAPER_MDU=2953B. Overhead: 112 bytes total (16+16+64+8 timestamp+8 structure)."}],["entry_1770158717883_g2f058",{"id":"entry_1770158717883_g2f058","key":"reticulum-src-destination","namespace":"protocols","content":"# Destination.py Analysis\n\n## Main Class: Destination\nRepresents network endpoints. Can be outgoing (sending to) or incoming (receiving).\n\n## Destination Types\n- SINGLE (0x00): End-to-end encrypted, needs Identity\n- GROUP (0x01): Symmetric key encryption, shared secret\n- PLAIN (0x02): Unencrypted, no identity required\n- LINK (0x03): Internal type for Link destinations\n\n## Direction\n- IN (0x11): Receiving destination\n- OUT (0x12): Sending destination\n\n## Proof Strategies\n- PROVE_NONE: Never send proofs\n- PROVE_APP: Let app decide via callback\n- PROVE_ALL: Always prove received packets\n\n## Request Policies\n- ALLOW_NONE: Reject all requests\n- ALLOW_ALL: Accept all requests\n- ALLOW_LIST: Accept from identity whitelist\n\n## Ratchet Configuration\n- RATCHET_COUNT = 512 (retained keys)\n- RATCHET_INTERVAL = 30 minutes\n\n## Hash Generation\n- hash = full_hash(name_hash + identity.hash)[:16]\n- name_hash = full_hash(app_name.aspect1.aspect2...)[:10]\n\n## Key Methods\n- announce(app_data=None): Broadcast presence\n- receive(packet): Handle incoming packet\n- encrypt(plaintext): Encrypt for destination\n- decrypt(ciphertext): Decrypt received data\n- register_request_handler(path, generator, allow): Register RPC endpoint\n\n## Callbacks\n- link_established: New link created\n- packet: Data packet received\n- proof_requested: Proof requested\n\n## Announce Packet Structure\n- public_key (64 bytes)\n- name_hash (10 bytes)\n- random_hash (10 bytes)\n- [ratchet] (32 bytes, optional)\n- signature (64 bytes)\n- [app_data] (variable)"}],["entry_1770158724853_9tncy4",{"id":"entry_1770158724853_9tncy4","key":"reticulum-interfaces","namespace":"protocols","content":"Reticulum Interfaces connect to physical/virtual mediums. BUILT-IN TYPES: (1) AutoInterface - Auto-discovery over Ethernet/WiFi using IPv6 link-local + UDP. Zero config needed. Ports 29716, 42671. (2) BackboneInterface - High-performance kernel-event I/O for TCP (Linux/Android only). Handles thousands of connections efficiently. (3) TCPServerInterface/TCPClientInterface - TCP over IP networks. Tolerates intermittency, auto-reconnects. I2P tunneling supported. (4) UDPInterface - UDP over IP, supports broadcast for local discovery. (5) I2PInterface - Connect via Invisible Internet Protocol. Gets portable, persistent I2P address. (6) RNodeInterface - LoRa via RNode hardware. Full control: frequency, bandwidth, TX power, spreading factor, coding rate. Supports serial, WiFi TCP, and BLE connections. (7) RNodeMultiInterface - Multiple LoRa transceivers per RNode. (8) SerialInterface - Direct serial port communication. (9) PipeInterface - Use any external program via stdin/stdout. (10) KISSInterface - Packet radio modems/TNCs. (11) AX25KISSInterface - AX.25 encapsulation for amateur radio compliance. INTERFACE MODES: full (default), gateway (gw), access_point (ap), roaming, boundary. Modes control announce propagation, path expiry, and path request handling. DISCOVERABLE INTERFACES: Can publish connection details to network with discovery_name, reachable_on, location coordinates, radio parameters. Supports encrypted discovery via Network Identity."}],["entry_1770158725474_mg2vl9",{"id":"entry_1770158725474_mg2vl9","key":"lxst-pipeline","namespace":"protocols","content":"LXST AUDIO PIPELINE ARCHITECTURE\n\nThe Pipeline class orchestrates audio flow: Source -> Codec -> Sink\n\nPIPELINE CLASS (/home/tyler/repos/public/columba/app/build/python/pip/sentryDebug/common/LXST/Pipeline.py):\n- Constructor: Pipeline(source, codec, sink, processor=None)\n- Validates that source is a Source subclass, sink is a Sink subclass, codec is a Codec subclass\n- Binds source.sink = sink, source.codec = codec\n- Manages start/stop lifecycle\n\nSOURCE HIERARCHY:\n- Source (base)\n  - LocalSource (local audio capture)\n    - LineSource - Microphone input with filters, gain, ease-in, skip\n    - OpusFileSource - Plays Opus files with loop support\n    - ToneSource - Generates sine wave tones\n    - Loopback - Routes audio back locally\n  - RemoteSource (network audio)\n    - LinkSource - Receives audio from Reticulum link\n\nSINK HIERARCHY:\n- Sink (base) with handle_frame(frame, source) and can_receive(from_source)\n  - LocalSink (local playback)\n    - LineSink - Speaker output with autodigest, low-latency mode\n    - OpusFileSink - Records to Opus file\n    - Loopback - Routes to another sink\n  - RemoteSink (network)\n    - Packetizer - Sends frames over Reticulum link\n\nFRAME FLOW:\n1. Source captures audio samples (numpy array float32, shape [samples, channels])\n2. Filters applied in sequence (BandPass, AGC)\n3. Codec encodes to bytes (Opus/Codec2/Raw)\n4. Sink handles encoded frame\n5. For network: Packetizer wraps in msgpack with codec header byte, sends via RNS.Packet\n6. Remote: LinkSource receives, decodes, passes to local sink\n\nFRAME TIMING:\n- target_frame_ms configurable per source (default 60-80ms)\n- Codec may quantize frame time (Opus: 2.5ms quanta, max 60ms)\n- samples_per_frame = (target_frame_ms/1000) * samplerate"}],["entry_1770158727843_q671ir",{"id":"entry_1770158727843_q671ir","key":"reticulum-src-packet","namespace":"protocols","content":"# Packet.py Analysis\n\n## Main Class: Packet\nRepresents a network packet with headers and encrypted payload.\n\n## Packet Types\n- DATA (0x00): Regular data\n- ANNOUNCE (0x01): Presence announcement\n- LINKREQUEST (0x02): Link establishment\n- PROOF (0x03): Delivery proof\n\n## Header Types\n- HEADER_1 (0x00): Normal format (19 bytes)\n- HEADER_2 (0x01): Transport format (35 bytes)\n\n## Context Types\n- NONE (0x00): Generic data\n- RESOURCE (0x01): Resource part\n- RESOURCE_ADV (0x02): Resource advertisement\n- RESOURCE_REQ (0x03): Resource request\n- PATH_RESPONSE (0x0B): Path announcement reply\n- CHANNEL (0x0E): Channel data\n- KEEPALIVE (0xFA): Link keepalive\n- LINKIDENTIFY (0xFB): Peer identification\n- LINKCLOSE (0xFC): Close link\n- LINKPROOF (0xFD): Link proof\n- LRRTT (0xFE): Round-trip measurement\n- LRPROOF (0xFF): Link request proof\n\n## Packet Structure\nByte 0: Flags [header_type:2][context_flag:1][transport_type:1][dest_type:2][packet_type:2]\nByte 1: Hop count\nBytes 2-17: Destination hash (HEADER_1) or Transport ID (HEADER_2)\nBytes 18-33: Destination hash (HEADER_2 only)\nByte 34/18: Context\nRemaining: Payload/ciphertext\n\n## Size Limits\n- MDU = 464 bytes (unencrypted payload)\n- ENCRYPTED_MDU = 383 bytes (encrypted payload)\n\n## Key Methods\n- pack(): Serialize packet, encrypt if needed\n- unpack(): Deserialize received packet\n- send(): Transmit via Transport.outbound()\n- get_hash(): SHA-256 of hashable part\n\n## PacketReceipt\nTracks delivery status:\n- SENT: Transmitted\n- DELIVERED: Proof received\n- FAILED: Timed out\n- CULLED: Removed from tracking"}],["entry_1770158728294_7zkx9p",{"id":"entry_1770158728294_7zkx9p","key":"lxmf-router","namespace":"protocols","content":"LXMRouter is the core message routing engine. KEY CONSTANTS: MAX_DELIVERY_ATTEMPTS=5, MESSAGE_EXPIRY=30days, PROCESSING_INTERVAL=4s, LINK_MAX_INACTIVITY=10min. ROUTER STATES for propagation transfer: PR_IDLE(0x00), PR_PATH_REQUESTED(0x01), PR_LINK_ESTABLISHING(0x02), PR_LINK_ESTABLISHED(0x03), PR_REQUEST_SENT(0x04), PR_RECEIVING(0x05), PR_RESPONSE_RECEIVED(0x06), PR_COMPLETE(0x07). Error states: PR_NO_PATH(0xf0), PR_LINK_FAILED(0xf1), PR_TRANSFER_FAILED(0xf2), PR_NO_IDENTITY_RCVD(0xf3), PR_NO_ACCESS(0xf4), PR_FAILED(0xfe). Main data structures: pending_inbound[], pending_outbound[], failed_outbound[], direct_links{}, backchannel_links{}, delivery_destinations{}, propagation_entries{}, peers{}. Job loop runs periodically: process_outbound, process_deferred_stamps, clean_links, clean_transient_id_caches, clean_message_store, flush_queues, rotate_peers, sync_peers. Key methods: handle_outbound() queues messages, process_outbound() delivers them, lxmf_delivery() handles inbound, lxmf_propagation() handles propagated messages."}],["entry_1770158732909_yxw2a",{"id":"entry_1770158732909_yxw2a","key":"reticulum-resources","namespace":"protocols","content":"Reticulum Resources handle reliable transfer of arbitrary data amounts over established Links. FEATURES: (1) Auto-compression of data. (2) Automatic packet sequencing and reassembly. (3) Transfer coordination across hops. (4) Integrity verification via checksumming. (5) Progress callbacks for transfer status. (6) Can transfer from memory or stream directly from files. API: RNS.Resource(data, link, advertise=True, auto_compress=True, callback=None, progress_callback=None, timeout=None). PACKET API: For small data exchanges, RNS.Packet(destination, data, create_receipt=True) provides per-packet encryption with ephemeral ECDH keys. Destination can prove receipt via SHA-256 hash signed with Ed25519 key - unforgeable delivery confirmation. CHANNEL/BUFFER: RNS.Channel provides reliable sequential delivery mechanism. RNS.Buffer offers stream-like interface. RawChannelReader/RawChannelWriter for low-level access. REQUEST/RESPONSE: Lightweight mechanism built on Links for RPC-style communication. RequestReceipt tracks request status. CRYPTOGRAPHIC PRIMITIVES: Ed25519 signatures, X25519 ECDH, HKDF key derivation, Fernet-based encrypted tokens (AES-256-CBC + HMAC-SHA256), SHA-256/SHA-512. Default uses OpenSSL via PyCA/cryptography. Pure Python fallback available but not recommended for production."}],["entry_1770158735608_5o3ynb",{"id":"entry_1770158735608_5o3ynb","key":"lxst-network","namespace":"protocols","content":"LXST NETWORK PROTOCOL FOR AUDIO STREAMING\n\nTRANSPORT LAYER: Reticulum Network Stack (RNS)\n- Uses RNS.Link for bidirectional audio channels\n- Uses RNS.Packet for sending audio frames\n- Packet-based, not stream-based\n\nPACKET STRUCTURE (/home/tyler/repos/public/columba/app/build/python/pip/sentryDebug/common/LXST/Network.py):\nFields packed via msgpack (RNS.vendor.umsgpack):\n- FIELD_SIGNALLING (0x00): Control signals for call state\n- FIELD_FRAMES (0x01): Audio frame data\n\nFRAME FORMAT:\n[codec_header_byte (1 byte)][encoded_audio_bytes...]\n\nCODEC HEADER BYTES:\n- 0x00 = Raw\n- 0x01 = Opus\n- 0x02 = Codec2\n- 0xFF = Null (passthrough)\n\nPACKETIZER CLASS (RemoteSink):\n- Wraps frames with codec header byte\n- Packs into msgpack dict: {FIELD_FRAMES: header+frame}\n- Sends via RNS.Packet(destination, data, create_receipt=False)\n- Handles transmit failures with callback\n\nLINKSOURCE CLASS (RemoteSource):\n- Listens on RNS.Link packet callback\n- Unpacks msgpack, extracts FIELD_FRAMES\n- Detects codec type from header byte\n- Decodes frame via codec.decode()\n- Passes decoded samples to sink\n\nSIGNALLING (in-band):\n- SignallingReceiver handles FIELD_SIGNALLING\n- Signals sent via RNS.Packet with msgpack\n- Used for call state transitions (BUSY, RINGING, ESTABLISHED, etc.)\n\nFLOW CONTROL:\n- Sink.can_receive(from_source) checks buffer space\n- Source only sends when sink reports ready\n- MAX_FRAMES limits (6-128 depending on component)\n- Frame timeout for stale data handling"}],["entry_1770158740814_ugam4e",{"id":"entry_1770158740814_ugam4e","key":"lxmf-propagation","namespace":"protocols","content":"Propagation Nodes are store-and-forward infrastructure. KEY CONCEPTS: 1) Nodes auto-peer and synchronize messages creating distributed encrypted message store. 2) Messages stored as files: {transient_id}_{received_timestamp}_{stamp_value}. 3) propagation_entries{} maps transient_id to [destination_hash, filepath, received_time, msg_size, handled_peers[], unhandled_peers[], stamp_value]. SYNC PROTOCOL: Peer initiates link, identifies with peering_key (proof-of-work), sends offer_request with [peering_key, transient_ids[]], node responds with wanted_ids. Peer sends messages as resource transfer. LIMITS: PROPAGATION_LIMIT=256KB per transfer, SYNC_LIMIT=256KB*40 per sync, MAX_PEERS=20, AUTOPEER_MAXDEPTH=4 hops. ANNOUNCE DATA: [legacy, timebase, propagation_enabled, transfer_limit, sync_limit, [stamp_cost, flexibility, peering_cost], metadata{}]. Message download: Client connects, identifies, requests MESSAGE_GET_PATH with [want_ids, have_ids]. Node sends messages and deletes them when confirmed received."}],["entry_1770158741625_1e0bic",{"id":"entry_1770158741625_1e0bic","key":"reticulum-src-link","namespace":"protocols","content":"# Link.py Analysis\n\n## Main Class: Link\nEncrypted bidirectional channel with forward secrecy between two endpoints.\n\n## Link States (State Machine)\n- PENDING (0x00): Link request sent, awaiting proof\n- HANDSHAKE (0x01): Keys exchanged, deriving secrets\n- ACTIVE (0x02): Ready for data\n- STALE (0x03): No activity, may timeout\n- CLOSED (0x04): Terminated\n\n## Teardown Reasons\n- TIMEOUT (0x01): No response\n- INITIATOR_CLOSED (0x02): Initiator closed\n- DESTINATION_CLOSED (0x03): Responder closed\n\n## Resource Strategies\n- ACCEPT_NONE (0x00): Reject all resources\n- ACCEPT_APP (0x01): Let app decide\n- ACCEPT_ALL (0x02): Accept everything\n\n## Encryption Modes\n- MODE_AES128_CBC (0x00)\n- MODE_AES256_CBC (0x01) - Default\n- MODE_AES256_GCM (0x02)\n- Reserved for post-quantum (0x03-0x07)\n\n## Timing Constants\n- ESTABLISHMENT_TIMEOUT_PER_HOP = 6s\n- TRAFFIC_TIMEOUT_FACTOR = 6x RTT\n- KEEPALIVE_MAX = 360s\n- KEEPALIVE_MIN = 5s\n- STALE_FACTOR = 2x keepalive\n\n## Handshake Flow\n1. Initiator generates ephemeral X25519+Ed25519\n2. Link request sent with public keys\n3. Responder validates, generates own keys\n4. ECDH shared secret derived\n5. HKDF to get derived_key\n6. Proof sent back with signature\n7. RTT packet confirms activation\n\n## Key Methods\n- validate_request(): Accept incoming link\n- handshake(): Derive shared secrets\n- prove(): Send link proof\n- identify(identity): Reveal identity to peer\n- request(path, data): Send RPC request\n- encrypt/decrypt(): AES with Token class\n- teardown(): Close link gracefully\n\n## Callbacks\n- link_established: Active state reached\n- link_closed: Link terminated\n- packet: Data received\n- resource: Resource offered\n- remote_identified: Peer identity revealed\n\n## MTU Discovery\n- Negotiated during handshake\n- Uses LINK_MTU_SIZE bytes (3)\n- Can upgrade to interface HW_MTU"}],["entry_1770158749301_2bb0k",{"id":"entry_1770158749301_2bb0k","key":"lxst-codecs","namespace":"protocols","content":"LXST CODEC SYSTEM\n\nBASE CODEC CLASS (/home/tyler/repos/public/columba/app/build/python/pip/sentryDebug/common/LXST/Codecs/Codec.py):\n- preferred_samplerate: Target sample rate for codec\n- frame_quanta_ms: Frame time must be multiple of this\n- frame_max_ms: Maximum frame duration\n- valid_frame_ms: List of valid frame durations\n- encode(frame) -> bytes\n- decode(frame_bytes) -> numpy array\n\nOPUS CODEC (/home/tyler/repos/public/columba/app/build/python/pip/sentryDebug/common/LXST/Codecs/Opus.py):\n- Uses pyogg library (OpusEncoder, OpusDecoder)\n- FRAME_QUANTA_MS = 2.5\n- FRAME_MAX_MS = 60\n- VALID_FRAME_MS = [2.5, 5, 10, 20, 40, 60]\n- TYPE_MAP_FACTOR = 32767 (int16 max for conversion)\n\nOPUS PROFILES:\n| Profile           | Sample Rate | Channels | Bitrate Ceiling | Application |\n|-------------------|-------------|----------|-----------------|-------------|\n| VOICE_LOW (0x00)  | 8000        | 1        | 6000 bps        | voip        |\n| VOICE_MEDIUM      | 24000       | 1        | 8000 bps        | voip        |\n| VOICE_HIGH        | 48000       | 1        | 16000 bps       | voip        |\n| VOICE_MAX         | 48000       | 2        | 32000 bps       | voip        |\n| AUDIO_MIN         | 8000        | 1        | 8000 bps        | audio       |\n| AUDIO_LOW         | 12000       | 1        | 14000 bps       | audio       |\n| AUDIO_MEDIUM      | 24000       | 2        | 28000 bps       | audio       |\n| AUDIO_HIGH        | 48000       | 2        | 56000 bps       | audio       |\n| AUDIO_MAX (0x08)  | 48000       | 2        | 128000 bps      | audio       |\n\nCODEC2 (/home/tyler/repos/public/columba/app/build/python/pip/sentryDebug/common/LXST/Codecs/Codec2.py):\n- Uses pycodec2 library\n- INPUT/OUTPUT_RATE = 8000 Hz (fixed)\n- FRAME_QUANTA_MS = 40\n- Modes: 700C, 1200, 1300, 1400, 1600, 2400, 3200 bps\n- Mode header prepended to encoded data\n- Ultra low bandwidth voice codec\n\nRAW CODEC (/home/tyler/repos/public/columba/app/build/python/pip/sentryDebug/common/LXST/Codecs/Raw.py):\n- Uncompressed audio\n- Supports float16, float32, float64, float128\n- Header byte encodes bit depth (2 bits) + channels (6 bits)\n\nNULL CODEC:\n- Passthrough, no encoding/decoding\n- Used for local pipelines\n\nRESAMPLING:\n- resample_bytes() and resample() functions in Codec.py\n- Uses pydub AudioSegment for rate conversion\n- Required when source/sink rates differ from codec rate"}],["entry_1770158752028_3vrybs",{"id":"entry_1770158752028_3vrybs","key":"lxmf-peer-management","namespace":"protocols","content":"LXMPeer manages peer-to-peer synchronization. PEER STATES: IDLE(0x00), LINK_ESTABLISHING(0x01), LINK_READY(0x02), REQUEST_SENT(0x03), RESPONSE_RECEIVED(0x04), RESOURCE_TRANSFERRING(0x05). ERRORS: ERROR_NO_IDENTITY(0xf0), ERROR_NO_ACCESS(0xf1), ERROR_INVALID_KEY(0xf3), ERROR_INVALID_DATA(0xf4), ERROR_INVALID_STAMP(0xf5), ERROR_THROTTLED(0xf6), ERROR_NOT_FOUND(0xfd), ERROR_TIMEOUT(0xfe). SYNC STRATEGIES: LAZY(0x01), PERSISTENT(0x02, default). KEY PARAMETERS: MAX_UNREACHABLE=14days, SYNC_BACKOFF_STEP=12min, PATH_REQUEST_GRACE=7.5s. Peer tracking: peering_timebase, link_establishment_rate, sync_transfer_rate, propagation_transfer_limit, propagation_sync_limit, propagation_stamp_cost, peering_cost, peering_key (proof-of-work for authentication). Message tracking: handled_messages[] (already synced to peer), unhandled_messages[] (pending sync). Sync flow: generate peering_key -> establish link -> identify -> send offer with wanted messages -> transfer as resource -> mark handled."}],["entry_1770158763455_c2hwb7",{"id":"entry_1770158763455_c2hwb7","key":"reticulum-src-channel","namespace":"protocols","content":"# Channel.py Analysis\n\n## Main Class: Channel\nReliable message delivery over Links with sequencing and windowing.\n\n## Key Differences from Packet/Resource\n- Continuous: Messages while link open\n- Bidirectional: Either end can send\n- Size-constrained: Single packet per message\n- Reliable: Automatic retries with timeout\n\n## Window Management\n- WINDOW = 2 (initial)\n- WINDOW_MIN = 2\n- WINDOW_MAX_SLOW = 5\n- WINDOW_MAX_MEDIUM = 12\n- WINDOW_MAX_FAST = 48\n- RTT thresholds: FAST=0.18s, MEDIUM=0.75s, SLOW=1.45s\n\n## Message Sequencing\n- SEQ_MAX = 0xFFFF (16-bit)\n- SEQ_MODULUS = SEQ_MAX + 1\n- Handles wraparound\n\n## MessageBase (Abstract)\nBase class for channel messages:\n- MSGTYPE: Unique identifier < 0xf000\n- pack(): Serialize to bytes\n- unpack(raw): Deserialize\n\n## Envelope\nInternal wrapper tracking message state:\n- sequence: Order number\n- raw: Packed bytes\n- packet: Associated RNS.Packet\n- tries: Retry count\n\n## MessageState\n- MSGSTATE_NEW (0): Just created\n- MSGSTATE_SENT (1): Transmitted\n- MSGSTATE_DELIVERED (2): Proof received\n- MSGSTATE_FAILED (3): Gave up\n\n## Key Methods\n- register_message_type(cls): Register message class\n- add_message_handler(callback): Receive handler\n- send(message): Transmit message\n- is_ready_to_send(): Check window capacity\n- mdu: Available bytes (link MDU - 6 header)\n\n## Message Wire Format\n- msgtype (2 bytes)\n- sequence (2 bytes)\n- length (2 bytes)\n- data (variable)\n\n## LinkChannelOutlet\nAdapter connecting Channel to Link:\n- Sends via RNS.Packet with CHANNEL context\n- Tracks packet delivery/timeout\n- Maps packet state to MessageState\n\n## System Message Types\n- SMT_STREAM_DATA (0xff00): Reserved"}],["entry_1770158764018_jecpif",{"id":"entry_1770158764018_jecpif","key":"lxmf-stamping","namespace":"protocols","content":"LXStamper implements proof-of-work anti-spam stamps. STAMP TYPES: 1) Message stamps - required by recipients to accept messages, 2) Propagation stamps - required by propagation nodes, 3) Peering keys - required for peer-to-peer sync. ALGORITHM: stamp_workblock() expands material via HKDF to 256*expand_rounds bytes. stamp_valid() checks if SHA256(workblock+stamp) has enough leading zeros. stamp_value() counts leading zero bits. EXPAND_ROUNDS: 3000 for message stamps, 1000 for propagation stamps (WORKBLOCK_EXPAND_ROUNDS_PN), 25 for peering keys (WORKBLOCK_EXPAND_ROUNDS_PEERING). STAMP_SIZE=32 bytes. Generation: Random 32-byte nonces tested until hash has required leading zeros. Multi-core support on Linux via multiprocessing. COST PARAMETERS: PROPAGATION_COST=16 (bits of work), PROPAGATION_COST_MIN=13, PROPAGATION_COST_FLEX=3, PEERING_COST=18, MAX_PEERING_COST=26. Stamp validation can be parallelized (PN_VALIDATION_POOL_MIN_SIZE=256). TICKETS: Alternative to stamps - pre-shared tokens allowing stamp-free messaging. Ticket expiry=21 days, grace=5 days, renew at 14 days remaining."}],["entry_1770158765272_gwvn7q",{"id":"entry_1770158765272_gwvn7q","key":"lxst-call-management","namespace":"protocols","content":"LXST CALL MANAGEMENT AND STATE MACHINE\n\nTELEPHONY PRIMITIVE (/home/tyler/repos/public/columba/app/build/python/pip/sentryDebug/common/LXST/Primitives/Telephony.py)\n\nTELEPHONE CLASS:\nCentral call management with full state machine for VoIP-style calls over Reticulum.\n\nSIGNALLING STATES:\n- STATUS_BUSY (0x00): Line is busy, cannot accept call\n- STATUS_REJECTED (0x01): Call was rejected\n- STATUS_CALLING (0x02): Initiating outgoing call\n- STATUS_AVAILABLE (0x03): Ready to receive calls\n- STATUS_RINGING (0x04): Incoming call ringing\n- STATUS_CONNECTING (0x05): Call setup in progress\n- STATUS_ESTABLISHED (0x06): Call active, audio flowing\n- PREFERRED_PROFILE (0xFF): Profile negotiation signal\n\nCALL PROFILES (bandwidth/quality tradeoffs):\n| Profile             | Codec          | Frame Time | Use Case            |\n|---------------------|----------------|------------|---------------------|\n| BANDWIDTH_ULTRA_LOW | Codec2 700C    | 400ms      | Extreme low BW      |\n| BANDWIDTH_VERY_LOW  | Codec2 1600    | 320ms      | Very low BW         |\n| BANDWIDTH_LOW       | Codec2 3200    | 200ms      | Low BW              |\n| QUALITY_MEDIUM      | Opus Voice Med | 60ms       | Default balanced    |\n| QUALITY_HIGH        | Opus Voice Hi  | 60ms       | Better quality      |\n| QUALITY_MAX         | Opus Voice Max | 60ms       | Best quality        |\n| LATENCY_LOW         | Opus Voice Med | 20ms       | Low latency         |\n| LATENCY_ULTRA_LOW   | Opus Voice Med | 10ms       | Minimum latency     |\n\nOUTGOING CALL FLOW:\n1. call(identity, profile) initiated\n2. Request path if not known (RNS.Transport.request_path)\n3. Establish RNS.Link to destination\n4. Wait for STATUS_AVAILABLE signal\n5. Send identity identification (link.identify)\n6. Receive STATUS_RINGING\n7. Start dial tone, send PREFERRED_PROFILE\n8. Receive STATUS_CONNECTING\n9. Open audio pipelines\n10. Receive STATUS_ESTABLISHED\n11. Start audio pipelines, disable dial tone\n\nINCOMING CALL FLOW:\n1. Link established callback fires\n2. Send STATUS_AVAILABLE to caller\n3. Wait for caller identification\n4. If allowed, send STATUS_RINGING, activate ringtone\n5. Optional auto_answer timer or user answer()\n6. answer() sends STATUS_CONNECTING\n7. Open transmit/receive pipelines\n8. Send STATUS_ESTABLISHED\n9. Start audio flow\n\nPIPELINE SETUP:\nReceive: LinkSource -> Mixer -> LineSink\nTransmit: LineSource -> [BandPass, AGC] -> Raw -> Mixer -> Codec -> Packetizer\n\nFEATURES:\n- AGC (Automatic Gain Control) for input normalization\n- BandPass filter (250-8500 Hz) for voice clarity\n- Mute/unmute for receive and transmit\n- Gain adjustment for both directions\n- Low-latency output mode\n- Ringtone playback from Opus files\n- Dial/busy tone generation\n- Allowed/blocked caller lists\n- Auto-announce interval"}],["entry_1770158774905_w7i6yi",{"id":"entry_1770158774905_w7i6yi","key":"lxmf-field-types","namespace":"protocols","content":"LXMF defines standardized field types for message.fields dictionary. CORE FIELDS: FIELD_EMBEDDED_LXMS(0x01), FIELD_TELEMETRY(0x02), FIELD_TELEMETRY_STREAM(0x03), FIELD_ICON_APPEARANCE(0x04), FIELD_FILE_ATTACHMENTS(0x05), FIELD_IMAGE(0x06), FIELD_AUDIO(0x07), FIELD_THREAD(0x08), FIELD_COMMANDS(0x09), FIELD_RESULTS(0x0A), FIELD_GROUP(0x0B), FIELD_TICKET(0x0C), FIELD_EVENT(0x0D), FIELD_RNR_REFS(0x0E), FIELD_RENDERER(0x0F). CUSTOM FIELDS: FIELD_CUSTOM_TYPE(0xFB), FIELD_CUSTOM_DATA(0xFC), FIELD_CUSTOM_META(0xFD). DEBUG: FIELD_NON_SPECIFIC(0xFE), FIELD_DEBUG(0xFF). AUDIO MODES: Codec2 (0x01-0x09), Opus (0x10-0x19), AM_CUSTOM(0xFF). RENDERER: PLAIN(0x00), MICRON(0x01), MARKDOWN(0x02), BBCODE(0x03). PN METADATA: PN_META_VERSION(0x00), PN_META_NAME(0x01), PN_META_SYNC_STRATUM(0x02), PN_META_SYNC_THROTTLE(0x03), PN_META_AUTH_BAND(0x04), PN_META_UTIL_PRESSURE(0x05), PN_META_CUSTOM(0xFF)."}],["entry_1770158776990_ip40li",{"id":"entry_1770158776990_ip40li","key":"lxst-android-audio","namespace":"protocols","content":"LXST ANDROID AUDIO BACKEND\n\nPLATFORM: Android via JNI (jnius/pyjnius)\n\nSOUNDCARD MODULE (/home/tyler/repos/public/columba/app/build/python/pip/sentryDebug/common/LXST/Platforms/android/soundcard.py)\n\nANDROID AUDIO CLASS:\n- Uses AudioManager, AudioTrack, AudioRecord via JNI\n- Discovers devices via getAvailableCommunicationDevices() (API 31+)\n- Falls back to getDevices() for older APIs\n\nDEVICE TYPES SUPPORTED:\nSources: Internal Microphone, Wired Headset, USB Headset, BLE Headset, Bluetooth SCO, Hearing Aid\nSinks: Internal Speaker, Internal Earpiece, Ringer Speaker, Bluetooth A2DP, BLE Speaker, HDMI, etc.\n\nAUDIO MODES:\n- MODE_NORMAL: General media playback\n- MODE_IN_COMMUNICATION: VoIP calls (enables earpiece, SCO)\n- Ringer mode: For ringtone output\n\nPLAYER CLASS (_Player):\n- Uses AudioTrack.Builder for stream creation\n- Supports WRITE_BLOCKING and WRITE_NON_BLOCKING modes\n- Low-latency mode with dynamic buffer sizing\n- Performance mode: PERFORMANCE_MODE_LOW_LATENCY\n- Handles buffer underruns with logging\n\nRECORDER CLASS (_Recorder):\n- Uses AudioRecord with VOICE_COMMUNICATION source\n- READ_NON_BLOCKING mode\n- Maintains pending_chunk for frame alignment\n\nKEY API LEVELS:\n- API 23: Basic AudioDeviceInfo\n- API 26: USB Headset support\n- API 28: Hearing Aid support\n- API 30: Ringer Speaker (BUILTIN_SPEAKER_SAFE)\n- API 31: BLE Headset, setCommunicationDevice API\n- API 34: Improved communication device selection\n\nSPECIAL HANDLING:\n- Virtual ringer devices created when no native ringer available\n- Service context fallback for background operation\n- Communication device auto-selection pairs sources with sinks\n- Low-latency buffer management with target buffer of 125ms\n\nAUDIO FORMAT:\n- Encoding: PCM 16-bit\n- Sample rate: 48000 Hz\n- Channels: Mono or Stereo\n- Mode: STREAM mode for real-time audio"}],["entry_1770158778729_wrsvp7",{"id":"entry_1770158778729_wrsvp7","key":"reticulum-src-transport","namespace":"protocols","content":"# Transport.py Analysis\n\n## Main Class: Transport (Static)\nCore routing engine handling packet forwarding, path discovery, and link management.\n\n## Transport Types\n- BROADCAST (0x00): Direct transmission\n- TRANSPORT (0x01): Forwarded via nodes\n- RELAY (0x02): Relay operation\n- TUNNEL (0x03): Tunneled traffic\n\n## Reachability States\n- UNREACHABLE (0x00)\n- DIRECT (0x01): 1 hop\n- TRANSPORT (0x02): Multiple hops\n\n## Path Constants\n- PATHFINDER_M = 128 (max hops)\n- PATHFINDER_R = 1 (retransmit retries)\n- PATHFINDER_G = 5s (retry grace)\n- PATHFINDER_E = 7 days (path expiry)\n- AP_PATH_TIME = 1 day (access point)\n- ROAMING_PATH_TIME = 6 hours\n- PATH_REQUEST_TIMEOUT = 15s\n\n## Core Tables\n- path_table: {dest_hash -> [timestamp, via, hops, expires, blobs, interface, packet_hash]}\n- reverse_table: {truncated_hash -> [recv_if, outb_if, timestamp]}\n- link_table: {link_id -> link_entry}\n- announce_table: {dest_hash -> announce_entry}\n- tunnels: {tunnel_id -> tunnel_entry}\n- announce_rate_table: Rate limiting\n- blackholed_identities: Spam filter\n\n## Packet Flow\n1. Interface receives raw bytes\n2. Transport.inbound() called\n3. IFAC authentication if enabled\n4. packet_filter() checks duplicates\n5. Route based on tables or broadcast\n6. Forward to local destinations or transport\n\n## Path Discovery\n1. request_path(dest_hash): Send path request\n2. path_request_handler(): Respond with announce\n3. announce_table entries rebroadcast\n4. Path recorded when announce received\n\n## Key Methods\n- start(): Initialize transport, load tables\n- outbound(packet): Send packet\n- inbound(raw, interface): Receive packet\n- register_destination(dest): Add local dest\n- has_path(dest_hash): Check path exists\n- hops_to(dest_hash): Get hop count\n- next_hop(dest_hash): Get via address\n\n## Interface Access Codes (IFAC)\n- Optional per-interface authentication\n- Uses identity signature for access code\n- HKDF-derived mask applied to packet\n- Prevents unauthorized network access\n\n## Announce Processing\n- validate_announce(): Check signature\n- Cache announce for retransmission\n- Rate limiting per destination\n- Bandwidth cap enforcement\n\n## Background Jobs\n- jobloop(): Runs every 250ms\n- Cull stale table entries\n- Process pending path requests\n- Clean packet caches\n- Send management announces\n- Check blackhole expiry"}],["entry_1770158786502_78wbxf",{"id":"entry_1770158786502_78wbxf","key":"lxmf-message-lifecycle","namespace":"protocols","content":"MESSAGE LIFECYCLE - Outbound: 1) Create LXMessage(destination, source, content, title, fields). 2) Call router.handle_outbound(message) - sets state to OUTBOUND, checks stamp_cost from cached announces, attaches outbound_ticket if available. 3) Message packed: timestamp set, payload=[ts,title,content,fields,stamp?], hash computed, signature generated. 4) If deferred stamp needed, added to pending_deferred_stamps for background generation. 5) process_outbound() called periodically, handles by method: OPPORTUNISTIC sends packet directly, DIRECT establishes link then sends, PROPAGATED connects to propagation node. 6) Delivery confirmed via proof receipt, state becomes DELIVERED or SENT(propagated). MESSAGE LIFECYCLE - Inbound: 1) delivery_packet() or delivery_resource_concluded() receives data. 2) lxmf_delivery() unpacks message, validates signature, checks stamp if required, calls delivery_callback. 3) For propagated: lxmf_propagation() decrypts if local destination, otherwise stores in messagestore and queues for peer distribution."}],["entry_1770158790528_pg852",{"id":"entry_1770158790528_pg852","key":"lxst-filters","namespace":"protocols","content":"LXST AUDIO FILTERS\n\nFILTER MODULE (/home/tyler/repos/public/columba/app/build/python/pip/sentryDebug/common/LXST/Filters.py)\n\nACCELERATION:\n- Native C implementation via CFFI (filterlib.so/dll)\n- Falls back to pure Python if CFFI unavailable\n- USE_NATIVE_FILTERS flag controls which implementation\n\nBASE FILTER CLASS:\n- handle_frame(frame, samplerate) -> processed frame\n- Frames are numpy float32 arrays [samples, channels]\n\nHIGHPASS FILTER:\n- First-order RC high-pass filter\n- Constructor: HighPass(cut) where cut is cutoff frequency in Hz\n- Alpha coefficient: rc / (rc + dt) where rc = 1/(2*pi*cut)\n- Maintains filter state between frames for continuity\n\nLOWPASS FILTER:\n- First-order RC low-pass filter\n- Constructor: LowPass(cut) where cut is cutoff frequency in Hz\n- Alpha coefficient: dt / (rc + dt)\n- Maintains filter state between frames\n\nBANDPASS FILTER:\n- Combines HighPass and LowPass in series\n- Constructor: BandPass(low_cut, high_cut)\n- low_cut must be < high_cut\n- Used for voice: typically BandPass(250, 8500) Hz\n\nAGC (AUTOMATIC GAIN CONTROL):\n- Constructor: AGC(target_level=-12.0, max_gain=12.0, attack_time=0.0001, release_time=0.002, hold_time=0.001)\n- target_level: Target output level in dBFS\n- max_gain: Maximum gain boost allowed in dB\n- attack_time: How fast to reduce gain (seconds)\n- release_time: How fast to increase gain (seconds)\n- hold_time: Time to hold before release\n\nAGC ALGORITHM:\n- Block-based processing (10ms blocks)\n- Calculates RMS of each block\n- Computes target gain to reach target_level\n- Applies attack/release smoothing\n- Trigger level (0.003) prevents amplifying silence\n- Peak limiting at 0.75 to prevent clipping\n\nNATIVE FUNCTIONS (C):\n- highpass_filter(input, output, samples, channels, alpha, states, last_inputs)\n- lowpass_filter(input, output, samples, channels, alpha, states)\n- agc_process(input, output, samples, channels, target, max_gain, trigger, attack, release, hold, gain_ptr, hold_ptr, block_target)\n\nTELEPHONY FILTER CHAIN:\n- BandPass(250, 8500) for voice frequency isolation\n- AGC(target_level=-15.0) for level normalization\n- Applied before encoding in transmit pipeline"}],["entry_1770158796833_572fa",{"id":"entry_1770158796833_572fa","key":"lxmf-announce-handlers","namespace":"protocols","content":"LXMF uses Reticulum announce handlers for discovery. LXMFDeliveryAnnounceHandler: aspect_filter='lxmf.delivery'. On announce: triggers delivery attempts for pending outbound messages to that destination, extracts and caches stamp_cost from app_data using stamp_cost_from_app_data(). App data format (v0.5.0+): msgpack array [display_name, stamp_cost]. LXMFPropagationAnnounceHandler: aspect_filter='lxmf.propagation'. On announce from propagation node: validates pn_announce_data_is_valid(), extracts [legacy, timebase, enabled, transfer_limit, sync_limit, [stamp_cost, flexibility, peering_cost], metadata]. For static peers: always updates peering config. For auto-discovered peers: peers if enabled=True and hops <= autopeer_maxdepth, unpeers if outside range or disabled. Path responses treated differently (don't auto-peer from path response to avoid flooding)."}],["entry_1770158806442_c18ekb",{"id":"entry_1770158806442_c18ekb","key":"reticulum-architecture-summary","namespace":"protocols","content":"# Reticulum Network Stack Architecture Summary\n\n## Component Hierarchy\n\n\n## Core Design Patterns\n\n### 1. Singleton Reticulum Instance\n- One instance per process\n- Shared instance mode for multiple apps\n- Client mode connects to shared instance\n\n### 2. Destination-Based Addressing\n- Hash = full_hash(name_hash + identity_hash)[:16]\n- 128-bit truncated addresses\n- Types: SINGLE, GROUP, PLAIN, LINK\n\n### 3. Announce-Based Routing\n- Destinations announce presence\n- Transport nodes remember and forward\n- Path table caches routes\n- Hop count incremented at each node\n\n### 4. End-to-End Encryption\n- X25519 ECDH for key agreement\n- Ed25519 for signatures\n- HKDF for key derivation\n- AES-256 for symmetric encryption\n\n### 5. Forward Secrecy via Ratchets\n- Ephemeral keys in announces\n- Ratchet rotated every 30 minutes\n- 512 ratchets retained\n- Decryption tries current + historical\n\n## Data Flow: Sending a Packet\n\n1. **Application Layer**\n   - Create Destination (with Identity)\n   - Create Packet with payload\n\n2. **Encryption (Packet.pack)**\n   - For SINGLE: Identity.encrypt()\n   - Ephemeral ECDH + HKDF + Token\n\n3. **Transport.outbound()**\n   - Check path_table for route\n   - If multi-hop: Add transport header\n   - If direct: Broadcast\n\n4. **Interface.process_outgoing()**\n   - IFAC masking if enabled\n   - Physical transmission\n\n## Data Flow: Receiving a Packet\n\n1. **Interface receives bytes**\n   - Calls Transport.inbound()\n\n2. **IFAC Processing**\n   - Unmask if enabled\n   - Verify access code\n\n3. **Transport.inbound()**\n   - packet_filter(): Duplicate check\n   - Route based on transport_id\n   - Deliver to local destinations\n\n4. **Destination.receive()**\n   - Decrypt payload\n   - Call packet callback\n\n## Link Establishment Flow\n\n1. Initiator: Link(destination)\n2. Send LINKREQUEST with ephemeral keys\n3. Responder: validate_request()\n4. ECDH handshake()\n5. Send LRPROOF with signature\n6. Initiator validates, sends RTT packet\n7. Link becomes ACTIVE\n\n## Key State Machines\n\n### Link States\nPENDING -> HANDSHAKE -> ACTIVE -> STALE -> CLOSED\n\n### Resource States\nNONE -> QUEUED -> ADVERTISED -> TRANSFERRING -> AWAITING_PROOF -> COMPLETE\n\n### Packet Receipt States\nSENT -> DELIVERED or FAILED\n\n## Integration Points for Columba\n\n### 1. Identity Management\n- Create/load Identity objects\n- Store in ~/.reticulum/storage/identities/\n- Map to Kotlin cryptography\n\n### 2. Destination Registration\n- Register incoming destinations\n- Set packet callbacks\n- Handle announces\n\n### 3. Link Handling\n- Accept/initiate links\n- Use request() for RPC\n- Channel for streaming\n\n### 4. Transport Interface\n- Implement Interface subclass\n- Connect via LocalInterface\n- Or custom interface type"}],["entry_1770159671702_545r",{"id":"entry_1770159671702_545r","key":"fix-columba-1e-anr-oneway","namespace":"fixes","content":"COLUMBA-1E: ANR in setConversationActive during ViewModel.onCleared(). Root cause: synchronous Binder IPC on main thread blocks during navigation. Fix: Add 'oneway' modifier to AIDL method (IReticulumService.aidl line 253). The oneway modifier makes IPC fire-and-forget - caller doesn't block waiting for service response. Safe when: method returns void, operation is atomic, no confirmation needed. PR #409. Pattern applies to other void AIDL methods called during lifecycle events."}],["entry_1770159676345_vjeen",{"id":"entry_1770159676345_vjeen","key":"pattern-anr-prevention-lifecycle","namespace":"patterns","content":"ANR Prevention in Android Lifecycle Methods: ViewModel.onCleared(), Activity.onDestroy(), Fragment.onDestroyView() run on main thread. Any blocking operation (IPC, disk I/O, network) risks ANR. Solutions: 1) AIDL 'oneway' for fire-and-forget IPC, 2) Launch coroutine with non-blocking scope, 3) Post to background handler. Never use runBlocking in lifecycle methods. See THREADING_REDESIGN_PLAN.md Phase 1.2 for Columba's zero-runBlocking policy."}],["entry_1770159683311_dxohoa",{"id":"entry_1770159683311_dxohoa","key":"session-claude-flow-setup","namespace":"session","content":"Claude-flow v3 setup completed for Columba: 1) Daemon running, 2) Hybrid memory with HNSW indexing at .swarm/memory.db, 3) Neural patterns trained (150 patterns in ReasoningBank), 4) MCP server configured. Memory contains: 12 codebase docs (Columba architecture, BLE, testing), 30 protocol docs (Reticulum, LXMF, LXST deep knowledge). Use 'npx @claude-flow/cli@alpha memory search --query X' for semantic search across all knowledge."}],["entry_1770184660729_gxn0nk",{"id":"entry_1770184660729_gxn0nk","key":"audio-debug-findings-2026-02-04","namespace":"columba-audio","content":"{\"issue\":\"Voice call audio delayed and choppy despite native filterlib loading\",\"symptoms\":[\"Filters taking 14-102ms per frame (should be <1ms with native)\",\"Total frame time 170ms+ (should be ~60ms)\",\"USE_NATIVE_FILTERS may be False despite successful dlopen\"],\"hypothesis\":\"Native library loaded but cffi function bindings failed silently\",\"fix_applied\":\"Renamed .so to .dat to bypass Chaquopy filtering\",\"device\":\"10.0.0.249:35993 (SM-G998U1 arm64)\",\"files_modified\":[\"LXST/Filters.py\",\"LXST/setup.py\",\"columba/app/build.gradle.kts\",\"columba/python/requirements.txt\"]}"}],["entry_1770215445323_la5k8n",{"id":"entry_1770215445323_la5k8n","key":"audio-debug-cffi-slow-2026-02-04","namespace":"columba-audio","content":"{\"diagnosis\":\"cffi native calls slow on Android (0.74-27ms vs expected <0.1ms)\",\"root_causes\":[\"Android GC pauses Python threads\",\"cffi ABI mode overhead significant on Chaquopy\",\"Loading from .dat file bypasses linker optimizations\",\"Each filter call has cffi overhead - BandPass makes 2 calls (HighPass+LowPass)\"],\"timing_breakdown\":{\"ascontiguous\":\"0.01-0.19ms\",\"ffi_cast_setup\":\"0.24-1.82ms\",\"native_call\":\"0.74-27ms (highly variable)\",\"reshape\":\"0.03-0.25ms\"},\"solutions_tried\":[\"Native filterlib loading via .dat - works but slow\",\"Copy to .so in cache - testing\"],\"recommended_fixes\":[\"Move filters to Kotlin/JNI layer\",\"Disable filters if too slow (adaptive)\",\"Process larger blocks less frequently\",\"Pre-allocate all buffers to reduce GC\"]}"}],["entry_1770227046952_pvqlug",{"id":"entry_1770227046952_pvqlug","key":"columba-v0.8.0-milestone","namespace":"columba-planning","content":"{\"milestone\":\"v0.8.0\",\"name\":\"Kotlin LXST Audio Pipeline\",\"goal\":\"Rewrite Python LXST audio pipeline in Kotlin to eliminate JNI bridge latency\",\"motivation\":\"Raw audio (5760 bytes) crosses JNI every 60ms causing 30-50ms latency. After rewrite, only encoded packets (20-60 bytes) cross to Python Reticulum.\",\"phases\":[{\"phase\":7,\"name\":\"Codec Foundation\",\"status\":\"ready\"},{\"phase\":8,\"name\":\"Audio Sources & Sinks\",\"status\":\"pending\"},{\"phase\":9,\"name\":\"Mixer & Pipeline\",\"status\":\"pending\"},{\"phase\":10,\"name\":\"Network Bridge\",\"status\":\"pending\"},{\"phase\":11,\"name\":\"Telephony Integration\",\"status\":\"pending\"},{\"phase\":12,\"name\":\"Quality Verification\",\"status\":\"pending\"}],\"files_to_port\":{\"Codec.kt\":80,\"Opus.kt\":200,\"Codec2.kt\":150,\"Sources.kt\":300,\"Sinks.kt\":300,\"Mixer.kt\":200,\"Network.kt\":180,\"Pipeline.kt\":70,\"Generators.kt\":150,\"Telephony.kt\":800,\"Bridge\":150},\"total_lines\":2900}"}],["entry_1770227052560_2kz5tm",{"id":"entry_1770227052560_2kz5tm","key":"columba-phase7-context","namespace":"columba-planning","content":"{\"phase\":7,\"name\":\"Codec Foundation\",\"goal\":\"Implement Opus and Codec2 codecs in Kotlin with wire-compatible output\",\"decisions\":{\"library_selection\":{\"opus\":\"io.rebble.cobble:opus-jni (android-opus-codec)\",\"codec2\":\"com.ustadmobile.codec2:codec2-android\",\"fallback\":\"none - block until libraries work\",\"bundling\":\"bundle in APK\"},\"wire_format\":{\"compatibility\":\"bit-identical required\",\"documentation\":\"code comments for header bytes\",\"opus_header\":\"0x01\",\"codec2_headers\":\"0x00-0x06 for modes 700C-3200\"},\"api_design\":{\"method_names\":\"exact Python match\",\"sample_format\":\"FloatArray\",\"opus_profiles\":\"all 9 (VOICE_LOW through AUDIO_MAX)\",\"codec2_modes\":\"all 7 (700C through 3200)\"},\"resampling\":{\"priority\":\"quality over CPU\",\"buffers\":\"pre-allocated\",\"library\":\"claude discretion\"}},\"requirements\":[\"CODEC-01\",\"CODEC-02\",\"CODEC-03\"]}"}],["entry_1770227060298_bmt9iw",{"id":"entry_1770227060298_bmt9iw","key":"lxst-python-structure","namespace":"columba-planning","content":"{\"package\":\"LXST\",\"files\":{\"Sources.py\":{\"lines\":361,\"classes\":[\"LineSource\",\"OpusFileSource\",\"Loopback\"],\"methods\":[\"start\",\"stop\",\"ingestJob\"]},\"Sinks.py\":{\"lines\":348,\"classes\":[\"LineSink\",\"OpusFileSink\"],\"methods\":[\"canReceive\",\"handleFrame\",\"start\",\"stop\",\"digestJob\"]},\"Mixer.py\":{\"lines\":177,\"classes\":[\"Mixer\"],\"methods\":[\"start\",\"stop\",\"setGain\",\"mute\",\"unmute\",\"canReceive\",\"handleFrame\",\"mixerJob\"]},\"Network.py\":{\"lines\":145,\"classes\":[\"SignallingReceiver\",\"Packetizer\",\"LinkSource\"],\"methods\":[\"signal\",\"handleFrame\",\"packet\"]},\"Pipeline.py\":{\"lines\":58,\"classes\":[\"Pipeline\"],\"methods\":[\"start\",\"stop\"]},\"Filters.py\":{\"lines\":398,\"classes\":[\"HighPass\",\"LowPass\",\"BandPass\",\"AGC\"],\"status\":\"already in Kotlin\"},\"Generators.py\":{\"lines\":134,\"classes\":[\"ToneSource\"],\"methods\":[\"start\",\"stop\",\"generate\"]},\"Codecs/Codec.py\":{\"lines\":62,\"classes\":[\"Codec\",\"Null\"],\"functions\":[\"resample\",\"resampleBytes\"]},\"Codecs/Opus.py\":{\"lines\":167,\"classes\":[\"Opus\"],\"methods\":[\"encode\",\"decode\",\"setProfile\",\"updateBitrate\"]},\"Codecs/Codec2.py\":{\"lines\":121,\"classes\":[\"Codec2\"],\"methods\":[\"encode\",\"decode\",\"setMode\"]},\"Primitives/Telephony.py\":{\"lines\":732,\"classes\":[\"Profiles\",\"Signalling\",\"Telephone\"],\"methods_count\":47}},\"total_lines\":2703}"}],["entry_1770231811726_0il8q",{"id":"entry_1770231811726_0il8q","key":"phase7-codec-decisions","namespace":"columba-lxst","content":"{\"phase\":\"07-codec-foundation\",\"milestone\":\"v0.8.0 Kotlin LXST Audio Pipeline\",\"key_decision\":\"decode-compatible (not bit-identical)\",\"rationale\":\"Different encoder implementations produce different bytes but all produce valid packets decodable by any compliant decoder. What matters for LXST interop is cross-implementation decode working correctly.\",\"success_criteria\":{\"opus\":\"Packets from Kotlin decodable by Python pyogg with intelligible audio\",\"codec2\":\"Packets from Kotlin decodable by Python pycodec2 with intelligible audio, correct header bytes 0x00-0x06\"},\"libraries\":{\"opus\":\"io.rebble.cobble:opus-jni (verify on Maven Central first)\",\"codec2\":\"com.ustadmobile.codec2:codec2-android (verify on Maven Central first)\"},\"resampling\":\"Android SRC (Kaiser-windowed sinc) via AudioTrack\",\"plans\":[\"07-01-PLAN.md (base codec, resample)\",\"07-02-PLAN.md (Opus 9 profiles)\",\"07-03-PLAN.md (Codec2 7 modes)\"],\"wave_structure\":\"Wave 1: 07-01, Wave 2: 07-02 + 07-03 parallel\"}"}],["entry_1770231817670_3insgd",{"id":"entry_1770231817670_3insgd","key":"lxst-wire-format","namespace":"columba-lxst","content":"{\"codec2_headers\":{\"1200\":\"0x01\",\"1300\":\"0x02\",\"1400\":\"0x03\",\"1600\":\"0x04\",\"2400\":\"0x05\",\"3200\":\"0x06\",\"700C\":\"0x00\"},\"opus_profiles\":{\"VOICE_LOW\":\"0x00 - 1ch, 8kHz, voip, 6kbps\",\"VOICE_MEDIUM\":\"0x01 - 1ch, 24kHz, voip, 8kbps\",\"VOICE_HIGH\":\"0x02 - 1ch, 48kHz, voip, 16kbps\",\"VOICE_MAX\":\"0x03 - 2ch, 48kHz, voip, 32kbps\",\"AUDIO_MIN\":\"0x04 - 1ch, 8kHz, audio, 8kbps\",\"AUDIO_LOW\":\"0x05 - 1ch, 12kHz, audio, 14kbps\",\"AUDIO_MEDIUM\":\"0x06 - 2ch, 24kHz, audio, 28kbps\",\"AUDIO_HIGH\":\"0x07 - 2ch, 48kHz, audio, 56kbps\",\"AUDIO_MAX\":\"0x08 - 2ch, 48kHz, audio, 128kbps\"},\"packet_format\":\"header_byte + encoded_data\",\"interop_requirement\":\"decode-compatible (not bit-identical)\"}"}],["entry_1770231823059_u4ckr",{"id":"entry_1770231823059_u4ckr","key":"kotlin-lxst-file-mapping","namespace":"columba-lxst","content":"{\"phase7_files\":{\"Codec.kt\":\"Base codec interface, Null passthrough, resample utilities (~80 lines)\",\"Opus.kt\":\"Opus encoder/decoder, 9 profiles, bitrate ceiling (~200 lines)\",\"Codec2.kt\":\"Codec2 encoder/decoder, 7 modes, header byte handling (~150 lines)\"},\"target_package\":\"com.lxmf.messenger.reticulum.audio.codec\",\"python_reference\":{\"Codec.py\":\"app/build/python/pip/noSentryDebug/common/LXST/Codecs/Codec.py\",\"Opus.py\":\"app/build/python/pip/noSentryDebug/common/LXST/Codecs/Opus.py\",\"Codec2.py\":\"app/build/python/pip/noSentryDebug/common/LXST/Codecs/Codec2.py\"},\"api_match\":\"encode(), decode(), setProfile(), setMode() - exact Python method names\"}"}]]